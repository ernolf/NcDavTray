# NDT.ps1

# SPDX-FileCopyrightText: 2025 [ernolf] Raphael Gradenwitz <raphael.gradenwitz@googlemail.com>
# SPDX-License-Identifier: GPL-3.0-or-later

[CmdletBinding()] param([ValidateSet('', 'Install', 'ExportPortable', 'CacheAgent')] [string]$Action = '', [switch]$Watchdog, [string]$MainMutexName, [int]$OwnerPid, [int]$IntervalSeconds = 3)

# --- Anchor current script path/name/dir for later use (PS 5.1 safe) ---
try { if (-not $script:ThisScriptPath -and $PSCommandPath) { $script:ThisScriptPath = $PSCommandPath } } catch {}
try { if (-not $script:ThisScriptPath -and $MyInvocation -and $MyInvocation.MyCommand -and $MyInvocation.MyCommand.Path) { $script:ThisScriptPath = $MyInvocation.MyCommand.Path } } catch {}

# --- App meta ---
$Version = '1.2.1'
$Author = '[ernolf] Raphael Gradenwitz'
$ProjectUrl = 'https://github.com/ernolf/NcDavTray'

# ================================================================
#	Bootstrap / Process requirements (PowerShell 5.1 + STA)
# ================================================================
if (-not $Watchdog) {
	$needWinPS51 = ($PSVersionTable.PSEdition -ne 'Desktop' -or $PSVersionTable.PSVersion.Major -ne 5 -or $PSVersionTable.PSVersion.Minor -lt 1)
	$needSTA = ([System.Threading.Thread]::CurrentThread.ApartmentState -ne 'STA')
	if ($needWinPS51 -or $needSTA) { $exe = "$env:SystemRoot\System32\WindowsPowerShell\v1.0\powershell.exe"; $args = "-WindowStyle Hidden -NoProfile -STA -ExecutionPolicy Bypass -File `"$PSCommandPath`""; Start-Process -FilePath $exe -ArgumentList $args -WindowStyle Hidden | Out-Null; exit }
}

# ================================================================
#	Native types (P/Invoke) and WinForms setup
#	- Nc.Dpi, Nc.NetUse, Nc.WinFormsOnce, Nc.Shell
# ================================================================
# --- DPI: minimal (process-wide) ---
if (-not ("Nc.Dpi" -as [type])) {
	try {
		Add-Type -TypeDefinition @'
using System;
using System.Runtime.InteropServices;
namespace Nc {
	public static class Dpi {
		[DllImport("user32.dll", SetLastError = false)]
		static extern bool SetProcessDpiAwarenessContext(IntPtr value);
		[DllImport("shcore.dll", SetLastError = false)]
		static extern int SetProcessDpiAwareness(int value); // 0 = Unaware, 1 = System, 2 = PerMonitor
		[DllImport("user32.dll", SetLastError = false)]
		static extern bool SetProcessDPIAware();
		static readonly IntPtr PER_MONITOR_V2 = (IntPtr)(-4);
		public static void EnableBest() {
			try { if (SetProcessDpiAwarenessContext(PER_MONITOR_V2)) return; } catch {}
			try { if (SetProcessDpiAwareness(2) == 0) return; } catch {}
			try { SetProcessDPIAware(); } catch {}
		}
	}
}
'@
	} catch {}
}
[Nc.Dpi]::EnableBest() | Out-Null

Add-Type -AssemblyName System.Windows.Forms, System.Drawing

# --- Win32 WebDAV mapping via WNetAddConnection2 (no password in cmdline) ---
if (-not ("Nc.NetUse" -as [type])) {
	Add-Type -TypeDefinition @'
using System;
using System.Runtime.InteropServices;
namespace Nc {
	public static class NetUse {
		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		public struct NETRESOURCE {
			public uint dwScope;
			public uint dwType;
			public uint dwDisplayType;
			public uint dwUsage;
			public string lpLocalName;
			public string lpRemoteName;
			public string lpComment;
			public string lpProvider;
		}
		[DllImport("mpr.dll", CharSet = CharSet.Unicode)]
		public static extern int WNetAddConnection2(ref NETRESOURCE nr, string password, string username, uint flags);
		[DllImport("mpr.dll", CharSet = CharSet.Unicode)]
		public static extern int WNetCancelConnection2(string name, uint flags, bool force);
		public const uint RESOURCETYPE_DISK = 0x00000001;
		public const uint CONNECT_UPDATE_PROFILE = 0x00000001;
	}
}
'@
}

# Important: this must be called before the first WinForms window
# Call once per process:
# SetCompatibleTextRenderingDefault() must be invoked before any WinForms control/window
# is created (first IWin32Window) and only once.
# Re-running this script in the same PowerShell session throws a MethodInvocationException
# with an InvalidOperationException (via FullyQualifiedErrorId).
# This is why we use a one-time guard:
if (-not ("Nc.WinFormsOnce" -as [type])) {
	Add-Type -TypeDefinition @'
namespace Nc { public static class WinFormsOnce { public static bool Done; } }
'@
}
if (-not [Nc.WinFormsOnce]::Done) {
	[System.Windows.Forms.Application]::EnableVisualStyles()
	try { [System.Windows.Forms.Application]::SetCompatibleTextRenderingDefault($false) } catch {}
	[Nc.WinFormsOnce]::Done = $true
}

# Shell refresh (one-time type)
if (-not ("Nc.Shell" -as [type])) {
	Add-Type -TypeDefinition @'
using System;
using System.Runtime.InteropServices;
namespace Nc {
	public static class Shell {
		[DllImport("shell32.dll")]
		public static extern void SHChangeNotify(uint wEventId, uint uFlags, IntPtr dwItem1, IntPtr dwItem2);
		[DllImport("shell32.dll", CharSet = CharSet.Unicode)]
		public static extern void SHChangeNotify(uint wEventId, uint uFlags, string pszItem1, string pszItem2);
	}
}
'@
}

# P/Invoke: DestroyIcon from user32.dll to release HICON handles created by Bitmap.GetHicon().
# Why: Icon.FromHandle does NOT take ownership; without DestroyIcon, GDI handles leak over time.
# Used by: New-StatusIcon() and Save-IconFromBitmap() when cloning icons from HICON.
# Load once; guarded so re-running the script won't re-add the type.
if (-not ('Nc.Win32' -as [type])) {
	Add-Type -Namespace Nc -Name Win32 -MemberDefinition @"
[System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)]
public static extern bool DestroyIcon(System.IntPtr hIcon);
"@
}

$ErrorActionPreference = 'Stop'
[System.AppDomain]::CurrentDomain.add_ProcessExit({ try { Unmap-DriveIfOurs -Force -RemoveProfile } catch {} })

# ================================================================
#	App constants, paths, globals, state
# ================================================================
# ---------- Constants / paths ----------
$AppName = 'NcDavTray'
$AppNameShort = 'NDT'
$HereDir = Split-Path -Parent $PSCommandPath
$ScriptFile = [System.IO.Path]::GetFileName($PSCommandPath)
$RegBase = ("HKCU:\Software\{0}" -f $AppName)
$RunKey = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Run'
$RegMP2 = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\MountPoints2'
$RegWebClient = 'HKLM:\SYSTEM\CurrentControlSet\Services\WebClient\Parameters'
$InstallDir = Join-Path $env:LOCALAPPDATA $AppName
$InstallBin = Join-Path $InstallDir $ScriptFile
$WDMutex = ("Local\{0}Watchdog" -f $AppName)
$PortJson = Join-Path $HereDir ("{0}_portable.json" -f $AppName)
$SecretPath = Join-Path $HereDir ("{0}_secret.dat" -f $AppNameShort)
$IsInstalled = ($PSCommandPath -ieq $InstallBin)
$PortableMode = -not $IsInstalled
$ernolfB64 = @'
iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAAwXpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjabVDBDcMwCPwzRUewgRA8jtO4Ujfo+MWGRHHTk3zAEV0AaJ/3Cx4dmBl4WVWKSDJw4YLVEk2OOjgnHjzwjJbVkw5nA00ii+SlSnx/6Pk08FAtWy5GGk55mxuFw19/jNAD9Yl6vodRCSNCb+QwqL5WkqLrdYWtpRnqDzqxzGPf6tWuty/2H0JslCkZE7EPQP0RULVEjJEYXe4KD+VY1Q7y704H4Atk51lmyFwsngAAAYRpQ0NQSUNDIHByb2ZpbGUAAHicfZE9SMNAHMVfU7UiFUE7lOKQoTrZRUUcpYpFsFDaCq06mFz6BU0akhQXR8G14ODHYtXBxVlXB1dBEPwAcXVxUnSREv+XFFrEeHDcj3f3HnfvAKFZZarZMweommWkE3Exl18VA6/oQxjDEBCRmKknM4tZeI6ve/j4ehfjWd7n/hyDSsFkgE8knmO6YRFvEM9sWjrnfeIQK0sK8TnxhEEXJH7kuuzyG+eSwwLPDBnZ9DxxiFgsdbHcxaxsqMTTxFFF1ShfyLmscN7irFbrrH1P/sJgQVvJcJ3mKBJYQhIpiJBRRwVVWIjRqpFiIk37cQ9/xPGnyCWTqwJGjgXUoEJy/OB/8Ltbszg16SYF40Dvi21/jAGBXaDVsO3vY9tunQD+Z+BK6/hrTWD2k/RGR4seAUPbwMV1R5P3gMsdIPykS4bkSH6aQrEIvJ/RN+WBkVtgYM3trb2P0wcgS10t3wAHh8B4ibLXPd7d393bv2fa/f0AeV1yqeqTYGoAAA12aVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA0LjQuMC1FeGl2MiI+CiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOjE2MTM3NmM5LTFmYzktNGVhZC05MjMwLTE1Mjc0YzhhZWY4ZCIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0YzNjMzVjZi1kYzgxLTRjNGMtYjE3NS0yZDhjZTg0ZjBjYjciCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDoxM2JlZDgwZC1iYTY1LTQ0MDYtYTA0YS0yMDQ1ZTg2ZmY2YjUiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJXaW5kb3dzIgogICBHSU1QOlRpbWVTdGFtcD0iMTY4NzYyOTg4MTY1NjA4NSIKICAgR0lNUDpWZXJzaW9uPSIyLjEwLjM0IgogICB0aWZmOk9yaWVudGF0aW9uPSIxIgogICB4bXA6Q3JlYXRvclRvb2w9IkdJTVAgMi4xMCIKICAgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMzowNjoyNFQyMDowNDoyNSswMjowMCIKICAgeG1wOk1vZGlmeURhdGU9IjIwMjM6MDY6MjRUMjA6MDQ6MjUrMDI6MDAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDplOTcwYzU0Yy0yZjM3LTQ4NDctYTNhNi01YzQwZjQxYjUwOTIiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoV2luZG93cykiCiAgICAgIHN0RXZ0OndoZW49IjIwMjMtMDYtMjRUMjA6MDQ6NDEiLz4KICAgIDwvcmRmOlNlcT4KICAgPC94bXBNTTpIaXN0b3J5PgogIDwvcmRmOkRlc2NyaXB0aW9uPgogPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+w5PFVAAAAARnQU1BAACxjwv8YQUAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACsQAAArEAWZtgtQAAAAHdElNRQfnBhgSBCnkBCE8AAAgAElEQVR42uy9ebCld1rf95x938/d7+1NLakltUYzGo2EBtAsCHsYxkzGg1PgAC6bCpgQEmxXJZU4KWMMBleqkknssrE9wZAiHicxwUyMITMaNMz0TEtI6p5WS72q97udfd/vOSd/0J9fvudVAwNoFkBddUvqvveec973/T3b9/k+38c3n8/t7T9f3Z/5fG7z+dxms5kdHBzYZDKx0WhkL7zwgvX7/cxgMLhvNpsdnc1m65PJ5FCr1SoOBoPV6XSaM7OMmaWn02liNptFRqNRaDgcBmazmc1ms2k0Gp3EYrGh3+/vJRKJdjAYbEYikUYsFtuPRCKVWCx2OxwO785msxvT6fRaIBDovv/977doNGqhUMiCwaD5/X7z+Xzm8/neflhf5R/f2wbwBx94DvtoNLIf+7Efs+/8zu9MdLvdx9rt9jv7/f6j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
'@
$Logo96B64 = @'
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
'@
$LogoIcoB64 = @'
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
'@
# --- One-time global flag ---
if ($null -eq $script:ResetRequested) { $script:ResetRequested = $false }
if ($null -eq $script:MissingSecretsPrompted) { $script:MissingSecretsPrompted = $false }
if ($null -eq $script:MissingPwdPrompted) { $script:MissingPwdPrompted = $false }
if ($null -eq $script:WebClientServicePrompted) { $script:WebClientServicePrompted = $false }
if ($null -eq $script:BasicAuthWarned) { $script:BasicAuthWarned = $false }
if ($null -eq $script:ServiceDeactivated) { $script:ServiceDeactivated = $false }
if ($null -eq $script:CacheWatcherLiveUpdate) { $script:CacheWatcherLiveUpdate = $true }
if ($null -eq $script:CacheWatcherPanel) { $script:CacheWatcherPanel = $null }
if ($null -eq $script:CacheWatcherDetailsPanel) { $script:CacheWatcherDetailsPanel = $null }
if ($null -eq $script:CacheWatcherStatusLabel) { $script:CacheWatcherStatusLabel = $null }
if ($null -eq $script:CacheWatcherLiveCheckbox) { $script:CacheWatcherLiveCheckbox = $null }
if ($null -eq $script:CacheWatcherPresent) { $script:CacheWatcherPresent = $false }
if ($null -eq $script:CacheStopPending) { $script:CacheStopPending = $false }
if ($null -eq $script:CacheStartPending) { $script:CacheStartPending = $false }
if ($null -eq $script:LastCacheSnapshotSignature) { $script:LastCacheSnapshotSignature = $null }
if ($null -eq $script:CacheForceRefreshOnce) { $script:CacheForceRefreshOnce = $false }
# --- Global UI metrics (compute once, DPI-aware) ---
# Default button height (non-shield buttons)
if (-not $script:ButtonH) { $script:ButtonH = 28 }
# Extra high button height (non-shield buttons)
if (-not $script:ButtonXH) { $script:ButtonXH = 32 }
# Default vertical padding for button rows
if (-not $script:ButtonPadY) { $script:ButtonPadY = 8 }
# Minimal logical width for small dialog buttons (OK / Yes / No / Cancel)
if (-not $script:ButtonMinW) { $script:ButtonMinW = 80 }
# Top offset for inline copy URL button
if (-not $script:ButtonCopyOffsetY) { $script:ButtonCopyOffsetY = -2 }
# Button height big enough for the shield + breathing space
if (-not $script:UacButtonH) { $script:UacButtonH = 40; $script:UacPadY = 0 <# vertical padding in panels #>; $script:UacFooterH = $script:UacButtonH + (2 * $script:UacPadY); $script:UacGroupH = $script:UacButtonH + (2 * $script:UacPadY) }
# Set once: desired shield size in pixels (e.g., 32 or 36)
$script:UAC_SHIELD_PX = 30
function Enable-UacShield([System.Windows.Forms.Button]$btn) {
	try {
		if (-not $btn -or $btn.IsDisposed) { return }
		$null = $btn.Handle
		# Disable OS overlay so custom size is used
		if (-not ('Ndt_Native' -as [type])) {
			Add-Type -Namespace Ndt -Name Native -MemberDefinition @"
[System.Runtime.InteropServices.DllImport("user32.dll", CharSet = System.Runtime.InteropServices.CharSet.Auto)]
public static extern System.IntPtr SendMessage(System.IntPtr hWnd, uint Msg, System.IntPtr wParam, System.IntPtr lParam);
"@
		}
		[Ndt.Native]::SendMessage($btn.Handle,0x160C,[IntPtr]0,[IntPtr]0) | Out-Null # BCM_SETSHIELD FALSE
		$px = [math]::Max(8,[int]$script:UAC_SHIELD_PX)
		try { if ($btn.Image) { $btn.Image.Dispose() } } catch {}
		$ico = [System.Drawing.SystemIcons]::Shield
		$bmp = New-Object System.Drawing.Bitmap $px,$px
		$g = [System.Drawing.Graphics]::FromImage($bmp)
		$g.InterpolationMode = 'HighQualityBicubic'
		$g.SmoothingMode = 'HighQuality'
		$g.PixelOffsetMode = 'HighQuality'
		$g.Clear([System.Drawing.Color]::Transparent)
		$g.DrawImage($ico.ToBitmap(),0,0,$px,$px)
		$g.Dispose()
		$btn.FlatStyle = [System.Windows.Forms.FlatStyle]::Standard
		$btn.Image = $bmp
		$btn.ImageAlign = [System.Drawing.ContentAlignment]::MiddleLeft
		$btn.TextImageRelation = [System.Windows.Forms.TextImageRelation]::ImageBeforeText
		if ($btn.Padding.Left -lt 6) { $btn.Padding = New-Object System.Windows.Forms.Padding(16,0,16,0) }
	} catch {}
}
# Always show a small UAC shield bitmap; no OS overlay used
function Enable-FlatUacShield([System.Windows.Forms.Button]$btn) {
	try {
		if (-not $btn -or $btn.IsDisposed) { return }
		# Ensure handle exists
		$null = $btn.Handle
		# Import SendMessage once (local helper type)
		if (-not ('Ndt_Native' -as [type])) {
			Add-Type -Namespace Ndt -Name Native -MemberDefinition @"
[System.Runtime.InteropServices.DllImport("user32.dll", CharSet = System.Runtime.InteropServices.CharSet.Auto)]
public static extern System.IntPtr SendMessage(System.IntPtr hWnd, uint Msg, System.IntPtr wParam, System.IntPtr lParam);
"@
		}
		# Use OS-drawn UAC shield via BCM_SETSHIELD so look is consistent everywhere
		$btn.FlatStyle = [System.Windows.Forms.FlatStyle]::System
		[Ndt.Native]::SendMessage($btn.Handle, 0x160C, [IntPtr]0, [IntPtr]1) | Out-Null
		$btn.Padding = New-Object System.Windows.Forms.Padding(16, 0, 16, 0)
	} catch {}
}
# --- UI font (tray glyph & any small labels) ---
$UiFontFamily = 'Tahoma'
$UiFontStyleRegular = [System.Drawing.FontStyle]::Regular
$UiFontStyleBold = [System.Drawing.FontStyle]::Bold

# Optional: fall back if the font isn't installed
if (-not (([System.Drawing.FontFamily]::Families | ForEach-Object Name) -contains $UiFontFamily)) { $UiFontFamily = 'Segoe UI' }

# ---------- State ----------
$State = [pscustomobject]@{ Server = ''; User = ''; SubPath = ''; Drive = ''; Label = ''; IntervalS = 15; EncPass = ''; LangPref = '' }
$script:PlainPassCache = $null; $script:AskedPassphrase = $false; $script:NeedsSetup = $true; $script:mapMutexObj = $null; $script:mapMutexName = $null; $script:mapMutexOwned = $false; $script:Paused = $false
# --- Image cache (in-memory) ---
$script:ServerFaviconBmp = $null; $script:UserAvatarBmp = $null
# Settings dialog singleton tracking
$script:SettingsForm = $null; $script:IsSettingsOpen = $false

# Reset leftover script-scope state (safe for multiple loads)
if ($script:WebClientRegTimer) { try { $script:WebClientRegTimer.Stop(); $script:WebClientRegTimer.Dispose() } catch {}; $script:WebClientRegTimer = $null }
if ($script:FaviconTimer) { try { $script:FaviconTimer.Stop(); $script:FaviconTimer.Dispose() } catch {}; $script:FaviconTimer = $null }
if ($script:AvatarTimer) { try { $script:AvatarTimer.Stop(); $script:AvatarTimer.Dispose() } catch {}; $script:AvatarTimer = $null }
$script:RebuildDriveList = $null; $script:UpdateWebClientRegView = $null; $script:InvokeWebClientActionAsync = $null; $script:UpdateSvc = $null

# ================================================================
# Config schema helpers
# ================================================================
# List of all "normal" config keys that apply everywhere (portable, installed, etc.)
$script:ConfigKeys = @( 'Server', 'User', 'SubPath', 'Drive', 'Label', 'IntervalS', 'LangPref' )
# Build a neutral/portable config object from $State (without DPAPI secret)
function New-StateConfigObject { $ht = @{}; foreach ($k in $script:ConfigKeys) { $val = $State.$k; if ($k -eq 'IntervalS') { $val = [int]$val }; $ht[$k] = $val }; return New-Object psobject -Property $ht }
# Build export object for Export-InstalledConfig (adds DPAPI secret as 'DPAPI')
function New-InstalledExportObject { $obj = New-StateConfigObject; $dp = $State.EncPass; Add-Member -InputObject $obj -MemberType NoteProperty -Name 'DPAPI' -Value $dp -Force; return $obj }
function Copy-ObjectToState {
	[CmdletBinding()] param( [Parameter(Mandatory = $true)][object]$Source, [switch]$IncludeSecret )
	foreach ($k in $script:ConfigKeys) { if ($Source.PSObject.Properties.Name -contains $k) { if ($k -eq 'IntervalS') { $State.$k = [int]($Source.$k) } else { $State.$k = $Source.$k } } }
	if ($IncludeSecret) {
		# from registry/json with EncPass
		if ($Source.PSObject.Properties.Name -contains 'EncPass') { $State.EncPass = $Source.EncPass }
		# from exported installed config (DPAPI key)
		if ($Source.PSObject.Properties.Name -contains 'DPAPI') { $State.EncPass = $Source.DPAPI }
	}
}
function Write-StateToRegistry {
	# Persist current $State into registry (installed mode)
	if (-not (Test-Path $RegBase)) { New-Item -Path $RegBase -Force | Out-Null }
	foreach ($k in $script:ConfigKeys) {
		$type = if ($k -eq 'IntervalS') { 'DWord' } else { 'String' }
		$val = if ($k -eq 'IntervalS') { [int]$State.IntervalS } else { $State.$k }
		New-ItemProperty -Path $RegBase -Name $k -Value $val -PropertyType $type -Force | Out-Null
	}
	# DPAPI-protected password blob
	New-ItemProperty -Path $RegBase -Name 'EncPass' -Value ($State.EncPass) -PropertyType String -Force | Out-Null
}

# ================================================================
#	Utility helpers (UI DPI hook, embedded resources)
# ================================================================
function Hook-FormDpi([System.Windows.Forms.Form]$f) { if (-not $f) { return }; $f.AutoScaleMode = 'Dpi' }
# ---------- launcher (installed only) ----------
function Get-LauncherFor([string]$scriptPath) {
	$vbsFile = [System.IO.Path]::ChangeExtension($scriptPath, 'vbs')
	$line = 'CreateObject("Wscript.Shell").Run "powershell.exe -NoProfile -ExecutionPolicy Bypass -STA -WindowStyle Hidden -File ""' + $scriptPath + '""", 0, False'
	if (-not (Test-Path $vbsFile) -or (Get-Content -Raw -Path $vbsFile -ErrorAction SilentlyContinue) -ne $line) { Set-Content -Path $vbsFile -Value $line -Encoding ASCII }
	return @("$env:SystemRoot\System32\wscript.exe", "`"$vbsFile`"")
}
# --- Robust script-path resolver (PS 5.1 safe) ---
function Get-ThisScriptPath {
	[CmdletBinding()] param( [string]$FallbackName = "$($AppNameShort).ps1" )
	try {
		# Prefer an explicit anchor if present and valid
		if ($script:ThisScriptPath -and (Test-Path -LiteralPath $script:ThisScriptPath)) { return (Resolve-Path -LiteralPath $script:ThisScriptPath).Path }
		# PSCommandPath is set in scripts
		if ($PSCommandPath -and (Test-Path -LiteralPath $PSCommandPath)) { return (Resolve-Path -LiteralPath $PSCommandPath).Path }
		# MyInvocation works in many contexts
		if ($MyInvocation -and $MyInvocation.MyCommand -and $MyInvocation.MyCommand.Path) { $mi = $MyInvocation.MyCommand.Path; if (Test-Path -LiteralPath $mi) { return (Resolve-Path -LiteralPath $mi).Path } }
		# Try PSScriptRoot + known filename
		if ($PSScriptRoot) { $try1 = Join-Path $PSScriptRoot $FallbackName; if (Test-Path -LiteralPath $try1) { return (Resolve-Path -LiteralPath $try1).Path } }
		# Try current directory + known filename (last resort)
		$try2 = Join-Path (Get-Location).Path $FallbackName
		if (Test-Path -LiteralPath $try2) { return (Resolve-Path -LiteralPath $try2).Path }
		return $null
	} catch { return $null }
}

# ================================================================
#	Cache agent glue
# ================================================================
function Get-CacheAgentStateDir {
	$base = [Environment]::GetFolderPath('LocalApplicationData')
	$dir = Join-Path $base ("{0}\CacheAgent" -f $AppName)
	if (-not (Test-Path -LiteralPath $dir)) { try { New-Item -ItemType Directory -Path $dir -Force | Out-Null } catch {} }
	return $dir
}
function Get-CacheAgentStatePath { $dir = Get-CacheAgentStateDir; return (Join-Path $dir 'state.json') }
function Get-CacheAgentCommandPath { $dir = Get-CacheAgentStateDir; return (Join-Path $dir 'command.json') }
function Get-CacheAgentPidPath { $dir = Get-CacheAgentStateDir; return (Join-Path $dir 'pids.json') }
function Get-CacheAgentState {
	# Reads current state.json from the cache agent (if present)
	$path = Get-CacheAgentStatePath
	if (-not (Test-Path -LiteralPath $path)) { return $null }
	try {
		$raw = Get-Content -LiteralPath $path -Raw -ErrorAction Stop
		if (-not $raw) { return $null }
		return ($raw | ConvertFrom-Json -ErrorAction Stop)
	} catch { return $null }
}
function Send-CacheAgentCommand([Parameter(Mandatory = $true)][hashtable]$Command) {
	$path = Get-CacheAgentCommandPath
	$tmp = $path + '.tmp'
	try {
		$json = $Command | ConvertTo-Json -Depth 4
		$json | Set-Content -LiteralPath $tmp -Encoding UTF8
		Move-Item -LiteralPath $tmp -Destination $path -Force
		return $true
	} catch { return $false }
}
function Request-CacheDeleteAll { $cmd = @{ Action = 'DeleteAll' }; return (Send-CacheAgentCommand -Command $cmd) }
function Start-CacheAgentElevated([int]$IntervalSeconds = 3) {
	try {
		$scriptPath = Get-ThisScriptPath
		if ([string]::IsNullOrWhiteSpace($scriptPath) -or -not (Test-Path -LiteralPath $scriptPath)) { return $false }
		if ($IntervalSeconds -le 0) { $IntervalSeconds = 3 }
		# Clean up stale command/state files before starting a fresh agent
		try {
			$cmdPath = Get-CacheAgentCommandPath
			if (Test-Path -LiteralPath $cmdPath) { Remove-Item -LiteralPath $cmdPath -Force -ErrorAction SilentlyContinue }
			# also clear a very old state.json so we start clean
			$statePath = Get-CacheAgentStatePath
			if (Test-Path -LiteralPath $statePath) {
				$fi = Get-Item -LiteralPath $statePath -ErrorAction SilentlyContinue
				if ($fi) { $ageSeconds = ([DateTime]::UtcNow - $fi.LastWriteTimeUtc).TotalSeconds; if ($ageSeconds -gt 5) { Remove-Item -LiteralPath $statePath -Force -ErrorAction SilentlyContinue } }
			}
		} catch {}
		$psi = New-Object System.Diagnostics.ProcessStartInfo
		$psi.FileName = "$env:SystemRoot\System32\WindowsPowerShell\v1.0\powershell.exe"
#		$psi.Arguments = "-NoProfile -ExecutionPolicy Bypass -File `"$scriptPath`" -Action CacheAgent -OwnerPid $PID -IntervalSeconds $IntervalSeconds"
		$psi.Arguments = "-NoProfile -ExecutionPolicy Bypass -File `"$scriptPath`" -Action CacheAgent -IntervalSeconds $IntervalSeconds" # No `-OwnerPid $PID`
		$psi.Verb = 'runas'
		$psi.WindowStyle = 'Hidden'
		$psi.UseShellExecute = $true
		[System.Diagnostics.Process]::Start($psi) | Out-Null
		return $true
	} catch { return $false }
}
function Ensure-CacheAgentRunning([int]$IntervalSeconds = 3) {
	# If at least one watcher is registered in pids.json, we are done.
	try {
		$watchersRaw = Get-CacheWatcherEntries
		$watchers = @()
		if ($watchersRaw) { $watchers = @($watchersRaw) } # normalize
		if ($watchers.Count -gt 0) { Write-Verbose ("[CacheGlue] Ensure-CacheAgentRunning: watcher already present (Count={0})" -f $watchers.Count); return $true }
	} catch { Write-Verbose ("[CacheGlue] Ensure-CacheAgentRunning: error while checking watchers: {0}" -f $_.Exception.Message) }
	Write-Verbose ("[CacheGlue] Ensure-CacheAgentRunning: no watcher, starting elevated")
	return (Start-CacheAgentElevated -IntervalSeconds $IntervalSeconds)
}
function Invoke-CacheAgentCommand([hashtable]$cmd,[int]$IntervalSeconds = 3) {
	if (-not $cmd) { return $false }
	if (-not (Ensure-CacheAgentRunning -IntervalSeconds $IntervalSeconds)) { return $false }
	return (Send-CacheAgentCommand -Command $cmd)
}
function Start-CacheWatcher([int]$IntervalSeconds = 3) {
	Write-Verbose ("[CacheGlue] Start-CacheWatcher: requested (IntervalSeconds={0})" -f $IntervalSeconds)
	if ($IntervalSeconds -le 0) { $IntervalSeconds = 3 }
	if (Ensure-CacheAgentRunning -IntervalSeconds $IntervalSeconds) { Write-Verbose ("[CacheGlue] Start-CacheWatcher: Ensure-CacheAgentRunning returned true"); return $true }
	Write-Verbose "[CacheGlue] Start-CacheWatcher: Ensure-CacheAgentRunning returned false"
	return $false
}
function Read-CachePidEntries {
	$path = Get-CacheAgentPidPath
	if (-not (Test-Path -LiteralPath $path)) { Write-Verbose "[CacheGlue] Read-CachePidEntries: pid file not found"; return @() }
	try {
		$raw = Get-Content -LiteralPath $path -Raw -ErrorAction Stop
		if (-not $raw) { Write-Verbose "[CacheGlue] Read-CachePidEntries: pid file is empty"; return @() }
		$data = $raw | ConvertFrom-Json -ErrorAction Stop
		if ($null -eq $data) { Write-Verbose "[CacheGlue] Read-CachePidEntries: json is null"; return @() }
		if ($data -is [System.Collections.IEnumerable] -and -not ($data -is [string])) { $result = @($data) } else { $result = @($data) }
		Write-Verbose ("[CacheGlue] Read-CachePidEntries: read {0} entries" -f $result.Count)
		return $result
	} catch { Write-Verbose ("[CacheGlue] Read-CachePidEntries: ERROR {0}" -f $_.Exception.Message); return @() }
}
function Write-CachePidEntries([object[]]$entries) {
	$path = Get-CacheAgentPidPath; $tmp = $path + '.tmp'
	try {
		Write-Verbose ("[CacheGlue] Write-CachePidEntries: writing {0} entries" -f ($entries.Count))
		$json = $entries | ConvertTo-Json -Depth 4
		$json | Set-Content -LiteralPath $tmp -Encoding UTF8
		Move-Item -LiteralPath $tmp -Destination $path -Force
	} catch {
		Write-Verbose ("[CacheGlue] Write-CachePidEntries: ERROR {0}" -f $_.Exception.Message)
		try { Remove-Item -LiteralPath $tmp -Force -ErrorAction SilentlyContinue } catch {}
	}
}
function Get-AliveCachePidEntries {
	$entries = Read-CachePidEntries
	if (-not $entries -or $entries.Count -eq 0) { Write-Verbose "[CacheGlue] Get-AliveCachePidEntries: no entries"; return @() }
	$alive = @()
	foreach ($e in $entries) {
		[int]$pidValue = 0
		try { $pidValue = [int]$e.Pid } catch { $pidValue = 0 }
		if ($pidValue -le 0) { continue }
		try { $p = Get-Process -Id $pidValue -ErrorAction Stop; if (-not $p.HasExited) { $alive += $e } } catch { <# process dead, skip #> }
	}
	Write-Verbose ("[CacheGlue] Get-AliveCachePidEntries: {0} alive of {1}" -f $alive.Count, $entries.Count)
	if ($alive.Count -ne $entries.Count) { Write-CachePidEntries $alive }
	return $alive
}
function Register-CacheInstance([int]$ProcessId,[string]$Role,[string]$Tag) {
	Write-Verbose ("[CacheGlue] Register-CacheInstance: Pid={0}, Role={1}, Tag={2}" -f $ProcessId, $Role, $Tag)
	$entries = Get-AliveCachePidEntries
	$filtered = @()
	foreach ($e in $entries) {
		[int]$pidValue = 0
		try { $pidValue = [int]$e.Pid } catch { $pidValue = 0 }
		if ($pidValue -eq $ProcessId -and [string]$e.Role -eq $Role) { continue }
		$filtered += $e
	}
	$new = [pscustomobject]@{Pid = $ProcessId; Role = $Role; Tag = $Tag}
	$filtered += $new
	Write-CachePidEntries $filtered
}
function Get-CacheWatcherEntries {
	# Get current alive entries (may be empty if pid file was deleted)
	$alive = Get-AliveCachePidEntries
	# Ensure that THIS process is registered as Ui in the pid set
	$hasOwnUi = $false
	if ($alive -and $alive.Count -gt 0) {
		foreach ($e in $alive) { [int]$pidValue = 0; try { $pidValue = [int]$e.Pid } catch { $pidValue = 0 }; if ($pidValue -eq $PID -and [string]$e.Role -eq 'Ui') { $hasOwnUi = $true; break } }
	}
	if (-not $hasOwnUi) {
		Write-Verbose "[CacheGlue] Get-CacheWatcherEntries: ensuring Ui registration for this process"
		try { Register-CacheInstance -ProcessId $PID -Role 'Ui' -Tag 'main' } catch {} # This recreates pids.json if the watcher deleted it, and adds our own Ui entry
		$alive = Get-AliveCachePidEntries
		if (-not $alive -or $alive.Count -eq 0) { Write-Verbose "[CacheGlue] Get-CacheWatcherEntries: still no alive entries after re-registering Ui"; return @() }
	}
	# Collect watcher entries from the refreshed alive set
	$watchers = @()
	foreach ($e in $alive) { if ([string]$e.Role -eq 'Watcher') { $watchers += $e } }
	Write-Verbose ("[CacheGlue] Get-CacheWatcherEntries: returning {0} watcher entries" -f $watchers.Count)
	return $watchers
}
function Test-AnyCacheUi { $alive = Get-AliveCachePidEntries; if (-not $alive) { return $false }; foreach ($e in $alive) { if ([string]$e.Role -eq 'Ui') { return $true } }; return $false }
function Get-CacheWatcherClearOnExit {
	$entries = Read-CachePidEntries
	if (-not $entries -or $entries.Count -eq 0) { return $true }
	foreach ($e in $entries) {
		if ([string]$e.Role -eq 'Watcher') {
			if ($e.PSObject.Properties.Name -contains 'ClearOnExit') { try { return [bool]$e.ClearOnExit } catch { return $true } }
			return $true # Watcher without flag -> Default = true
		}
	}
	return $true # No watcher entered -> Default = true
}
function Set-CacheWatcherClearOnExit([bool]$value) {
	$entries = Read-CachePidEntries
	if (-not $entries -or $entries.Count -eq 0) { return }
	$changed = $false
	foreach ($e in $entries) {
		if ([string]$e.Role -eq 'Watcher') {
			try {
				if ($e.PSObject.Properties.Name -contains 'ClearOnExit') { $e.ClearOnExit = $value } else { $e | Add-Member -NotePropertyName 'ClearOnExit' -NotePropertyValue $value -Force }
				$changed = $true
			} catch {}
		}
	}
	if ($changed) { Write-CachePidEntries $entries }
}

# ================================================================
#	Cache agent loop (runs when -Action CacheAgent)
# ================================================================
function CacheAgent([int]$OwnerPid,[int]$IntervalSeconds = 3) {
	$ErrorActionPreference = 'Stop'
	if ($IntervalSeconds -le 0) { $IntervalSeconds = 3 }
	$script:CacheAgentStopRequested = $false
	$script:CacheAgentExplicitStopRequested = $false
	Register-CacheInstance -ProcessId $PID -Role 'Watcher' -Tag 'cache'
	try {
		# Ensure watcher entry has a ClearOnExit flag (default true)
		$flag = Get-CacheWatcherClearOnExit
		Set-CacheWatcherClearOnExit -value $flag
	} catch {}
	# WebDAV Redirector cache root for WebClient service
	function Get-CacheSnapshot {
		# Returns a hashtable with basic summary for the cache
		$root = Join-Path $env:WINDIR 'ServiceProfiles\LocalService\AppData\Local\Temp\TfsStore\Tfs_DAV'
		$snapshot = [ordered]@{ Root = $root; Exists = $false; TotalBytes = 0; FileCount = 0; NewestWriteTimeUtc = $null; OldestWriteTimeUtc = $null; Files = @() }
		if (-not $root -or -not (Test-Path -LiteralPath $root)) { return $snapshot }
		$snapshot.Exists = $true; $newest = $null; $oldest = $null; [int64]$totalBytes = 0; [int]$count = 0; $files = @()
		try {
			Get-ChildItem -LiteralPath $root -Recurse -File -ErrorAction Stop | ForEach-Object {
				$count++
				$len = [int64]$_.Length
				$totalBytes += $len
				$wt = $_.LastWriteTimeUtc
				if (-not $newest -or $wt -gt $newest) { $newest = $wt }
				if (-not $oldest -or $wt -lt $oldest) { $oldest = $wt }
				$type = [System.IO.Path]::GetExtension($_.Name)
				if ([string]::IsNullOrEmpty($type)) { $type = 'file' } else { $type = $type.TrimStart('.').ToLowerInvariant() }
				$files += [pscustomobject]@{ Name = $_.Name; FullName = $_.FullName; Length = $len; LastWriteTimeUtc = $wt; Type = $type }
			}
		} catch { } # Partial failure is acceptable, we just return what we have
		$snapshot.TotalBytes = $totalBytes
		$snapshot.FileCount = $count
		$snapshot.Files = $files
		$snapshot.NewestWriteTimeUtc = if ($newest) { $newest.ToString('o') } else { $null }
		$snapshot.OldestWriteTimeUtc = if ($oldest) { $oldest.ToString('o') } else { $null }
		return $snapshot
	}
	function Write-CacheState([Parameter(Mandatory = $true)][hashtable]$Snapshot, [string]$LastAction = $null, [string]$LastError = $null) {
		$statePath = Get-CacheAgentStatePath
		$tmpPath = $statePath + '.tmp'
		$payload = [ordered]@{ TimestampUtc = (Get-Date).ToUniversalTime().ToString('o'); Snapshot = $Snapshot }
		if ($LastAction) { $payload.LastAction = $LastAction }
		if ($LastError) { $payload.LastError = $LastError }
		try {
			$json = $payload | ConvertTo-Json -Depth 6
			$json | Set-Content -LiteralPath $tmpPath -Encoding UTF8
			Move-Item -LiteralPath $tmpPath -Destination $statePath -Force
		} catch { } # If we cannot write state, there is not much else we can do
	}
	function Get-PendingCommand {
		# Reads and deletes command.json atomically. Returns a deserialized object or $null.
		$cmdPath = Get-CacheAgentCommandPath
		if (-not (Test-Path -LiteralPath $cmdPath)) { return $null }
		try {
			$raw = Get-Content -LiteralPath $cmdPath -Raw -ErrorAction Stop
			if (-not $raw) { Remove-Item -LiteralPath $cmdPath -Force -ErrorAction SilentlyContinue; return $null }
			$cmd = $raw | ConvertFrom-Json -ErrorAction Stop
			Remove-Item -LiteralPath $cmdPath -Force -ErrorAction SilentlyContinue
			return $cmd
		} catch { try { Remove-Item -LiteralPath $cmdPath -Force -ErrorAction SilentlyContinue } catch {}; return $null }
	}
	function Execute-CacheCommand([Parameter(Mandatory = $true)][object]$Command, [string]$Root) {
		$result = [ordered]@{ Action = $null; Ok = $false; DeletedCount = 0; DeletedBytes = 0; Error = $null }
		if (-not $Command) { $result.Error = 'Command is null'; return $result }
		$action = [string]$Command.Action
		if ([string]::IsNullOrWhiteSpace($action)) { $result.Error = 'Missing Action field'; return $result }
		$result.Action = $action
		if (-not $Root -or -not (Test-Path -LiteralPath $Root)) { $result.Error = 'Cache root not found'; return $result }
		$rootFull = $null
		try { $rootFull = (Resolve-Path -LiteralPath $Root -ErrorAction Stop).ProviderPath.TrimEnd('\') } catch { $result.Error = 'Could not resolve cache root'; return $result }
		switch ($action.ToLowerInvariant()) {
			'deleteall' {
				try {
					$files = Get-ChildItem -LiteralPath $Root -Recurse -File -ErrorAction SilentlyContinue
					foreach ($f in $files) {
						try {
							$len = [int64]$f.Length
							Remove-Item -LiteralPath $f.FullName -Force -ErrorAction Stop
							$result.DeletedCount++
							$result.DeletedBytes += $len
						} catch {}
					}
					$result.Ok = $true
				} catch { $result.Error = $_.Exception.Message }
			}
			'stop' { $script:CacheAgentStopRequested = $true; $script:CacheAgentExplicitStopRequested = $true; $result.Ok = $true } # Set global stop flag so outer loop can terminate cleanly
			default { $result.Error = "Unknown action '$action'" }
		}
		return $result
	}
	$ownerProcess = $null
	if ($OwnerPid -gt 0) { try { $ownerProcess = Get-Process -Id $OwnerPid -ErrorAction SilentlyContinue } catch { $ownerProcess = $null } }
	try {
		while ($true) {
			# Clean dead PIDs at every tick
			Get-AliveCachePidEntries | Out-Null
			if ($OwnerPid -gt 0) { # If owner process is gone, request a clean stop
				if ($ownerProcess -eq $null) { $ownerProcess = Get-Process -Id $OwnerPid -ErrorAction SilentlyContinue; if (-not $ownerProcess) { $script:CacheAgentStopRequested = $true } }
				else { try { $ownerProcess.Refresh(); if ($ownerProcess.HasExited) { $script:CacheAgentStopRequested = $true } } catch { $script:CacheAgentStopRequested = $true } }
			}
			$snapshot = Get-CacheSnapshot; $lastAction = $null; $lastError = $null; $cmd = Get-PendingCommand
			if ($cmd) { $res = Execute-CacheCommand -Command $cmd -Root $snapshot.Root; $lastAction = $res.Action; if (-not $res.Ok -and $res.Error) { $lastError = $res.Error }; if ($res.Ok) { $snapshot = Get-CacheSnapshot } }
			Write-CacheState -Snapshot $snapshot -LastAction $lastAction -LastError $lastError
			# Auto-stop if no UI instance is registered anymore
			if (-not (Test-AnyCacheUi)) { $script:CacheAgentStopRequested = $true }
			if ($script:CacheAgentStopRequested) {
				$doClear = $false
				if (-not $script:CacheAgentExplicitStopRequested) { try { $doClear = Get-CacheWatcherClearOnExit } catch { $doClear = $true } }
				if ($doClear) {
					try {
						$snap = Get-CacheSnapshot
						if ($snap -and $snap.Root -and (Test-Path -LiteralPath $snap.Root)) {
							Get-ChildItem -LiteralPath $snap.Root -Recurse -File -ErrorAction SilentlyContinue | ForEach-Object {
								try { Remove-Item -LiteralPath $_.FullName -Force -ErrorAction SilentlyContinue } catch {}
							}
						}
					} catch {}
				}
				# On stop, remove state.json so UIs will no longer see an active watcher
				try { $statePath = Get-CacheAgentStatePath; if (Test-Path -LiteralPath $statePath) { Remove-Item -LiteralPath $statePath -Force -ErrorAction SilentlyContinue } } catch {}
				# Remove the pid file completely
				try { $pidPath = Get-CacheAgentPidPath; if (Test-Path -LiteralPath $pidPath) { Remove-Item -LiteralPath $pidPath -Force -ErrorAction SilentlyContinue } } catch {}
				break
			}
			Start-Sleep -Seconds $IntervalSeconds
		}
	} catch { try { $snap = Get-CacheSnapshot; Write-CacheState -Snapshot $snap -LastAction 'fatal' -LastError $_.Exception.Message } catch {} }
}

# ================================================================
#	Internationalization (i18n)
# ================================================================

# Embedded English fallback (extend over time). Keep it flat "dot" keys for simplicity.
# NOTE: UTF-8 here-string; safe in PS 5.1.
$script:I18N_Embedded_En = @'
{
	"about.aut": "Author: {author}",
	"about.des": "Tiny Nextcloud WebDAV tray app",
	"about.ver": "Version: {version}",
	"app_password": "App-Password",
	"box.autostart": "Start with Windows",
	"box.cache_clear_on_exit": "Clear cache on exit",
	"box.cache_live_update": "Live update",
	"box.shortcut_desktop": "Desktop shortcut",
	"box.shortcut_startmenu": "Start menu shortcut",
	"button.clear_cache": "Clear cache",
	"button.cache_watcher_start": "Start cache watcher",
	"button.cache_watcher_stop": "Stop cache watcher",
	"button.cancel": "Cancel",
	"button.clear": "Clear",
	"button.close": "Close",
	"button.copy_url": "Copy URL",
	"button.delete_secrets": "Delete secrets",
	"button.encrypt": "Encrypt",
	"button.export2portable": "Export to Portable...",
	"button.export_config": "Export config (JSON)...",
	"button.import_config": "Import config...",
	"button.install2appdata": "Install to AppData",
	"button.install_language": "Install Language...",
	"button.no": "No",
	"button.ok": "OK",
	"button.open": "Open",
	"button.refresh": "Refresh",
	"button.restart_service": "Restart service",
	"button.save": "Save",
	"button.select": "Select",
	"button.start_service": "Start service",
	"button.triggerinfo": "Trigger info",
	"button.uac_apply_changes": "Apply changes",
	"button.uninstall": "Uninstall...",
	"button.up": "Up",
	"button.yes": "Yes",
	"column.cache_name": "item UUID",
	"column.cache_size": "size",
	"column.cache_modified": "modified",
	"column.cache_type": "type",
	"combo.basic_auth_level_0": "0 - Disabled (no Basic at all)",
	"combo.basic_auth_level_1": "1 - Basic over HTTPS only (recommended)",
	"combo.basic_auth_level_2": "2 - Basic over HTTP or HTTPS (not recommended)",
	"combo.webclient_start_automatic": "Automatic",
	"combo.webclient_start_manual": "Manual",
	"combo.webclient_start_disabled": "Disabled",
	"hint.select_portable_folder": "Choose destination folder for portable package (select existing portable folder to update in place)",
	"i18n.ok": "i18n initialized.",
	"label.active_scope": "* The WebClient service has classified the current server as a '{zone}'",
	"label.active_scope_internet": "internet server",
	"label.active_scope_local": "local server",
	"label.basic_auth_level": "Basic authentication level",
	"label.cache_info": "Cached items - total used cache size: {size}",
	"label.cache_watcher_status": "Cache watcher: {status}",
	"label.checkinterval": "Check interval (sec)",
	"label.display_name": "Display name (Explorer)",
	"label.drive_letter": "Drive letter",
	"label.file_attributes_limit": "Max files per folder",
	"label.file_size_limit": "Max filesize",
	"label.folderpath": "Folder: /",
	"label.internet_server_timeout": "Internet server timeout",
	"label.language": "Language",
	"label.local_server_timeout": "Local server timeout",
	"label.passphrase_confirm": "Confirm passphrase:",
	"label.passphrase_enter": "Enter passphrase:",
	"label.send_receive_timeout": "Send receive timeout",
	"label.server": "Server",
	"label.server_not_found_cache_lifetime": "Server not found cache lifetime",	
	"label.service_starttype": "Starttype",
	"label.service_status": "WebClient service",
	"label.subfolder": "Subfolder",
	"label.user": "User",
	"menu.about": "About...",
	"menu.connect": "Connect now",
	"menu.disconnect": "Disconnect",
	"menu.exit": "Exit",
	"menu.settings": "Settings...",
	"message.already_installed_appdata": "Already installed (AppData).",
	"message.app_password_help": "1) Sign in to your Nextcloud in the browser.\r\n2) Open: {url}\r\n3) Scroll to the bottom of the page ('Devices & sessions').\r\n4) In the field 'App name', enter '{app}'.\r\n5) Click 'Create new app password' and copy the generated password into the app.",
	"message.config_already_running": "This config is already running:\n{path}",
	"message.config_imported": "Config imported.",
	"message.drive_already_in_use": "Drive {drive} is already in use.",
	"message.drive_already_in_use_by_other_instance": "Drive {drive} is already in use by another {app} instance.",
	"message.drive_letter_used": "That drive letter is already in use.",
	"message.enter_password_first": "Please enter app-password first.",
	"message.export_failed": "Export failed: {err}",
	"message.fill_server_user_drive": "Please fill Server, User and pick a valid drive letter (e.g. Z:).",
	"message.folder_does_not_exist": "Folder '/{folder}' does not exist.",
	"message.import_failed": "Import failed: {err}",
	"message.install_failed": "Install failed: {err}",
	"message.installed_config_exported": "Installed config exported.",
	"message.installed_to_appdata_success": "Installed to AppData successfully.",
	"message.internet_server_timeout_help": "Specifies the connection timeout in seconds for the WebClient service uses when communicating with non-local WebDAV servers.\r\n\r\nThe default is 30",
	"message.lang_imported": "Language pack installed: {path}",
	"message.local_server_timeout_help": "Specifies the connection timeout in seconds for the WebClient service uses when communicating with a local WebDAV server.\r\n\r\nThe default is 15",
	"message.passphrase_mismatch": "Passphrases did not match.",
	"message.passphrase_required": "Passphrase is required to encrypt the app-password.",
	"message.passphrase_wrong_or_corrupt": "Wrong passphrase (or secret is corrupt). Please try again or click Cancel to exit.",
	"message.portable_launchers_inplace": "Portable launchers written in-place:\r\n{path}",
	"message.portable_package_exported": "Portable package exported into:\r\n{path}",
	"message.portable_package_installed": "Portable package installed in:\r\n{path}",
	"message.portable_package_updated": "Portable package updated at:\r\n{path}",
	"message.send_receive_timeout_help": "Specifies the timeout in seconds that WebDAV the WebClient service uses after issuing a request, such as 'GET /file.ext' or 'PUT /file.ext'.\r\n\r\nThe default is 60",
	"message.server_not_found_cache_lifetime_help": "Specifies the period of time in seconds that a server is cached as non-WebDAV by the WebClient service.\r\nNote: The WebClient service maintains a list of non-WebDAV servers that have been contacted. If the server is found in this list, a fail is returned immediately without attempting to contact the server.\r\n\r\nThe default is 60",
	"message.service_trigger_info": "This trigger is configured to start the WebClient service:\r\nETW-provider-name:\r\n{name}\r\nETW-provider-UUID:\r\n{uuid}",
	"message.service_webclient_disabled_use_tuning": "This App relies on the 'WebClient' service but its 'Starttype' is switched to 'Disabled'. It can not be startet as long as it is disabled. The service must and can be activated by switching the 'Starttype' to 'Manual' or 'Automatic' in the 'WebClient tuning'-tab of the settings window.",
	"message.service_webclient_missing": "WebClient service missing.",
	"message.store_password_failed": "Failed to store password: {err}",
	"message.tuning_applied": "Successfully applied WebClient settings",
	"message.uac_admin_required": "Insufficient permissions. Please contact your administrator",
	"message.write_secret_failed": "Failed to write secret: {err}",
	"mode.installed": "INSTALLED MODE",
	"mode.portable": "PORTABLE MODE",
	"password.encrypted_dpapi": "DPAPI encrypted password",
	"password.encrypted_secret": "Encrypted portable secret",
	"prompt.basic_auth_disabled_enable_now": "Basic authentication is disabled for the WebClient service.\r\nThis App uses basic authentication to log into the server and will not work when basic authentication is disabled.\r\nDo you want to enable basic authentication now?",
	"prompt.basic_auth_0_warning": "This app uses basic authentication to log into the server and will no longer work once basic authentication is disabled.\r\nAre you sure you want to disable basic authentication?",
	"prompt.basic_auth_2_warning": "Using basic authentication on non-SSL connections can cause serious security issues as the username/password are transmitted in clear text.\r\nAre you sure you want to enable basic authentication for non-SSL connections?",
	"prompt.cache_delete_all_confirm": "Do you want to delete all cached items?",
	"prompt.cache_watcher_stop_warn": "Stopping the cache watcher now will disable the '{cache_clear_on_exit}' feature.\r\nAre you sure you want to stop the cache watcher?",
	"prompt.clear_stored_password": "Clear stored password?",
	"prompt.export2json": "Export settings into a JSON file?\r\n\r\nIf you select 'Yes', the settings, including the DPAPI-encrypted password, will be saved in a JSON file. This allows the settings to be restored in a later reinstallation of {app} but only on *this* Windows computer for *this* user.",
	"prompt.export2json_before_uninstall": "Export settings before uninstalling?\r\n\r\nIf you select 'Yes', the settings, including the DPAPI-encrypted password, will be saved in a JSON file. This allows the settings to be restored in a later reinstallation of {app} but only on *this* Windows computer for *this* user. Select 'No' if the settings also need to be transferred to other devices.",
	"prompt.export2portable": "Export to a portable package?\r\n\r\nIf you select 'Yes' here, a portable package will be exported. Your Nextcloud app password will be encrypted in the '{appshort}_secret.dat' file using the following method:\r\n- AES-256 in CBC mode, PKCS7 padding\r\n- Initialization vector (IV) = 16 random bytes\r\n- Key derived from your passphrase using PBKDF2\r\n  (Rfc2898DeriveBytes) with 100, 000 iterations\r\nYou will be prompted to enter a passphrase during the export process. Remember this passphrase carefully, as your Nextcloud app-password can only be decrypted with it. You can carry the exported folder on a USB stick and run {app} on other people's PCs without leaving secrets behind.",
	"prompt.export2portable_before_uninstall": "Export to a portable package before uninstall?\r\n\r\nIf you select 'Yes' here, a portable package will be exported. Your Nextcloud app password will be encrypted in the '{appshort}_secret.dat' file using the following method:\r\n- AES-256 in CBC mode, PKCS7 padding\r\n- Initialization vector (IV) = 16 random bytes\r\n- Key derived from your passphrase using PBKDF2\r\n  (Rfc2898DeriveBytes) with 100, 000 iterations\r\nYou will be prompted to enter a passphrase during the export process. Remember this passphrase carefully, as your Nextcloud app-password can only be decrypted with it. You can carry the exported folder on a USB stick and run {app} on other people's PCs without leaving secrets behind.",
	"prompt.folder_is_not_empty_overwrite": "Folder '{dir}' is not empty.\r\nOverwrite its contents?",
	"prompt.folder_missing_open_settings": "Configured folder '/{folder}' does not exist.\r\nOpen Settings to choose a new folder?",
	"prompt.folder_no_longer_exists_choose_new": "Configured folder '/{folder}' no longer exists.\r\nChoose a new folder now?",
	"prompt.import_portable_settings_to_installed": "Import current portable settings into the installed app?",
	"prompt.install_portable_to_dir": "Install portable package to:\r\n\r\n{dir}\r\n\r\nContinue?",
	"prompt.password_missing_quit" : "No stored password for {app}. Quit now?",
	"prompt.secret_file_missing_quit": "Secret file is missing. Quit {app} now?",
	"prompt.secrets_delete_confirm": "Delete secrets.dat?",
	"prompt.service_webclient_start_now": "This App relies on the WebClient service but it is switched off. Do you want to start the service now?",
	"prompt.start_disabled_warn": "This App relies on the WebClient service and will no longer work once the WebClient service is disabled..\r\nDo you really want to disable it?",
	"prompt.unsaved_changes": "There are unsaved changes. Should these be saved before exiting?",
	"status.not_found": "<not found>",
	"status.pending": "working...",
	"status.running": "running",
	"status.starting": "starting...",
	"status.stopped": "stopped",
	"status.stopping": "stopping...",
	"tab.basic_settings": "Basic settings",
	"tab.webclient_tuning": "WebClient tuning",
	"tab.webdav_cache": "WebDAV cache",
	"tip.basic_auth": "Using basic authentication on non-SSL connections can cause serious\r\nsecurity issues as the username/password are transmitted in clear text",
	"tip.enter_password_and_encrypt": "Enter app-password and click 'Encrypt' to enable folder browse",
	"tip.enter_server": "Server address without https://",
	"tip.enter_user": "User login name",
	"tip.internet_server_timeout_help": "Specifies the connection timeout in seconds for the WebClient\nservice uses when communicating with non-local WebDAV servers",
	"tip.local_server_timeout_help": "Specifies the connection timeout in seconds for the WebClient\nservice uses when communicating with a local WebDAV server",
	"tip.send_receive_timeout_help": "Specifies the timeout in seconds that WebDAV the\nWebClient service uses after issuing a request",
	"tip.server_not_found_cache_lifetime_help": "Specifies the period of time in seconds that a server\nis cached as non-WebDAV by the WebClient service",
	"tip.service_status": "Status of 'WebClient' service: {status}",
	"title.about": "About {app}",
	"title.app_password_help": "How to create an app password",
	"title.app_password_query": "{app}: app password query",
	"title.export_config": "Export installed config",
	"title.folderpicker": "{app}: Select Nextcloud folder",
	"title.import_config": "Import config",
	"title.install_language": "Install language pack",
	"title.passphrase_query": "{app}: passphrase query",
	"title.passphrase_set": "{app}: set passphrase",
	"title.settings_dialog": "ernolfs {app}: Settings",
	"tray.balloon": "Server: {server}\nDrive: {drive} [{sub}]\nStatus: {status}",
	"tray.error": "{app}: error",
	"tray.initializing": "{app}: initializing...",
	"tray.maintenance": "{app}: server in maintenance mode",
	"tray.mapping_failed": "{app}: mapping failed",
	"tray.needs_setup": "{app}: needs setup - open settings",
	"tray.offline": "{app}: offline",
	"tray.online": "{app}: {drive} online",
	"tray.password_missing" : "{app}: needs setup (password)",
	"tray.paused": "{app}: {drive} disconnected (paused)",
	"tray.secrets_missing": "{app}: portable secrets missing",
	"tray.service_deactivated": "{app}: needs setup (service deactivated)",
	"end.of.json": "dont touch this"
}
'@

# Internal i18n state
$script:I18N = @{
	Language = 'en' # resolved language (two-letter or custom)
	Fallback = @{} # hashtable of embedded EN
	Current = @{} # merged: Fallback + external overrides
	FilePath = $null # loaded file path (if any)
}
function Convert-JsonToHashtable([string]$Json) {
	try { $o = $Json | ConvertFrom-Json } catch { return @{} }
	# Convert PSCustomObject to Hashtable (flat keys only expected)
	$ht = @{}; if ($o) { foreach($p in $o.PSObject.Properties) { $ht[$p.Name] = [string]$p.Value } }
	return $ht
}
# Community packs: NDTi18n.<lang>.json (e.g., NDTi18n.de.json)
function Resolve-I18nFilePath([string]$Lang) { Join-Path $HereDir ("i18n\{0}i18n.{1}.json" -f $AppNameShort, $Lang) }
# Two-letter UI culture (e.g., 'de', 'en', 'fr')
function Get-SystemLang2{ try { return [System.Globalization.CultureInfo]::CurrentUICulture.TwoLetterISOLanguageName } catch { return 'en' } }
# Optional explicit lang (e.g., 'de'); if omitted, pick from State.Language or UI culture.
function Initialize-I18n([string]$Lang) {
	# 1) build fallback (embedded English minimal safety net)
	$script:I18N.Fallback = Convert-JsonToHashtable $script:I18N_Embedded_En
	# 2) decide requested language. Priority: a) explicit param b) $State.LangPref (user choice from Settings) c) Windows UI culture (auto)
	$chosen = $null
	if ($Lang -and $Lang.Trim()) { $chosen = $Lang.Trim() } elseif ($State -and ($State.PSObject.Properties.Name -contains 'LangPref') -and $State.LangPref) { $chosen = [string]$State.LangPref } else { $chosen = Get-SystemLang2 }
	$script:I18N.Language = $chosen
	# 3) try to load external override file (NDTi18n.<lang>.json)
	$fp = Resolve-I18nFilePath $chosen
	$override = @{}
	if (Test-Path -LiteralPath $fp) { try { $override = Convert-JsonToHashtable (Get-Content -LiteralPath $fp -Raw -Encoding UTF8); $script:I18N.FilePath = $fp } catch { $override = @{}; $script:I18N.FilePath = $null } } else { $script:I18N.FilePath = $null }
	# 4) merge fallback + override
	$merged = @{}
	foreach ($k in $script:I18N.Fallback.Keys) { $merged[$k] = $script:I18N.Fallback[$k] }
	foreach ($k in $override.Keys) { $merged[$k] = $override[$k] }
	$script:I18N.Current = $merged
	Write-Verbose ("Initialize-I18n: lang = {0} override = {1}" -f $script:I18N.Language, $(if ($script:I18N.FilePath) {$script:I18N.FilePath} else {'<none>'}))
}
<# Simple translation lookup by key with optional named placeholders.
 - Looks up from Current (override) first, then Fallback.
 - If missing, returns the key itself.
 - Named replacements: T 'greet' @{ name = 'Alice' } with JSON { "greet": "Hello {name}!" } #>
function global:T([string]$Key, [hashtable]$Vars) {
	$text = if ($script:I18N.Current.ContainsKey($Key)) { $script:I18N.Current[$Key] } elseif ($script:I18N.Fallback.ContainsKey($Key)) { $script:I18N.Fallback[$Key] } else { return $Key }
	if ($Vars) { foreach($k in $Vars.Keys) { $text = $text.Replace('{'+[string]$k+'}', [string]$Vars[$k]) } }
	return $text
}
# Helper to check if a key exists (useful during migration)
# function Has-TKey([string]$Key) { return ($script:I18N.Current.ContainsKey($Key) -or $script:I18N.Fallback.ContainsKey($Key)) }
# i18n: custom MessageBox helper (localized text)
function Show-CustomMsgBoxT([string]$Key, [hashtable]$Vars = $null, [string]$Mode = 'OK', [string]$Icon = 'None', [string]$Caption = $AppName, [switch]$Uac) {
	<#	[string]$Key -> i18n key for body text, [hashtable]$Vars -> placeholder vars for T(), [string]$Mode -> 'OK' | 'YesNo' | 'YesNoCancel', [string]$Icon -> 'Information' | 'Warning' | 'Error' | 'Question' | 'None' #>
	# play system sound (mirror MessageBox)
	switch ($Icon) { 'Information' { [System.Media.SystemSounds]::Asterisk.Play() }; 'Warning' { [System.Media.SystemSounds]::Exclamation.Play() }; 'Error' { [System.Media.SystemSounds]::Hand.Play() }; 'Question' { [System.Media.SystemSounds]::Question.Play() }; default {} }
	# Resolve translated body text
	$bodyText = T $Key $Vars
	# Define buttons (order in array is right-to-left visual order, see FlowDirection below)
	switch ($Mode) {
		'OK' { $btnDefs = @( @{ Text = T 'button.ok'; Result = [System.Windows.Forms.DialogResult]::OK; Default = $true; Cancel = $true } ) }
		# FlowDirection = RightToLeft, so first in list ends up rightmost. We add No first, then Yes -> visually "Yes No"
		'YesNo' { $btnDefs = @( @{ Text = T 'button.no'; Result = [System.Windows.Forms.DialogResult]::No; Default = $false; Cancel = $true }, @{ Text = T 'button.yes'; Result = [System.Windows.Forms.DialogResult]::Yes; Default = $true; Cancel = $false } ) }
		# Will render "Yes No Cancel"
		'YesNoCancel' { $btnDefs = @( @{ Text = T 'button.cancel'; Result = [System.Windows.Forms.DialogResult]::Cancel; Default = $false; Cancel = $true }, @{ Text = T 'button.no'; Result = [System.Windows.Forms.DialogResult]::No; Default = $false; Cancel = $false }, @{ Text = T 'button.yes'; Result = [System.Windows.Forms.DialogResult]::Yes; Default = $true; Cancel = $false } ) }
		default { $btnDefs = @( @{ Text = T 'button.ok'; Result = [System.Windows.Forms.DialogResult]::OK; Default = $true; Cancel = $true } ) }
	}
	# Pick icon
	$icoObj = $null
	switch ($Icon) { 'Information' { $icoObj = [System.Drawing.SystemIcons]::Information }; 'Warning' { $icoObj = [System.Drawing.SystemIcons]::Warning }; 'Error' { $icoObj = [System.Drawing.SystemIcons]::Error }; 'Question' { $icoObj = [System.Drawing.SystemIcons]::Question }; default { $icoObj = $null } }
	# ---- Form base ----
	$frm = New-Object System.Windows.Forms.Form
	Apply-BrandIconToForm $frm
	$frm.Text = $Caption; $frm.MinimizeBox = $false; $frm.MaximizeBox = $false; $frm.ShowInTaskbar = $false; $frm.TopMost = $true; $frm.AutoSize = $true
	$frm.FormBorderStyle = [System.Windows.Forms.FormBorderStyle]::FixedDialog; $frm.StartPosition = [System.Windows.Forms.FormStartPosition]::CenterScreen; $frm.AutoSizeMode = [System.Windows.Forms.AutoSizeMode]::GrowAndShrink
	# Main panel (2 rows: content + buttons)
	$mainPanel = New-Object System.Windows.Forms.TableLayoutPanel; $mainPanel.ColumnCount = 1; $mainPanel.RowCount = 2; $mainPanel.AutoSize = $true; $mainPanel.AutoSizeMode = [System.Windows.Forms.AutoSizeMode]::GrowAndShrink; $mainPanel.Dock = [System.Windows.Forms.DockStyle]::Fill; $mainPanel.Padding = New-Object System.Windows.Forms.Padding(12, 12, 12, 12); $mainPanel.GrowStyle = [System.Windows.Forms.TableLayoutPanelGrowStyle]::AddRows
	# Upper row: icon + text side by side
	$contentPanel = New-Object System.Windows.Forms.TableLayoutPanel; $contentPanel.ColumnCount = 2; $contentPanel.RowCount = 1; $contentPanel.AutoSize = $true; $contentPanel.AutoSizeMode = [System.Windows.Forms.AutoSizeMode]::GrowAndShrink; $contentPanel.Dock = [System.Windows.Forms.DockStyle]::Fill; $contentPanel.GrowStyle = [System.Windows.Forms.TableLayoutPanelGrowStyle]::AddColumns
	$pic = New-Object System.Windows.Forms.PictureBox; $pic.SizeMode = [System.Windows.Forms.PictureBoxSizeMode]::CenterImage; $pic.Margin = New-Object System.Windows.Forms.Padding(0, 0, 12, 0); $pic.MinimumSize = New-Object System.Drawing.Size(32, 32)
	if ($icoObj) { $pic.Image = $icoObj.ToBitmap() } else { $pic.Width = 1; $pic.Height = 1; $pic.Margin = New-Object System.Windows.Forms.Padding(0, 0, 0, 0) } # no icon -> collapse spacing
	$lbl = New-Object System.Windows.Forms.Label; $lbl.Text = $bodyText; $lbl.AutoSize = $true; $lbl.MaximumSize = New-Object System.Drawing.Size(360, 0) # wrap text at ~360px
	[void]$contentPanel.Controls.Add($pic, 0, 0); [void]$contentPanel.Controls.Add($lbl, 1, 0)
	# Lower row: buttons, right aligned
	$buttonPanel = New-Object System.Windows.Forms.FlowLayoutPanel; $buttonPanel.AutoSize = $true; $buttonPanel.AutoSizeMode = [System.Windows.Forms.AutoSizeMode]::GrowAndShrink; $buttonPanel.Dock = [System.Windows.Forms.DockStyle]::Fill; $buttonPanel.FlowDirection = [System.Windows.Forms.FlowDirection]::RightToLeft; $buttonPanel.Padding = New-Object System.Windows.Forms.Padding(0, 12, 0, 0)
	$defaultBtn = $null; $cancelBtn = $null
	$btnMinW = if ($script:ButtonMinW -is [int] -and $script:ButtonMinW -gt 0) { $script:ButtonMinW } else { 80 }
	foreach ($bdef in $btnDefs) {
		$btn = New-Object System.Windows.Forms.Button
		$btn.AutoSize = $true; $btn.AutoSizeMode = [System.Windows.Forms.AutoSizeMode]::GrowOnly
		$shieldThis = $Uac -and $bdef.Default -and ( ($bdef.Result -eq [System.Windows.Forms.DialogResult]::OK) -or ($bdef.Result -eq [System.Windows.Forms.DialogResult]::Yes) )
		$btn.Height = $script:ButtonXH
		$btn.MaximumSize = New-Object System.Drawing.Size(0, $btn.Height)
		$btn.Margin = New-Object System.Windows.Forms.Padding(6, 0, 0, 0)
		$btn.Text = $bdef.Text; $btn.DialogResult = $bdef.Result; $btn.MinimumSize = New-Object System.Drawing.Size($script:ButtonMinW, 0)
		if ($bdef.Default) { $defaultBtn = $btn }; if ($bdef.Cancel) { $cancelBtn = $btn }; if ($shieldThis) { Enable-FlatUacShield $btn }
		[void]$buttonPanel.Controls.Add($btn)
	}
	if ($defaultBtn) { $frm.AcceptButton = $defaultBtn }; if ($cancelBtn) { $frm.CancelButton = $cancelBtn }
	# Compose final layout
	[void]$mainPanel.Controls.Add($contentPanel, 0, 0); [void]$mainPanel.Controls.Add($buttonPanel, 0, 1); [void]$frm.Controls.Add($mainPanel)
	# Modal show and return DialogResult
	$dlgResult = $frm.ShowDialog()
	if (-not $dlgResult -or $dlgResult -eq [System.Windows.Forms.DialogResult]::None) { if ($cancelBtn) { $dlgResult = $cancelBtn.DialogResult } else { $dlgResult = [System.Windows.Forms.DialogResult]::None } }
	return $dlgResult
}
# Simple OK/Information message using a localized string
function global:Show-InfoT([string]$Key, [hashtable]$Vars = $null) { [void](Show-CustomMsgBoxT -Key $Key -Vars $Vars -Mode 'OK' -Icon 'Information' -Caption $AppName) }
# Simple OK/Warning message using a localized string
function global:Show-WarnT([string]$Key, [hashtable]$Vars = $null) { [void](Show-CustomMsgBoxT -Key $Key -Vars $Vars -Mode 'OK' -Icon 'Warning' -Caption $AppName) }
# Simple OK/Error message using a localized string
function global:Show-ErrorT([string]$Key, [hashtable]$Vars = $null) { [void](Show-CustomMsgBoxT -Key $Key -Vars $Vars -Mode 'OK' -Icon 'Error' -Caption $AppName) }
# Yes/No question (Information icon); returns DialogResult
function global:Ask-YesNoInfoT([string]$Key, [hashtable]$Vars = $null) { return Show-CustomMsgBoxT -Key $Key -Vars $Vars -Mode 'YesNo' -Icon 'Information' -Caption $AppName }
# Yes/No question (Warning icon); returns DialogResult
function global:Ask-YesNoWarnT([string]$Key, [hashtable]$Vars = $null, [switch]$Uac) { return Show-CustomMsgBoxT -Key $Key -Vars $Vars -Mode 'YesNo' -Icon 'Warning' -Caption $AppName -Uac:$Uac }
# Yes/No question (Question icon); returns DialogResult
function global:Ask-YesNoQuestT([string]$Key, [hashtable]$Vars = $null) { return Show-CustomMsgBoxT -Key $Key -Vars $Vars -Mode 'YesNo' -Icon 'Question' -Caption $AppName }
# Yes/No/Cancel question (Question icon); returns DialogResult
function global:Ask-YesNoCancelQuestT([string]$Key, [hashtable]$Vars = $null) { return Show-CustomMsgBoxT -Key $Key -Vars $Vars -Mode 'YesNoCancel' -Icon 'Question' -Caption $AppName }
# i18n: custom help dialog with optional clickable URL
function global:Show-HelpT([string]$TitleKey, [hashtable]$TitleVars = $null, [string]$BodyKey, [hashtable]$BodyVars = $null, [string]$Url = $null, [int]$Width = 640, [int]$Height = 320) {
	Add-Type -AssemblyName System.Windows.Forms
	Add-Type -AssemblyName System.Drawing
	# Resolve i18n
	$title = T $TitleKey $TitleVars; $body = T $BodyKey $BodyVars; $okTxt = T 'button.ok'
	# Form
	$f = New-Object System.Windows.Forms.Form; Apply-BrandIconToForm $f; Hook-FormDpi $f; $f.Text = $title; $f.StartPosition = $(if ($Parent) { 'CenterParent' } else { 'CenterScreen' }); $f.FormBorderStyle = 'FixedDialog'; $f.MinimizeBox = $false; $f.MaximizeBox = $false; $f.ShowInTaskbar = $false; $f.TopMost = $true; $f.AutoScaleMode = 'Dpi'; $f.Width = $Width; $f.Height = $Height; $wrapW = [Math]::Max(200, $f.ClientSize.Width - 32); $f.Font = New-Object System.Drawing.Font($UiFontFamily, 9)
	# DPI scale (96dpi = 1.0)
	$scale = ($f.DeviceDpi / 96.0); $icoPx = [int][Math]::Ceiling(32 * $scale) # target box size for the icon
	# Layout root
	$root = New-Object System.Windows.Forms.TableLayoutPanel; $root.Dock = 'Fill'; $root.Padding = New-Object System.Windows.Forms.Padding(12, 12, 12, 12); $root.ColumnCount = 1; $root.RowCount = $(if ($Url) { 4 } else { 3 })
	$root.RowStyles.Add((New-Object System.Windows.Forms.RowStyle([System.Windows.Forms.SizeType]::AutoSize))) | Out-Null
	$root.RowStyles.Add((New-Object System.Windows.Forms.RowStyle([System.Windows.Forms.SizeType]::AutoSize))) | Out-Null
	if ($Url) { $root.RowStyles.Add((New-Object System.Windows.Forms.RowStyle([System.Windows.Forms.SizeType]::AutoSize))) | Out-Null }
	$btnRowHeight = $script:ButtonXH + (2 * $script:ButtonPadY)
	$root.RowStyles.Add((New-Object System.Windows.Forms.RowStyle([System.Windows.Forms.SizeType]::Absolute, $btnRowHeight))) | Out-Null
	# Header (Help icon + title label)
	$hdr = New-Object System.Windows.Forms.FlowLayoutPanel
	$hdr.AutoSize = $true
	$hdr.FlowDirection = 'LeftToRight'
	$hdr.WrapContents = $false
	$pic = New-Object System.Windows.Forms.PictureBox
	$pic.SizeMode = 'Zoom' # 'CenterImage' # 'Zoom' to avoid cropping
	$pic.Width = $icoPx; $pic.Height = $icoPx
	$pic.Margin = New-Object System.Windows.Forms.Padding(0, 2, 8, 0) # a bit of breathing room
	$pic.Image = [System.Drawing.SystemIcons]::Information.ToBitmap()
	$lblTitle = New-Object System.Windows.Forms.Label; $lblTitle.AutoSize = $true; $lblTitle.Font = New-Object System.Drawing.Font($f.Font.FontFamily, ($f.Font.Size + 2), $UiFontStyleBold); $lblTitle.Text = $title; $lblTitle.Margin = New-Object System.Windows.Forms.Padding(8, 6, 0, 0)
	$hdr.Controls.AddRange(@($pic, $lblTitle))
	# Body
	$lblBody = New-Object System.Windows.Forms.Label; $lblBody.AutoSize = $true; $lblBody.MaximumSize = New-Object System.Drawing.Size($wrapW, 0); $lblBody.Text = $body; $lblBody.Margin = New-Object System.Windows.Forms.Padding(0, 8, 0, 0); $lblBody.UseMnemonic = $false
	# Optional URL + Copy
	$urlPanel = $null
	if ($Url) {
		$urlPanel = New-Object System.Windows.Forms.FlowLayoutPanel; $urlPanel.AutoSize = $true; $urlPanel.FlowDirection = 'LeftToRight'; $urlPanel.WrapContents = $false; $urlPanel.Margin = New-Object System.Windows.Forms.Padding(0, 8, 0, 0)
		$lnk = New-Object System.Windows.Forms.LinkLabel; $lnk.Text = $Url; $lnk.AutoSize = $true
		$lnk.add_LinkClicked({ param($s, $e); try { $psi = New-Object System.Diagnostics.ProcessStartInfo; $psi.FileName = $Url; $psi.UseShellExecute = $true; [System.Diagnostics.Process]::Start($psi) | Out-Null } catch {} })
		$btnCopy = New-Object System.Windows.Forms.Button; $btnCopy.Text = T 'button.copy_url'
		$btnCopy.AutoSize = $true; $btnCopy.AutoSizeMode = [System.Windows.Forms.AutoSizeMode]::GrowOnly; $btnCopy.Height = $script:ButtonH; $btnCopy.Margin = New-Object System.Windows.Forms.Padding(8, $script:ButtonCopyOffsetY, 0, 0)
		$btnCopy.Add_Click({ try { [System.Windows.Forms.Clipboard]::SetText($Url) } catch {} })
		$urlPanel.Controls.AddRange(@($lnk, $btnCopy))
	}
	# Buttons (OK right aligned)
	$btnRow = New-Object System.Windows.Forms.FlowLayoutPanel; $btnRow.Dock = 'Bottom' <# 'Fill' #>; $btnRow.FlowDirection = 'RightToLeft'; $btnRow.AutoSize = $false; $btnRow.Height = $script:ButtonXH + (2 * $script:ButtonPadY); $btnRow.Padding = New-Object System.Windows.Forms.Padding(0, $script:ButtonPadY, 0, 0)
	$ok = New-Object System.Windows.Forms.Button; $ok.Text = $okTxt; $ok.Width = $script:ButtonMinW; $ok.Height = $script:ButtonXH; $ok.Add_Click({ $f.Close() })
	$btnRow.Controls.Add($ok)
	$f.AcceptButton = $ok
	$f.CancelButton = $ok
	# ESC to close
	$f.KeyPreview = $true
	$f.Add_KeyDown({ param($s, $e) if ($e.KeyCode -eq 'Escape') { try { $s.Close() } catch {} } })
	# Compose
	$root.Controls.Add($hdr)
	$root.Controls.Add($lblBody)
	if ($urlPanel) { $root.Controls.Add($urlPanel) }
	$root.Controls.Add($btnRow)
	$f.Controls.Add($root)
	if ($Parent) { return $f.ShowDialog($Parent) } else { return $f.ShowDialog() }
}

# ================================================================
#	Config I/O (portable vs installed)
# ================================================================
# ---------- Config I/O ----------
function Save-Config {
	# portable mode -> write neutral json without DPAPI
	if ($PortableMode) { New-StateConfigObject | ConvertTo-Json | Set-Content -Path $PortJson -Encoding UTF8 }
	# installed mode -> write registry (includes EncPass)
	else { Write-StateToRegistry }
}
function Load-Config {
	if ($PortableMode) { if (Test-Path $PortJson) { try { $p = Get-Content -Raw -Path $PortJson | ConvertFrom-Json; Copy-ObjectToState -Source $p } catch {} } else { Save-Config } }
	elseif (Test-Path $RegBase) { $p = Get-ItemProperty -Path $RegBase; Copy-ObjectToState -Source $p -IncludeSecret }
	else { Save-Config }
}

# ================================================================
#	Crypto & password handling (portable DPAPI/secret)
# ================================================================
# ---------- Crypto (portable) ----------
function New-RandomBytes([int]$n) { $bytes = New-Object byte[] $n; [System.Security.Cryptography.RandomNumberGenerator]::Create().GetBytes($bytes); return $bytes }
function Protect-PortableSecret([string]$plain, [string]$passphrase, [string]$outPath) {
	if ([string]::IsNullOrEmpty($plain) -or [string]::IsNullOrEmpty($passphrase)) { throw "Missing password or passphrase." }
	$salt = New-RandomBytes 16; $iv = New-RandomBytes 16
	$kdf = New-Object System.Security.Cryptography.Rfc2898DeriveBytes($passphrase, $salt, 100000)
	$key = $kdf.GetBytes(32)
	$aes = [System.Security.Cryptography.Aes]::Create(); $aes.Mode = 'CBC'; $aes.Padding = 'PKCS7'; $aes.KeySize = 256; $aes.Key = $key; $aes.IV = $iv
	$enc = $aes.CreateEncryptor()
	$plainBytes = [System.Text.Encoding]::UTF8.GetBytes($plain)
	$cipher = $enc.TransformFinalBlock($plainBytes, 0, $plainBytes.Length)
	$enc.Dispose(); $aes.Dispose(); $kdf.Dispose()
	$head = [System.Text.Encoding]::ASCII.GetBytes("NCPT1")
	$len = [BitConverter]::GetBytes([int]$cipher.Length)
	$blob = New-Object byte[] ($head.Length + 16 + 16 + 4 + $cipher.Length)
	[Array]::Copy($head, 0, $blob, 0, $head.Length)
	[Array]::Copy($salt, 0, $blob, $head.Length, 16)
	[Array]::Copy($iv, 0, $blob, $head.Length+16, 16)
	[Array]::Copy($len, 0, $blob, $head.Length+32, 4)
	[Array]::Copy($cipher, 0, $blob, $head.Length+36, $cipher.Length)
	[System.IO.File]::WriteAllBytes($outPath, $blob)
}
function Unprotect-PortableSecret([string]$passphrase, [string]$inPath) {
	$blob = [System.IO.File]::ReadAllBytes($inPath)
	if ($blob.Length -lt 41) { throw "Secret file is corrupt." }
	$tag = [System.Text.Encoding]::ASCII.GetString($blob, 0, 5)
	if ($tag -ne 'NCPT1') { throw "Secret file format not recognized." }
	$salt = New-Object byte[] 16; [Array]::Copy($blob, 5, $salt, 0, 16)
	$iv = New-Object byte[] 16; [Array]::Copy($blob, 21, $iv, 0, 16)
	$lenB = New-Object byte[] 4; [Array]::Copy($blob, 37, $lenB, 0, 4)
	$clen = [BitConverter]::ToInt32($lenB, 0)
	$cipher = New-Object byte[] $clen; [Array]::Copy($blob, 41, $cipher, 0, $clen)
	$kdf = New-Object System.Security.Cryptography.Rfc2898DeriveBytes($passphrase, $salt, 100000)
	$key = $kdf.GetBytes(32)
	$aes = [System.Security.Cryptography.Aes]::Create(); $aes.Mode = 'CBC'; $aes.Padding = 'PKCS7'; $aes.KeySize = 256; $aes.Key = $key; $aes.IV = $iv
	$dec = $aes.CreateDecryptor()
	$plainBytes = $dec.TransformFinalBlock($cipher, 0, $cipher.Length)
	$dec.Dispose(); $aes.Dispose(); $kdf.Dispose()
	return [System.Text.Encoding]::UTF8.GetString($plainBytes)
}
# ---------- Password (installed vs portable) ----------
function Get-PlainPassword {
	if ($PortableMode) { if ($script:PlainPassCache) { return $script:PlainPassCache }; return '' }
	if ([string]::IsNullOrEmpty($State.EncPass)) { return '' }
	try { $sec = ConvertTo-SecureString $State.EncPass; return (New-Object System.Net.NetworkCredential('', $sec)).Password } catch { return '' }
}
function Set-PlainPassword([string]$plain) {
	if ($PortableMode) { $script:PlainPassCache = if ([string]::IsNullOrWhiteSpace($plain)) { $null } else { $plain }; Save-Config }
	else { if ([string]::IsNullOrWhiteSpace($plain)) { $State.EncPass = ''; Save-Config; return }; $sec = ConvertTo-SecureString $plain -AsPlainText -Force; $State.EncPass = ($sec | ConvertFrom-SecureString); Save-Config }
}
function Clear-PlainPassword { $State.EncPass = ''; try { Save-Config } catch {}; $script:PlainPassCache = $null; $script:AskedPassphrase = $false }

# ================================================================
#	Helpers to ensure Single Instance (Mutex)
# ================================================================
# Compute SHA1 hex for stable mutex names
function Get-Sha1Hex([Parameter(Mandatory = $true)][string]$Text) { $sha1 = [System.Security.Cryptography.SHA1]::Create(); $bytes = [Text.Encoding]::UTF8.GetBytes($Text); $hash = $sha1.ComputeHash($bytes); return (($hash | ForEach-Object { $_.ToString('x2') }) -join '') }
# Acquire a named mutex (returns $true if we own it; outputs mutex via [ref])
function Acquire-NamedMutex([Parameter(Mandatory = $true)][string]$Name, [ref]$MutexOut) {
	try {
		$createdNew = $false
		$mutex = New-Object System.Threading.Mutex($true, $Name, [ref]$createdNew)
		# Already held by another process
		if (-not $createdNew) { try { $mutex.Dispose() } catch {}; return $false }
		$MutexOut.Value = $mutex
		return $true
	} catch { return $false }
}
# Release + dispose helper (no-throw)
function Release-MutexSafe($m) { try { if ($m) { $m.ReleaseMutex() | Out-Null } } catch {}; try { if ($m) { $m.Dispose() } } catch {} }
# Compute absolute, normalized path for config.json
function Get-ConfigFilePath {
	# Adjust if you already have a canonical variable for this
	if ($PortableMode) { return (Join-Path $HereDir 'config.json') }
	return (Join-Path $InstallDir 'config.json')
}
# Ensure single-instance per config.json (stores mutex in $script:cfgMutex)
function Ensure-SingleInstanceForConfig {
	# Use Global\ so different sessions/desktops collide properly
	# Use GetFullPath (file may not exist yet)
	$cfgPath = [System.IO.Path]::GetFullPath((Get-ConfigFilePath)).ToLowerInvariant()
	$key = 'Global\{0}_cfg_{1}' -f $AppName, (Get-Sha1Hex $cfgPath)
	$mutexVar = $null
	if (-not (Acquire-NamedMutex -Name $key -MutexOut ([ref]$mutexVar))) { Show-WarnT 'message.config_already_running' @{ path = $cfgPath }; exit 2 }
	$script:cfgMutex = $mutexVar
}
## Guard a drive letter (stores mutex in $script:driveMutex)
function Ensure-DriveGuard([Parameter(Mandatory = $true)][string]$Drive) {
	# Normalize drive like 'Z:'
	$d = ($Drive.Trim().ToUpperInvariant())
	if (-not ($d -match '^[A-Z]:$')) { return }	# ignore invalid
	# Global\ so instances across sessions/desktops collide
	$key = 'Global\{0}_drv_{1}' -f $AppName, $d[0]
	# Use a normal var + [ref], not New-Object PSReference
	$mutexVar = $null
	if (-not (Acquire-NamedMutex -Name $key -MutexOut ([ref]$mutexVar))) { Show-WarnT 'message.drive_already_in_use_by_other_instance' @{ drive = $d; app = $AppName }; exit 3 }
	$script:driveMutex = $mutexVar
}

# ================================================================
#	Nextcloud OCS-Helper (HTTP + JSON) and status tests
# ================================================================
# Encode path for OCS API ('' -> '', 'A/B' -> 'A%2FB')
function Encode-OcsPath([string]$path) { $norm = Normalize-SubPath $path; if ([string]::IsNullOrWhiteSpace($norm)) { return '' }; return [Uri]::EscapeDataString($norm) }
# Basic auth header for HttpWebRequest
function New-BasicAuthHeader([string]$user, [string]$pass) { 'Basic ' + [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes("$user`:$pass")) }
# RAW OCS folder-tree call that returns status code + raw + parsed JSON.
function Invoke-NcOcsFolderTreeRaw {
	[CmdletBinding()] param( [Parameter(Mandatory)][string]$Server, [Parameter(Mandatory)][string]$User, [Parameter(Mandatory)][string]$Pass, [string]$EncodedPath, [int]$Depth = 0 )
	try { [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12 } catch {}
	$uri = "https://$Server/ocs/v2.php/apps/files/api/v1/folder-tree?depth=$Depth"
	if ($null -ne $EncodedPath) { $uri += "&path=$EncodedPath" } else { $uri += "&path=%2F" }
	try {
		$req = [System.Net.HttpWebRequest]::Create($uri)
		$req.Method = 'GET'
		$req.UserAgent = "ernolfs $AppName v$Version"
		$req.Timeout = 4000
		$req.ReadWriteTimeout = 4000
		$req.AllowAutoRedirect = $true
		$req.Accept = 'application/json'
		$req.Headers['OCS-APIRequest'] = 'true'
		$req.Headers['Authorization'] = New-BasicAuthHeader $User $Pass
		$resp = $req.GetResponse()
		try {
			$code = [int]([System.Net.HttpWebResponse]$resp).StatusCode
			$sr = New-Object System.IO.StreamReader($resp.GetResponseStream())
			$raw = $sr.ReadToEnd()
			$sr.Close()
			$obj = $null
			try { $obj = $raw | ConvertFrom-Json } catch {}
			return [pscustomobject]@{ StatusCode = $code; BodyRaw = $raw; Json = $obj }
		} finally { try { $resp.Close() } catch {} }
	}
	catch [System.Net.WebException] {
		$code = $null; $raw = $null; $obj = $null
		try {
			$http = [System.Net.HttpWebResponse]$_.Exception.Response
			if ($http) {
				$code = [int]$http.StatusCode
				$sr = New-Object System.IO.StreamReader($http.GetResponseStream())
				$raw = $sr.ReadToEnd()
				$sr.Close()
				if (-not [string]::IsNullOrWhiteSpace($raw)) { try { $obj = $raw | ConvertFrom-Json } catch {} }
			}
		} catch {}
		return [pscustomobject]@{ StatusCode = $code; BodyRaw = $raw; Json = $obj }
	}
	catch { return [pscustomobject]@{ StatusCode = $null; BodyRaw = $null; Json = $null } }
}
# OCS folder-tree call (NO &format = json; path is encoded or empty)
# Backward-compatible wrapper: returns parsed JSON only (or $null on error).
function Invoke-NcOcsFolderTree {
	[CmdletBinding()] param( [Parameter(Mandatory)][string]$Server, [Parameter(Mandatory)][string]$User, [Parameter(Mandatory)][string]$Pass, [string]$EncodedPath, [int]$Depth = 1 )
	$res = Invoke-NcOcsFolderTreeRaw -Server $Server -User $User -Pass $Pass -EncodedPath $EncodedPath -Depth $Depth
	if ($res) { return $res.Json }
	return $null
}
# depth = 0 strict existence check via RAW call:
# - $true = > exists OR unknown (offline/auth/maintenance/other errors)
# - $false = > ONLY when HTTP 404 AND exact JSON { "message": "Folder not found" }
function Test-NcFolderExists([string]$subPath) {
	if ([string]::IsNullOrWhiteSpace($State.Server) -or [string]::IsNullOrWhiteSpace($State.User)) { return $true }
	$pwd = Get-PlainPassword
	if ([string]::IsNullOrWhiteSpace($pwd)) { return $true }
	$enc = Encode-OcsPath $subPath
	$res = Invoke-NcOcsFolderTreeRaw -Server $State.Server -User $State.User -Pass $pwd -EncodedPath $enc -Depth 0
	if ($res -and $res.StatusCode -eq 200) { return $true }
	if ($res -and $res.StatusCode -eq 404) {
		if ($res.Json -and ($res.Json.PSObject.Properties.Name -contains 'message')) { if ([string]$res.Json.message -eq 'Folder not found') { return $false } }
		return $true # 404 but no exact "Folder not found" -> treat as unknown (NOT false)
	}
	return $true # Any other status or error -> unknown (NOT false)
}
# Unified server status via /status.php (no auth)
function Get-NcServerStatus {
	$fail = [pscustomobject]@{ Reachable = $false; Maintenance = $false; Installed = $false; Json = $null }
	if ([string]::IsNullOrWhiteSpace($State.Server)) { return $fail }
	try { [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12 } catch {}
	$uri = "https://$($State.Server)/status.php"
	try {
		$req = [System.Net.HttpWebRequest]::Create($uri)
		$req.Method = 'GET'
		$req.UserAgent = "ernolfs $AppName v$Version"
		$req.Timeout = 4000
		$req.ReadWriteTimeout = 4000
		$req.AllowAutoRedirect = $true
		$req.Accept = 'application/json'
		$resp = $req.GetResponse()
		try {
			$sr = New-Object System.IO.StreamReader($resp.GetResponseStream())
			$raw = $sr.ReadToEnd()
			$sr.Close()
			$j = $null
			try { $j = $raw | ConvertFrom-Json } catch {}
			$installed = $false; $maint = $false
			if ($j) {
				if ($j.PSObject.Properties.Name -contains 'installed') { $installed = [bool]$j.installed }
				if ($j.PSObject.Properties.Name -contains 'maintenance') { $maint = [bool]$j.maintenance }
			}
			return [pscustomobject]@{ Reachable = $true; Maintenance = $maint; Installed = $installed; Json = $j }
		} finally { try { $resp.Close() } catch {} }
	} catch { return $fail }
}
function Test-NcOnline { $st = Get-NcServerStatus; return ($st.Reachable -and (-not $st.Maintenance)) }
# Auth check via folder-tree depth = 0 on root "/": must be HTTP 200 and body == []
function Test-NcOnlineAuthenticated {
	if ([string]::IsNullOrWhiteSpace($State.Server) -or [string]::IsNullOrWhiteSpace($State.User)) { return $false }
	$pwd = Get-PlainPassword
	if ([string]::IsNullOrWhiteSpace($pwd)) { return $false }
	$res = Invoke-NcOcsFolderTreeRaw -Server $State.Server -User $State.User -Pass $pwd -EncodedPath '%2F' -Depth 0
	if ($res -and $res.StatusCode -eq 200) { if ($res.Json -is [System.Array] -and $res.Json.Count -eq 0) { return $true } }
	return $false
}
function Ensure-ConfiguredFolderOrExit {
	# If SubPath is set but does not exist, offer Settings; exit on decline or if still invalid after Settings.
	$sp = Normalize-SubPath $State.SubPath
	if ([string]::IsNullOrWhiteSpace($sp)) { return $true } # nothing to validate
	# Only validate when server is reachable (not in maintenance) AND auth works
	if (-not (Test-NcOnline)) { return $true }
	if (-not (Test-NcOnlineAuthenticated)) { return $true }
	if (Test-NcFolderExists $sp) { return $true }
	$ans = Ask-YesNoWarnT 'prompt.folder_missing_open_settings' @{ folder = $sp }
	if ($ans -ne [System.Windows.Forms.DialogResult]::Yes) {
		# Exit immediately (no mapping fallback)
		try { if ($script:timer) { $script:timer.Stop() } } catch {}
		try { Unmap-Drive } catch {}
		try { if ($script:mainMutex) { $script:mainMutex.ReleaseMutex() | Out-Null; $script:mainMutex.Dispose() } } catch {}
		try { if ($script:tray) { $script:tray.Visible = $false; $script:tray.Dispose() } } catch {}
		[System.Windows.Forms.Application]::Exit()
		return $false
	}
	# Open Settings; after closing, validate again
	[void](Show-SettingsDialog)
	$sp2 = Normalize-SubPath $State.SubPath
	if (-not [string]::IsNullOrWhiteSpace($sp2) -and (Test-NcFolderExists $sp2)) { return $true }
	# Still invalid or cancelled -> exit
	try { if ($script:timer) { $script:timer.Stop() } } catch {}
	try { Unmap-Drive } catch {}
	try { if ($script:mainMutex) { $script:mainMutex.ReleaseMutex() | Out-Null; $script:mainMutex.Dispose() } } catch {}
	try { if ($script:tray) { $script:tray.Visible = $false; $script:tray.Dispose() } } catch {}
	[System.Windows.Forms.Application]::Exit()
	return $false
}

# ================================================================
#	Simple lazy folder picker for Nextcloud (depth = 1 per level)
# ================================================================
# depth = 1 listing of children folder names at given parent path
function Get-NcFolderChildren([string]$parentPath) {
	if ([string]::IsNullOrWhiteSpace($State.Server) -or [string]::IsNullOrWhiteSpace($State.User)) { return @() }
	$pwd = Get-PlainPassword
	if ([string]::IsNullOrWhiteSpace($pwd)) { return @() }
	$enc = Encode-OcsPath $parentPath
	$res = Invoke-NcOcsFolderTree -Server $State.Server -User $State.User -Pass $pwd -EncodedPath $enc -Depth 1
	if ($null -eq $res) { return @() }
	# Expect array of objects with 'basename'
	if ($res -is [System.Array]) { return ($res | Where-Object { $_.PSObject.Properties.Name -contains 'basename' } | ForEach-Object { [string]$_.basename }) | Sort-Object }
	if ($res.PSObject.Properties.Name -contains 'ocs' -and ($res.ocs.data -is [System.Array])) { return ($res.ocs.data | Where-Object { $_.PSObject.Properties.Name -contains 'basename' } | ForEach-Object { [string]$_.basename }) | Sort-Object }
	return @()
}
# Join two subpath fragments using forward slashes and normalize the result
function Join-SubPath([string]$base, [string]$child) { $base = Normalize-SubPath $base; $child = Normalize-SubPath $child; if ([string]::IsNullOrWhiteSpace($base)) { return $child }; if ([string]::IsNullOrWhiteSpace($child)) { return $base }; return ($base + '/' + $child) }
# Modal Nextcloud folder picker. Returns: normalized subpath like "A/B/C", or '' for root, or $null on Cancel.
function Show-NcFolderPicker {
	# Pre-flight: need server/user/password to query OCS
	if ([string]::IsNullOrWhiteSpace($State.Server) -or [string]::IsNullOrWhiteSpace($State.User)) { return $null }
	$pwd = Get-PlainPassword
	if ([string]::IsNullOrWhiteSpace($pwd)) { return $null }
	# Shared state (ref) so event handlers mutate the SAME value
	$curPathRef = [ref](Normalize-SubPath $State.SubPath)
	$getCP = { $curPathRef.Value }; $setCP = { param($p) $curPathRef.Value = (Normalize-SubPath $p) }
	# --- UI ---
	$f = New-Object System.Windows.Forms.Form; Apply-BrandIconToForm $f; Hook-FormDpi $f
	$f.Text = (T 'title.folderpicker' @{ app = $AppName }); $f.StartPosition = 'CenterScreen'; $f.FormBorderStyle = 'FixedDialog'; $f.MaximizeBox = $false; $f.MinimizeBox = $false; $f.TopMost = $true; $f.Width = 520; $f.Height = 430; $f.KeyPreview = $true
	$lblCur = New-Object System.Windows.Forms.Label; $lblCur.Left = 12; $lblCur.Top = 12; $lblCur.AutoSize = $true
	$lb = New-Object System.Windows.Forms.ListBox; $lb.Left = 12; $lb.Top = 36; $lb.Width = $f.ClientSize.Width - 24; $lb.Height = 300; $lb.Anchor = 'Top, Left, Right'
	$btnUp = New-Object System.Windows.Forms.Button; $btnUp.Text = (T 'button.up'); $btnUp.Left = 12; $btnUp.Top = 346; $btnUp.Width = 70; $btnUp.Height = $script:ButtonH
	$btnOpen = New-Object System.Windows.Forms.Button; $btnOpen.Text = (T 'button.open'); $btnOpen.Left = $btnUp.Left + $btnUp.Width + 8; $btnOpen.Top = 346; $btnOpen.Width = 80; $btnOpen.Height = $script:ButtonH
	$btnSelect = New-Object System.Windows.Forms.Button; $btnSelect.Text = (T 'button.select'); $btnSelect.Width = 100; $btnSelect.Left = $f.ClientSize.Width - 220; $btnSelect.Top = 346; $btnSelect.Height = $script:ButtonH; $btnSelect.Anchor = 'Bottom, Right'
	$btnCancel = New-Object System.Windows.Forms.Button; $btnCancel.Text = (T 'button.cancel'); $btnCancel.Width = 100; $btnCancel.Left = $f.ClientSize.Width - 110; $btnCancel.Top = 346; $btnCancel.Height = $script:ButtonH; $btnCancel.Anchor = 'Bottom, Right'
	# Refresh list and header for the current path
	$refresh = {
		$p = & $getCP
		$lblCur.Text = if ([string]::IsNullOrWhiteSpace($p)) { (T 'label.folderpath') } else { (T 'label.folderpath') + $p }
		$lb.Items.Clear(); $children = Get-NcFolderChildren $p
		if ($children -and $children.Count -gt 0) { foreach ($n in $children) { [void]$lb.Items.Add([string]$n) } }
		$btnUp.Enabled = (-not [string]::IsNullOrWhiteSpace($p))
	}
	# Navigate into selected child
	$openSelected = { $sel = [string]$lb.SelectedItem; if ([string]::IsNullOrWhiteSpace($sel)) { return }; $newPath = Join-SubPath (& $getCP) $sel; & $setCP $newPath; & $refresh }
	# Up one level
	$btnUp.Add_Click({ $p = & $getCP; if ([string]::IsNullOrWhiteSpace($p)) { return }; $parts = ($p -split '/') | Where-Object { $_ -ne '' }; $newP = if ($parts.Count -le 1) { '' } else { ($parts[0..($parts.Count-2)] -join '/') }; & $setCP $newP; & $refresh })
	# Open/double-click
	$btnOpen.Add_Click({ & $openSelected }); $lb.Add_DoubleClick({ & $openSelected })
	# Select: return either current folder or current/selected-child
	$btnSelect.Add_Click({ $sel = [string]$lb.SelectedItem; $chosen = if ([string]::IsNullOrWhiteSpace($sel)) { (& $getCP) } else { Join-SubPath (& $getCP) $sel }; $f.Tag = $chosen; $f.DialogResult = [System.Windows.Forms.DialogResult]::OK; $f.Close() })
	# Cancel
	$btnCancel.Add_Click({ $f.Tag = $null; $f.DialogResult = 'Cancel'; $f.Close() })
	# Enter/Esc behavior
	$f.AcceptButton = $btnSelect; $f.CancelButton = $btnCancel
	$f.Add_KeyDown({ param($s, $e); if ($e.KeyCode -eq 'Enter') { $btnSelect.PerformClick() } elseif ($e.KeyCode -eq 'Escape') { $btnCancel.PerformClick() } })
	$f.Controls.AddRange(@($lblCur, $lb, $btnUp, $btnOpen, $btnSelect, $btnCancel))
	& $refresh
	$res = $f.ShowDialog()
	if ($res -eq [System.Windows.Forms.DialogResult]::OK) { return [string]$f.Tag }
	return $null
}

# ================================================================
#	WebDAV core (WebClient, host online, map secure)
# ================================================================
function New-WebDavMapSecure([string]$drive, [string]$unc, [string]$user, [string]$pass, [switch]$Persist, [ref]$LastError) {
	# Build NETRESOURCE
	$nr = New-Object Nc.NetUse+NETRESOURCE
	$nr.dwType = [Nc.NetUse]::RESOURCETYPE_DISK
	$nr.lpLocalName = $drive
	$nr.lpRemoteName = $unc
	$nr.lpComment = $null
	$nr.lpProvider = $null
	$flags = if ($Persist) { [Nc.NetUse]::CONNECT_UPDATE_PROFILE } else { 0 }
	$rc = [Nc.NetUse]::WNetAddConnection2([ref]$nr, $pass, $user, $flags)
	if ($PSBoundParameters.ContainsKey('LastError')) { $LastError.Value = $rc }
	return ($rc -eq 0)
}

# ================================================================
#	Registry path & key name builders (UNC, MountPoints2)
# ================================================================
function Normalize-SubPath([string]$sp) {
	if ([string]::IsNullOrWhiteSpace($sp) -or $sp -eq '/') { return '' }
	$sp = $sp.Trim().Trim('/', '\')
	if ($sp.Length -eq 0) { return '' }
	# Combine multiple / or \ -> save with '/'
	$parts = ($sp -split '[\\/]+') | Where-Object { $_ -ne '' }
	return ($parts -join '/')
}
function Build-Unc([string]$server, [string]$user, [string]$sub) { $norm = Normalize-SubPath $sub; $suffix = if ($norm) { '\' + ($norm -replace '/', '\') } else { '' }; return "\\$server@ssl\remote.php\dav\files\$user$suffix" }
function Set-MP2LabelExactExact {
	[CmdletBinding()] param( [Parameter(Mandatory)][string]$Server, [Parameter(Mandatory)][string]$User, [string]$SubPath, [string]$Label )
	# Build exact WebDAV MP2 key (no DavWWWRoot; literal '#' between path parts)
	$norm = Normalize-SubPath $SubPath; $frag = if ($norm) { '#' + ($norm -replace '/', '#') } else { '' }; $keyName = "##$Server@ssl#remote.php#dav#files#$User$frag"
	try {
		# Open MP2 base with write access
		$cu = [Microsoft.Win32.Registry]::CurrentUser; $mp2 = $cu.CreateSubKey(($RegMP2 -replace '^HKCU:\\'), $true)
		if ($null -eq $mp2) { return }
		# Ensure exact key exists (create if missing), then set/remove label
		try {
			$key = $mp2.OpenSubKey($keyName, $true)
			if (-not $key) { $key = $mp2.CreateSubKey($keyName, $true) }
			if ($key) { if ([string]::IsNullOrWhiteSpace($Label)) { try { $key.DeleteValue('_LabelFromReg', $false) } catch {} } else { $key.SetValue('_LabelFromReg', $Label, [Microsoft.Win32.RegistryValueKind]::String) }; $key.Close() }
		} catch {}
		try { $mp2.Close() } catch {}
	} catch {
		# best-effort; timer can retry
	}
	# Nudge Explorer caches (best-effort)
	try { Refresh-ShellIcons } catch {}; try { Refresh-AllExplorerViews } catch {}
}
function Test-MP2LabelApplied {
	[CmdletBinding()] param( [Parameter(Mandatory)][string]$Server, [Parameter(Mandatory)][string]$User, [string]$SubPath, [string]$Label )
	# No label desired -> nothing to enforce
	if ([string]::IsNullOrWhiteSpace($Server) -or [string]::IsNullOrWhiteSpace($User)) { return $false }
	if ([string]::IsNullOrWhiteSpace($Label)) { return $true }
	# build candidates exactly like Explorer does, with literal paths ( [] safe )
	$norm = Normalize-SubPath $SubPath
	$frag = if ($norm) { '#' + ($norm -replace '/', '#') } else { '' }
	$keys = @( "##$Server@ssl#remote.php#dav#files#$User$frag", "##$Server@ssl#DavWWWRoot#remote.php#dav#files#$User$frag" )
	foreach ($name in $keys) {
		$p = Join-Path $RegMP2 $name
		if (Test-Path -LiteralPath $p) {
			try { $val = (Get-ItemProperty -LiteralPath $p -ErrorAction Stop).'_LabelFromReg'; if ($val -and ($val -eq $Label)) { return $true } } catch {}
			# Sibling with trailing '#' (some builds materialize it)
			$s = $p + '#'
			if (Test-Path -LiteralPath $s) { try { $val2 = (Get-ItemProperty -LiteralPath $s -ErrorAction Stop).'_LabelFromReg'; if ($val2 -and ($val2 -eq $Label)) { return $true } } catch {} }
		}
	}
	return $false
}
# Delete exact MP2 key for given triplet (and its trailing '#'), both variants (with/without DavWWWRoot)
function Remove-MP2KeysetExact {
	[CmdletBinding()] param( [Parameter(Mandatory)][string]$Server, [Parameter(Mandatory)][string]$User, [string]$SubPath )
	# build candidates exactly like Explorer does, with literal paths ( [] safe )
	$norm = Normalize-SubPath $SubPath
	$frag = if ($norm) { '#' + ($norm -replace '/', '#') } else { '' }
	$names = @( "##$Server@ssl#remote.php#dav#files#$User$frag", "##$Server@ssl#DavWWWRoot#remote.php#dav#files#$User$frag" )
	foreach ($name in $names) {
		$key = Join-Path $RegMP2 $name
		foreach ($p in @($key, ($key + '#'))) { try { if (Test-Path -LiteralPath $p) { Remove-Item -LiteralPath $p -Recurse -Force } } catch {} }
	}
}

# ================================================================
#	Explorer branding (MountPoints2 label, drive icon HKCU)
# ================================================================
function Set-DriveIconHKCU {
	[CmdletBinding()] param( [Parameter(Mandatory)][string]$DriveLetter, [Parameter(Mandatory)][string]$IconPath )
	# Validate
	if (-not ($DriveLetter -match '^[A-Za-z]:$')) { return }; if (-not (Test-Path -LiteralPath $IconPath)) { return }
	$dl = $DriveLetter.Substring(0, 1).ToUpper()
	# Create full key chain under HKCU\Software\Classes\Applications\Explorer.exe\Drives\<X>\DefaultIcon
	try {
		$cu = [Microsoft.Win32.Registry]::CurrentUser
		$apps = $cu.CreateSubKey('Software\Classes\Applications', $true)
		$exp = $apps.CreateSubKey('Explorer.exe', $true)
		$drvS = $exp.CreateSubKey('Drives', $true)
		$drv = $drvS.CreateSubKey($dl, $true)
		$def = $drv.CreateSubKey('DefaultIcon', $true)
		# Write (Default) as REG_SZ with "<path>, 0"
		$def.SetValue('', "$IconPath, 0", [Microsoft.Win32.RegistryValueKind]::String)
		# Close handles
		$def.Close(); $drv.Close(); $drvS.Close(); $exp.Close(); $apps.Close()
	} catch {} # Swallow, timer will retry
	try { Refresh-ShellIcons } catch {} # Nudge the shell
}
function Remove-DriveIconHKCU {
	[CmdletBinding()] param( [Parameter(Mandatory)][string]$DriveLetter )
	if (-not ($DriveLetter -match '^[A-Za-z]:$')) { return }
	$dl = $DriveLetter.Substring(0, 1).ToUpper()
	# Delete HKCU\Software\Classes\Applications\Explorer.exe\Drives\<X>\* (keep ...\Drives)
	try { $cu = [Microsoft.Win32.Registry]::CurrentUser; $base = $cu.OpenSubKey('Software\Classes\Applications\Explorer.exe\Drives', $true); if ($base) { try { $base.DeleteSubKeyTree($dl, $false) } catch {}; $base.Close() } } catch {}
	try { Refresh-ShellIcons } catch {}
}
function Test-DriveIconApplied {
	[CmdletBinding()] param( [Parameter(Mandatory)][string]$DriveLetter, [Parameter(Mandatory)][string]$IconPath )
	# Cheap existence/value check via .NET (more robust than provider)
	if (-not ($DriveLetter -match '^[A-Za-z]:$')) { return $false }; if (-not (Test-Path -LiteralPath $IconPath)) { return $false }
	$dl = $DriveLetter.Substring(0, 1).ToUpper()
	try {
		$cu = [Microsoft.Win32.Registry]::CurrentUser
		$def = $cu.OpenSubKey("Software\Classes\Applications\Explorer.exe\Drives\$dl\DefaultIcon", $false)
		if ($null -eq $def) { return $false }
		$val = $def.GetValue('')
		$def.Close()
		return ($val -and ($val -ieq "$IconPath, 0"))
	} catch { return $false }
}
function Apply-WebDavBrandingFrom-State {
	# Apply label (MountPoints2) and icon (HKCU per-drive). No DavWWWRoot, no MP2 icon writes.
	if ([string]::IsNullOrWhiteSpace($State.Server) -or [string]::IsNullOrWhiteSpace($State.User) -or -not (Test-ValidDrive $State.Drive)) { return }
	# Ensure .ico file exists locally; fetch immediately if missing
	$icoPath = Get-FavIconFilePath
	if (-not (Test-Path -LiteralPath $icoPath)) { if ($script:ServerFaviconBmp) { [void](Save-IconFromBitmap $script:ServerFaviconBmp $icoPath) } else { [void](Fetch-ServerFavicon $State.Server) } }
	# Apply label via MountPoints2 (this is what Explorer honors for WebDAV name)
	try { Set-MP2LabelExactExact -Server $State.Server -User $State.User -SubPath $State.SubPath -Label $State.Label } catch {}
	# Apply icon via HKCU per-drive override (reliable for mapped letters)
	try { Set-DriveIconHKCU -DriveLetter $State.Drive -IconPath (Get-FavIconFilePath) } catch {}
	try { Refresh-ShellIcons } catch {}
}

# ================================================================
#	Shell refresh helpers (icon/association/drive removal)
# ================================================================
function Refresh-ExplorerDriveRemoval([string]$drive) {
	# Notify Explorer about drive removal (force immediate refresh)
	try {
		$path = if ($drive -match '^[A-Za-z]:$') { "$drive\" } else { $drive }
		$flags = 0x0005 -bor 0x2000 # SHCNF_PATHW | SHCNF_FLUSHNOW
		# 1) Drive removed
		[Nc.Shell]::SHChangeNotify(0x00008000, $flags, $path, $null) # SHCNE_DRIVEREMOVED
		# 2) Network share gone (mapped WebDAV behaves like a net resource)
		[Nc.Shell]::SHChangeNotify(0x00002000, $flags, $path, $null) # SHCNE_NETUNSHARE
		# 3) Associations/images changed (final nudge)
		[Nc.Shell]::SHChangeNotify(0x08000000, 0, [IntPtr]::Zero, [IntPtr]::Zero) # SHCNE_ASSOCCHANGED
		# Give the shell a tick to process the queue
		[System.Windows.Forms.Application]::DoEvents()
		Start-Sleep -Milliseconds 150
	} catch {}
}
function Ensure-BrandingTick {
	# Idempotent, cheap; called from timer when drive is accessible.
	try {
		# Ensure ICO exists; only download once if missing
		$icoPath = Get-FavIconFilePath
		if (-not (Test-Path -LiteralPath $icoPath)) { if ($script:ServerFaviconBmp) { [void](Save-IconFromBitmap $script:ServerFaviconBmp $icoPath) } else { [void](Fetch-ServerFavicon $State.Server) } }
		# Per-drive icon under HKCU\...\Explorer.exe\Drives\<X>\DefaultIcon
		if (-not (Test-DriveIconApplied -DriveLetter $State.Drive -IconPath (Get-FavIconFilePath))) { Set-DriveIconHKCU -DriveLetter $State.Drive -IconPath (Get-FavIconFilePath) }
	} catch {}
	try {
		# MountPoints2 label (create canonical key if none exists)
		if (-not (Test-MP2LabelApplied -Server $State.Server -User $State.User -SubPath $State.SubPath -Label $State.Label)) { Set-MP2LabelExactExact -Server $State.Server -User $State.User -SubPath $State.SubPath -Label $State.Label }
	} catch {}
}
function Test-ValidDrive([string]$d) { (-not [string]::IsNullOrWhiteSpace($d)) -and ($d -match '^[A-Za-z]:$') }
function Test-DriveAccessible { try { if (-not (Test-ValidDrive $State.Drive)) { return $false }; if (-not (Test-DriveMatchesDesired)) { return $false }; Get-ChildItem -LiteralPath ("{0}\" -f $State.Drive) -Force -ErrorAction Stop | Out-Null; return $true } catch { return $false } }

# ================================================================
#	Mapping / unmapping / mutex / drive-state checks
# ================================================================
function Map-Drive {
	if (-not (Test-ValidDrive $State.Drive)) { return $false }
	Ensure-MapMutex
	$occupied = (Get-PSDrive -PSProvider FileSystem | ForEach-Object { '{0}:' -f $_.Name }) -contains $State.Drive
	if ($occupied -and -not $script:mapMutexOwned -and -not (Test-DriveMatchesDesired)) { return $false }
	$pass = Get-PlainPassword
	# Early guard in Map-Drive (before building UNC / connecting)
	if (-not [string]::IsNullOrWhiteSpace($State.SubPath)) {
		if ($PortableMode) { if (-not (Ensure-PortablePass -Interactive)) { return $false } }
		if (-not (Test-NcFolderExists $State.SubPath)) {
			$gone = $State.SubPath; $State.SubPath = ''; $State.Label = ''; Save-Config; $ans = Ask-YesNoWarnT 'prompt.folder_no_longer_exists_choose_new' @{ folder = $gone }
			if ($ans -eq [System.Windows.Forms.DialogResult]::Yes) { $pick = Show-NcFolderPicker; if ($pick -ne $null) { $State.SubPath = $pick; Save-Config } else { return $false } } else { return $false }
		}
	}
	if ([string]::IsNullOrWhiteSpace($pass)) { return $false }
	$unc = Build-Unc $State.Server $State.User $State.SubPath
	if ($occupied -and (Test-DriveMatchesDesired)) { $ok = Test-DriveAccessible; if ($ok) { try { Apply-WebDavBrandingFrom-State } catch {} }; return $ok }
	Unmap-DriveIfOurs
	[int]$rc = 0
	if (New-WebDavMapSecure -drive $State.Drive -unc $unc -user $State.User -pass $pass -LastError ([ref]$rc)) { if (Test-DriveAccessible) { try { Apply-WebDavBrandingFrom-State } catch {}; return $true } } else { $script:tray.Text = "mapping failed (rc = $rc)" }
	return $false
}
function Unmap-Drive { if (Test-ValidDrive $State.Drive) { Unmap-DriveIfOurs -Force -RemoveProfile } }
# Call this everywhere the drive is torn down so label + icon are cleaned consistently
# add optional 'old' triplet for precise cleanup
function Unmap-DriveIfOurs {
	[CmdletBinding()]
	param(
		[string]$drive = $State.Drive, [switch]$RemoveProfile, [switch]$Force,
		# explicit cleanup target; defaults to current state if omitted
		[string]$Server = $State.Server, [string]$User = $State.User, [string]$SubPath = $State.SubPath
	)
	if (-not (Test-ValidDrive $drive)) { return }
	if (-not $Force) { if (-not ($script:mapMutexOwned -or (Test-DriveMatchesDesired))) { return } }
	# disconnect letter ...
	$flags = if ($RemoveProfile) { [Nc.NetUse]::CONNECT_UPDATE_PROFILE } else { 0 }
	try { [void][Nc.NetUse]::WNetCancelConnection2($drive, $flags, $true) } catch {}
	# also by UNC ...
	try { $unc = if ($Server -and $User) { Build-Unc $Server $User $SubPath } else { $null }; if ($unc) { [void][Nc.NetUse]::WNetCancelConnection2($unc, $flags, $true) } } catch {}
	try { Remove-PSDrive -Name $drive.Substring(0, 1) -Force -ErrorAction SilentlyContinue } catch {}
	try { if (Get-PSDrive -Name $drive.Substring(0, 1) -ErrorAction SilentlyContinue) { Start-Process -FilePath "$env:SystemRoot\System32\net.exe" -ArgumentList ("use {0} /delete /y" -f $drive) -WindowStyle Hidden -Wait | Out-Null } } catch {}
	# --- nuke exact MP2 key for *that* mapping (not the current state) ---
	try { Remove-MP2KeysetExact -Server $Server -User $User -SubPath $SubPath } catch {}
	# icon override
	try { Remove-DriveIconHKCU -DriveLetter $drive } catch {}; try { Refresh-ExplorerDriveRemoval $drive } catch {}
}
function Wait-DriveFullyUnmapped {
	[CmdletBinding()] param( [string]$Drive, [int]$TimeoutMs = 3000 )
	if (-not (Test-ValidDrive $Drive)) { return $true }
	# Initial cool-down to let Mini-Redirector tear down
	Start-Sleep -Milliseconds 1000
	$sw = [System.Diagnostics.Stopwatch]::StartNew()
	while ($sw.ElapsedMilliseconds -lt $TimeoutMs) {
		$exists = Get-PSDrive -PSProvider FileSystem -ErrorAction SilentlyContinue | Where-Object { ('{0}:' -f $_.Name) -ieq $Drive } | Select-Object -First 1
		if (-not $exists) { return $true }; Start-Sleep -Milliseconds 150
	}
	return $false
}
function Ensure-MapMutex {
	$name = "Local\${AppName}:map:{0}:{1}:{2}:{3}" -f ( ($State.Drive.ToUpper()), $State.Server.ToLower(), $State.User.ToLower(), (Normalize-SubPath $State.SubPath).ToLower() )
	if ($script:mapMutexName -ne $name -and $script:mapMutexObj) { try { $script:mapMutexObj.ReleaseMutex() | Out-Null } catch {}; try { $script:mapMutexObj.Dispose() } catch {}; $script:mapMutexOwned = $false; $script:mapMutexObj = $null }
	if (-not $script:mapMutexObj) { $owned = $false; $obj = New-Object System.Threading.Mutex($true, $name, [ref]$owned); $script:mapMutexObj = $obj; $script:mapMutexName = $name; $script:mapMutexOwned = $owned }
}
function Test-DriveMatchesDesired {
	try {
		if (-not (Test-ValidDrive $State.Drive) -or [string]::IsNullOrWhiteSpace($State.Server) -or [string]::IsNullOrWhiteSpace($State.User)) { return $false }
		$pd = Get-PSDrive -PSProvider FileSystem -ErrorAction SilentlyContinue | Where-Object { ('{0}:' -f $_.Name) -ieq $State.Drive } | Select-Object -First 1
		if (-not $pd) { return $false }
		$root = if ($pd.PSObject.Properties.Name -contains 'DisplayRoot' -and $pd.DisplayRoot) { $pd.DisplayRoot } else { $pd.Root }
		if (-not $root) { return $false }
		$svr = [regex]::Escape($State.Server); $usr = [regex]::Escape($State.User); $norm = Normalize-SubPath $State.SubPath; $subRx = ''
		if ($norm) { $parts = $norm -split '/'; $parts = $parts | ForEach-Object { [regex]::Escape($_) }; $subRx = '\\' + ($parts -join '\\') }
		# Accept both UNC shapes, with optional trailing backslash:
		# \\server@ssl\remote.php\dav\files\user
		# \\server@ssl\DavWWWRoot\remote.php\dav\files\user
		$rx = '^\\\\' + $svr + '@ssl\\(?:DavWWWRoot\\)?remote\.php\\dav\\files\\' + $usr + $subRx + '(?:\\)?$'
		return ($root -imatch $rx)
	} catch { return $false }
}

# ================================================================
#	Dialogs (passphrase prompt, drive-in-use)
# ================================================================
# Strip leading "<AppName>: " and optional "[D-Z]: "
function Get-TrayStatusCore([string]$text) { if ([string]::IsNullOrWhiteSpace($text)) { return '' }; $pat = '^' + [regex]::Escape($AppName) + ':\s*(?:[D-Z]:\s*)?'; return ([regex]::Replace($text, $pat, '')).Trim() }
function Prompt-Passphrase([string]$title, [switch]$Confirm, [switch]$ExitOnCancel) {
	# Build form
	$f = New-Object System.Windows.Forms.Form; Apply-BrandIconToForm $f; Hook-FormDpi $f
	$f.Text = $title; $f.StartPosition = 'CenterScreen'; $f.FormBorderStyle = 'FixedDialog'; $f.MaximizeBox = $false; $f.MinimizeBox = $false; $f.TopMost = $true; $h = 160; if ($Confirm) { $h = 210 }; $f.Width = 420; $f.Height = $h; $f.KeyPreview = $true
	$lbl = New-Object System.Windows.Forms.Label; $lbl.Text = (T 'label.passphrase_enter'); $lbl.AutoSize = $true; $lbl.Left = 12; $lbl.Top = 18
	$txt = New-Object System.Windows.Forms.TextBox; $txt.Left = 160; $txt.Top = 16; $txt.Width = 230; $txt.UseSystemPasswordChar = $true
	$lbl2 = $null; $txt2 = $null
	if ($Confirm) { $lbl2 = New-Object System.Windows.Forms.Label; $lbl2.Text = (T 'label.passphrase_confirm'); $lbl2.AutoSize = $true; $lbl2.Left = 12; $lbl2.Top = 56; $txt2 = New-Object System.Windows.Forms.TextBox; $txt2.Left = 160; $txt2.Top = 54; $txt2.Width = 230; $txt2.UseSystemPasswordChar = $true }
	$ok = New-Object System.Windows.Forms.Button; $ok.Text = (T 'button.ok'); $ok.Width = 100; $ok.Left = $f.ClientSize.Width - 216; $ok.Top = $f.ClientSize.Height - 40; $ok.Height = $script:ButtonXH; $ok.Anchor = 'Bottom, Right'
	$ok.Add_Click({ if ($Confirm -and ($txt.Text -ne $txt2.Text)) { Show-WarnT 'message.passphrase_mismatch'; return }; $f.DialogResult = [System.Windows.Forms.DialogResult]::OK; $f.Close() })
	$ca = New-Object System.Windows.Forms.Button; $ca.Text = (T 'button.cancel'); $ca.Width = 100; $ca.Left = $f.ClientSize.Width - 108; $ca.Top = $f.ClientSize.Height - 40; $ca.Height = $script:ButtonXH; $ca.Anchor = 'Bottom, Right'
	# Set the tab order correctly so that tabbing goes from Field1 -> Field2 -> OK -> Cancel
	$txt.TabIndex = 0; if ($Confirm) { $txt2.TabIndex = 1; $ok.TabIndex = 2; $ca.TabIndex = 3 } else { $ok.TabIndex = 1; $ca.TabIndex = 2 }
	$ca.Add_Click({
		if ($ExitOnCancel) {
			try { if ($miExit) { $miExit.PerformClick(); return } } catch {}
			try { if ($script:timer) { $script:timer.Stop() } } catch {}
			try { Unmap-Drive } catch {}
			try { if ($script:mainMutex) { $script:mainMutex.ReleaseMutex() | Out-Null; $script:mainMutex.Dispose() } } catch {}
			try { if ($script:tray) { $script:tray.Visible = $false; $script:tray.Dispose() } } catch {}
			[System.Windows.Forms.Application]::Exit()
			return
		}
		$f.DialogResult = [System.Windows.Forms.DialogResult]::Cancel
		$f.Close()
	})
	# Enter/Esc support
	$f.AcceptButton = $ok; $f.CancelButton = $ca
	$f.Add_KeyDown({ param($s, $e); if ($e.KeyCode -eq 'Enter') { $ok.PerformClick() } elseif ($e.KeyCode -eq 'Escape') { $ca.PerformClick() } })
	$f.Controls.AddRange(@($lbl, $txt, $ok, $ca))
	if ($Confirm) { $f.Controls.AddRange(@($lbl2, $txt2)) }
	$null = $txt.Focus(); $res = $f.ShowDialog()
	if ($res -eq [System.Windows.Forms.DialogResult]::OK) { return $txt.Text }
	return $null
}
function Ensure-PortablePass([switch]$Interactive) {
	if (-not $PortableMode) { return $true }
	if (-not (Test-Path $SecretPath)) { return $true }
	if ($script:PlainPassCache) { return $true }
	if (-not $Interactive) { return $false }
	$pp = Prompt-Passphrase (T 'title.passphrase_query' @{ app = $AppName }) -ExitOnCancel
	if ($null -eq $pp) {
		# User cancelled  exit now (we may already be inside the message loop)
		try { if ($miExit) { $miExit.PerformClick(); return $false } } catch {}
		try { if ($script:timer) { $script:timer.Stop() } } catch {}
		try { Unmap-Drive } catch {}
		try { if ($script:mainMutex) { $script:mainMutex.ReleaseMutex() | Out-Null; $script:mainMutex.Dispose() } } catch {}
		try { if ($script:tray) { $script:tray.Visible = $false; $script:tray.Dispose() } } catch {}
		[System.Windows.Forms.Application]::Exit()
		return $false
	}
	try { $script:PlainPassCache = Unprotect-PortableSecret $pp $SecretPath; return $true } catch { Show-WarnT 'message.passphrase_wrong_or_corrupt'; $script:AskedPassphrase = $false; return $false }
}

# ================================================================
#	Install / export / uninstall (Run key, shortcuts, packages)
# ================================================================
# ---------- Autostart / install / shortcuts (installed only) ----------
function Set-StartupRunKey([bool]$enable) {
	if ($PortableMode) { return }
	$exe, $args = Get-LauncherFor $InstallBin
	if ($enable) { New-ItemProperty -Path $RunKey -Name $AppName -Value "`"$exe`" $args" -PropertyType String -Force | Out-Null }
	elseif (Get-ItemProperty -Path $RunKey -Name $AppName -ErrorAction SilentlyContinue) { Remove-ItemProperty -Path $RunKey -Name $AppName -Force }
}
function Is-StartupRunKeyEnabled { if ($PortableMode) { return $false }; $val = Get-ItemProperty -Path $RunKey -Name $AppName -ErrorAction SilentlyContinue; return ($null -ne $val) }
function Get-StartMenuShortcutPath { $sm = [Environment]::GetFolderPath('StartMenu'); return (Join-Path (Join-Path $sm 'Programs') "$AppName.lnk") }
function Get-DesktopShortcutPath { $desk = [Environment]::GetFolderPath('Desktop'); return (Join-Path $desk "$AppName.lnk") }
function New-Shortcut($lnkPath, $scriptPath, [string]$IconPath = $null) {
	$exe, $args = Get-LauncherFor $scriptPath; $ws = New-Object -ComObject WScript.Shell; $sc = $ws.CreateShortcut($lnkPath); $sc.TargetPath = $exe; $sc.Arguments = $args
	# prefer explicit icon; otherwise try installed app ico; fallback to shell icon
	if (-not $IconPath -and -not $PortableMode) { $autoIco = Join-Path $InstallDir ("{0}.ico" -f $AppNameShort); if (Test-Path -LiteralPath $autoIco) { $IconPath = $autoIco } }
	if ($IconPath -and (Test-Path -LiteralPath $IconPath)) { $sc.IconLocation = "$IconPath, 0" }
	else { $sc.IconLocation = "$env:SystemRoot\system32\shell32.dll, 44" }
	$sc.WorkingDirectory = (Split-Path $scriptPath -Parent)
	$sc.Save()
}
function Shortcut-Exists($which) { if ($PortableMode) { return $false }; $lnk = if ($which -eq 'StartMenu') { Get-StartMenuShortcutPath } else { Get-DesktopShortcutPath }; return (Test-Path $lnk) }
function Ensure-Shortcut($which, [bool]$enable) {
	if ($PortableMode) { return }
	$lnk = if ($which -eq 'StartMenu') { Get-StartMenuShortcutPath } else { Get-DesktopShortcutPath }
	if ($enable) { if (-not (Test-Path $lnk)) { New-Shortcut -lnkPath $lnk -scriptPath $InstallBin } }
	elseif (Test-Path $lnk) { Remove-Item $lnk -Force }
}
function Install-Self {
	[CmdletBinding()] param( [switch]$FromInstaller )
	if (-not $PortableMode) { Show-InfoT 'message.already_installed_appdata'; return }
	try {
		# Ensure install directory exists
		if (-not (Test-Path $InstallDir)) { New-Item -ItemType Directory -Path $InstallDir -Force | Out-Null }
		# Copy main script into install directory
		Copy-Item -LiteralPath $PSCommandPath -Destination $InstallBin -Force
		# Copy i18n directory as a whole; if missing at source, ensure empty i18n target directory exists
		$srcI18n = Join-Path $HereDir 'i18n'; $dstI18n = Join-Path $InstallDir 'i18n'
		if (-not (Test-Path -LiteralPath $dstI18n)) { New-Item -ItemType Directory -Path $dstI18n -Force | Out-Null }
		if (Test-Path -LiteralPath $srcI18n) { try { Copy-Item -Path (Join-Path $srcI18n '*') -Destination $dstI18n -Recurse -Force } catch {} }
		# reconstruct icon from embedded base64 into install dir
		Ensure-AppBrandIcons
		$iconDst = Join-Path $InstallDir ("{0}.ico" -f $AppNameShort)
		try { [System.IO.File]::WriteAllBytes($iconDst, (Get-EmbeddedIconBytes)); $iconIcoPath = $iconDst } catch { $iconIcoPath = $null }
		# Skip any "import from portable" prompt if coming from installer
		if (-not $FromInstaller) {
			# Ask to import portable settings into installed mode
			$ans = Ask-YesNoQuestT 'prompt.import_portable_settings_to_installed'
			if ($ans -eq [System.Windows.Forms.DialogResult]::Yes) {
				# 1) get plaintext app-password from portable secret (if available)
				$plain = $null
				if (Test-Path $SecretPath) { $pp = Prompt-Passphrase (T 'title.passphrase_query' @{ app = $AppName }); if ($pp) { try { $plain = Unprotect-PortableSecret $pp $SecretPath } catch {} } }
				elseif ($script:PlainPassCache) { $plain = $script:PlainPassCache }
				# 2) convert plaintext to DPAPI blob for installed mode
				$encVal = ''
				if ($plain) { $sec = ConvertTo-SecureString $plain -AsPlainText -Force; $encVal = ($sec | ConvertFrom-SecureString) }
				$State.EncPass = $encVal
				# 3) write everything (Server/User/.../LangPref/IntervalS + EncPass) using the DRY helper
				Write-StateToRegistry
			}
		}
		# launcher + autostart (Run key)
		$exe, $args = Get-LauncherFor $InstallBin
		New-ItemProperty -Path $RunKey -Name $AppName -Value "`"$exe`" $args" -PropertyType String -Force | Out-Null
		# shortcuts by default
		New-Shortcut -lnkPath (Get-StartMenuShortcutPath) -scriptPath $InstallBin -IconPath $iconIcoPath; New-Shortcut -lnkPath (Get-DesktopShortcutPath) -scriptPath $InstallBin -IconPath $iconIcoPath
		# Success popup BEFORE exit/relaunch
		try { Show-InfoT 'message.installed_to_appdata_success' } catch {}
		# Only auto-launch if not invoked from the bootstrap path
		if (-not $FromInstaller) { Start-Process -FilePath $exe -ArgumentList $args -WindowStyle Hidden | Out-Null } # relaunch installed (hidden) and exit this instance
		try { if ($script:timer) { $script:timer.Stop(); $script:timer.Dispose() } } catch {}
		try { Unmap-Drive } catch {}
		try { if ($script:mainMutex) { $script:mainMutex.ReleaseMutex() | Out-Null; $script:mainMutex.Dispose() } } catch {}
		try { if ($script:tray) { $script:tray.Visible = $false; $script:tray.Dispose() } } catch {}
		[System.Windows.Forms.Application]::Exit()
	} catch { Show-ErrorT 'message.install_failed' @{ err = $_.Exception.Message } }
}
# Helper: detect whether a folder already contains a NcDavTray portable package
function Test-IsPortableFolder {
	[CmdletBinding()] param( [Parameter(Mandatory = $true)][string]$Path )
	try {
		if ([string]::IsNullOrWhiteSpace($Path) -or -not (Test-Path -LiteralPath $Path)) { return $false }
		$items = Get-ChildItem -LiteralPath $Path -Force -ErrorAction SilentlyContinue
		if (-not $items) { return $false }
		# Heuristics: presence of any of these marks a portable package
		foreach ($it in $items) {
			$name = $it.Name
			if ($name -like ("Start {0}.cmd" -f $AppName)) { return $true }
			if ($name -ieq ("{0}.vbs" -f $AppNameShort)) { return $true }
			if ($name -ieq ("{0}_portable.json" -f $AppName)) { return $true }
			if ($name -ieq ("{0}_secret.dat" -f $AppNameShort)) { return $true }
			if ($name -ieq ("{0}.ps1" -f $AppNameShort)) { return $true }
		}
		return $false
	} catch { return $false }
}
# Helper: write VBS/CMD/README into $Destination
function Write-PortableLaunchers {
	[CmdletBinding()] param( [Parameter(Mandatory = $true)][string]$Destination, [Parameter(Mandatory = $true)][string]$ScriptName, [Parameter(Mandatory = $true)][string]$SpdxFrom )
	# Extract SPDX lines from the .ps1 header (first 80 lines is plenty)
	$spdx = @()
	try {
		$head = Get-Content -LiteralPath $SpdxFrom -First 80 -ErrorAction Stop
		$spdx = $head | Where-Object { $_ -match '^\s*#\s*SPDX-' } | ForEach-Object { ($_ -replace '^\s*#\s*', '').Trim() }
	} catch {}
	# --- VBS launcher ---
	$vbsHeader = $spdx | ForEach-Object { "' " + $_ }
	$vbsBody = @(
		"Option Explicit", "", "Dim fso, shell, here, ps1, cmd", "Set fso = CreateObject(""Scripting.FileSystemObject"")",
		"Set shell = CreateObject(""WScript.Shell"")", "", "here = fso.GetParentFolderName(WScript.ScriptFullName)", ("ps1 = fso.BuildPath(here, ""{0}"")" -f $ScriptName), "",
		# Use Chr(34) to avoid crazy quote-escaping; equivalent to double double-quotes:
		'cmd = "powershell.exe -NoProfile -ExecutionPolicy Bypass -STA -WindowStyle Hidden -File " & Chr(34) & ps1 & Chr(34)', "shell.Run cmd, 0, False"
	)
	$vbsPath = Join-Path $Destination ('{0}.vbs' -f $AppNameShort)
	# IMPORTANT: do not concatenate arrays with + then -join; use a single flat array
	@($vbsHeader; ""; $vbsBody) -join "`r`n" | Set-Content -Path $vbsPath -Encoding ASCII
	# --- CMD starter (calls the VBS via relative path) ---
	$cmdHeader = $spdx | ForEach-Object { ":: " + $_ }
	$cmdBody = @( "@echo off", ("wscript.exe ""%~dp0{0}.vbs""" -f $AppNameShort) )
	$cmdPath = Join-Path $Destination ("Start {0}.cmd" -f $AppName)
	@($cmdHeader; ""; $cmdBody) -join "`r`n" | Set-Content -Path $cmdPath -Encoding ASCII
	# --- README_FIRST.txt (short variant) ---
	$readme = @"
$AppName (portable)

Start the app by double-clicking: "Start $AppName.cmd"

Much and good luck,
ernolf
"@
	Set-Content -Path (Join-Path $Destination 'README_FIRST.txt') -Value $readme -Encoding UTF8
}
# Export to portable (in-place or to another folder)
function Export-To-Portable {
	[CmdletBinding()] param( [switch]$Force, [switch]$SkipConfirm )
	# Only from installed mode unless explicitly forced (installer)
	if ($PortableMode -and (-not $Force)) { Write-Verbose 'Export-To-Portable: running in portable mode and Force is not set -> abort'; return }
	if (-not $SkipConfirm) { $ansPre = Ask-YesNoQuestT 'prompt.export2portable' @{ appshort = $AppNameShort; app = $AppName }; if ($ansPre -ne [System.Windows.Forms.DialogResult]::Yes) { return } }
	$oldEAP = $ErrorActionPreference
	$ErrorActionPreference = 'Stop'
	try {
		# Resolve script path (PS 5.1 safe)
		$scriptPath = Get-ThisScriptPath
		# Fallback: let user point to the ps1 (rare)
		if (-not $scriptPath) { $ofd = New-Object System.Windows.Forms.OpenFileDialog; $ofd.Title = ('Select {0}.ps1' -f $AppNameShort); $ofd.Filter = 'PowerShell script (*.ps1)|*.ps1'; $ofd.InitialDirectory = (Get-Location).Path; if ($ofd.ShowDialog() -ne 'OK') { return }; $scriptPath = $ofd.FileName }
		if ([string]::IsNullOrWhiteSpace($scriptPath) -or -not (Test-Path -LiteralPath $scriptPath)) { $display = if ($scriptPath -ne $null -and $scriptPath -ne '') { $scriptPath } else { '<null>' }; throw ("Cannot resolve script path: {0}" -f $display) }
		$scriptName = [System.IO.Path]::GetFileName($scriptPath); $hereAbs = [System.IO.Path]::GetDirectoryName($scriptPath)
		Write-Verbose ("Script path: {0}" -f $scriptPath)
		# Decide default selection:
		# - called by external installer: script folder
		# - normal export from installed mode: Desktop
		$defaultSel = if ($script:FromInstaller) { $hereAbs } else { [Environment]::GetFolderPath('Desktop') }
		Write-Verbose ("Default folder: {0}" -f $defaultSel)
		# Folder picker (defaults as decided above)
		$dlg = New-Object System.Windows.Forms.FolderBrowserDialog; $dlg.Description = (T 'hint.select_portable_folder'); $dlg.SelectedPath = $defaultSel
		if ($dlg.ShowDialog() -ne 'OK') { return }
		$chosen = [System.IO.Path]::GetFullPath($dlg.SelectedPath)
		Write-Verbose ("Chosen folder: {0}" -f $chosen)
		# --- Determine target root and whether we update in place ---
		$updateInPlace = $false
		$dstRoot = $null
		# Case 1: user selected a folder that already *is* a portable folder -> update in place
		if (Test-IsPortableFolder -Path $chosen) { $dstRoot = $chosen; $updateInPlace = $true; Write-Verbose "Detected existing portable folder -> update in place." }
		# Case 2: otherwise use <chosen>\<AppName>Portable; if that is portable, also update in place
		if (-not $dstRoot) { $maybeRoot = Join-Path $chosen ("{0}Portable" -f $AppName); if (Test-IsPortableFolder -Path $maybeRoot) { $dstRoot = $maybeRoot; $updateInPlace = $true; Write-Verbose "Detected existing portable folder at nested path -> update in place." } else { $dstRoot = $maybeRoot; Write-Verbose ("Will create new portable package at: {0}" -f $dstRoot) } }
		# --- CASE A: same folder as script -> write launchers only (bare helper) ---
		if ($chosen -ieq $hereAbs) { Write-Verbose "In-place launchers in script folder (bare mode)..."; Write-PortableLaunchers -Destination $hereAbs -ScriptName $scriptName -SpdxFrom $scriptPath; Show-InfoT 'message.portable_launchers_inplace' @{ path = $hereAbs }; return }
		# Ensure destination exists (only create when not updating-in-place)
		if (-not (Test-Path -LiteralPath $dstRoot)) { New-Item -ItemType Directory -Path $dstRoot -Force | Out-Null }
		else {
			# Folder exists. If it is NOT a recognized portable folder and not empty, optionally confirm cleanup.
			if (-not $updateInPlace) {
				$count = (Get-ChildItem -LiteralPath $dstRoot -Force -ErrorAction SilentlyContinue | Measure-Object).Count
				if ($count -gt 0) {
					# Ask before wiping an arbitrary non-portable folder
					$ans2 = Ask-YesNoQuestT 'prompt.folder_is_not_empty_overwrite' @{ dir = $dstRoot }
					if ($ans2 -eq [System.Windows.Forms.DialogResult]::Cancel) { return }
					if ($ans2 -eq [System.Windows.Forms.DialogResult]::Yes) { try { Remove-Item -LiteralPath $dstRoot -Recurse -Force -ErrorAction SilentlyContinue } catch {}; New-Item -ItemType Directory -Path $dstRoot -Force | Out-Null } else { $dstRoot = Join-Path $chosen ("{0}Portable_{1}" -f $AppName, (Get-Date -Format 'yyyyMMdd_HHmmss')); New-Item -ItemType Directory -Path $dstRoot -Force | Out-Null }
				}
			}
		}
		# Copy main script (always overwrite)
		$dstPs1 = Join-Path $dstRoot $scriptName; Write-Verbose ("Copy script -> {0}" -f $dstPs1); Copy-Item -LiteralPath $scriptPath -Destination $dstPs1 -Force
		# Copy/merge i18n (create dir if missing; overwrite files but do not delete unknown files)
		$srcI18n = Join-Path $hereAbs 'i18n'; $dstI18n = Join-Path $dstRoot 'i18n'
		if (-not (Test-Path -LiteralPath $dstI18n)) { New-Item -ItemType Directory -Path $dstI18n -Force | Out-Null }
		if (Test-Path -LiteralPath $srcI18n) { try { Copy-Item -Path (Join-Path $srcI18n '*') -Destination $dstI18n -Recurse -Force -ErrorAction SilentlyContinue } catch {} }
		# Bare mode? (called by external installer) = > do not (re)create config/secret
		$bare = ($script:FromInstaller -eq $true)
		if (-not $bare -and -not $updateInPlace) {
			# -------- New portable export (create config + secret) --------
			# portable config JSON (no DPAPI secret)
			$port = New-StateConfigObject
			$cfgPath = Join-Path $dstRoot ("{0}_portable.json" -f $AppName)
			Write-Verbose ("Write config -> {0}" -f $cfgPath)
			$port | ConvertTo-Json | Set-Content -Path $cfgPath -Encoding UTF8
			# Ensure plaintext App-Password
			$pw = Get-PlainPassword
			if ([string]::IsNullOrEmpty($pw)) {
				Write-Verbose "No plaintext in registry -> prompt for App-Password"
				$pwDlg = New-Object System.Windows.Forms.Form
				Apply-BrandIconToForm $pwDlg
				$pwDlg.Text = (T 'title.app_password_query' @{ app = $AppName })
				$pwDlg.StartPosition = 'CenterScreen'; $pwDlg.FormBorderStyle = 'FixedDialog'
				$pwDlg.MaximizeBox = $false; $pwDlg.MinimizeBox = $false; $pwDlg.TopMost = $true; $pwDlg.Width = 360; $pwDlg.Height = 150
				$lbl = New-Object Windows.Forms.Label; $lbl.Text = (T 'app_password'); $lbl.Left = 12; $lbl.Top = 20; $lbl.AutoSize = $true
				$txt = New-Object Windows.Forms.TextBox; $txt.Left = 120; $txt.Top = 18; $txt.Width = 200; $txt.UseSystemPasswordChar = $true
				$ok = New-Object Windows.Forms.Button; $ok.Text = (T 'button.ok'); $ok.Left = 170; $ok.Top = 60; $ok.Width = 70; $ok.Height = $script:ButtonXH
				$ca = New-Object Windows.Forms.Button; $ca.Text = (T 'button.cancel'); $ca.Left = 250; $ca.Top = 60; $ca.Width = 70; $ca.Height = $script:ButtonXH
				$ok.Add_Click({ $pwDlg.Tag = $txt.Text; $pwDlg.DialogResult = 'OK'; $pwDlg.Close() })
				$ca.Add_Click({ $pwDlg.DialogResult = 'Cancel'; $pwDlg.Close() })
				$pwDlg.Controls.AddRange(@($lbl, $txt, $ok, $ca))
				if ($pwDlg.ShowDialog() -ne 'OK') { return }
				$pw = [string]$pwDlg.Tag
			}
			# Passphrase (confirm)
			$ppVal = $null
			$ppRes = Prompt-Passphrase (T 'title.passphrase_set' @{ app = $AppName }) -Confirm
			if ($ppRes -is [string]) { $ppVal = $ppRes } elseif ($ppRes -and ($ppRes.PSObject.Properties.Name -contains 'Value')) { $ppVal = $ppRes.Value }
			if ([string]::IsNullOrWhiteSpace($ppVal)) { return }
			# secret.dat
			$destSecretPath = Join-Path $dstRoot ("{0}_secret.dat" -f $AppNameShort)
			Write-Verbose ("Write secret -> {0}" -f $destSecretPath)
			Protect-PortableSecret $pw $ppVal $destSecretPath
		} else { Write-Verbose "Portable update/bare: keeping existing *_portable.json and *_secret.dat unchanged." } # Update path (or bare): never delete config/secret; just leave them as-is
		# Launchers + README (always)
		Write-Verbose "Write launchers/README..."
		Write-PortableLaunchers -Destination $dstRoot -ScriptName $scriptName -SpdxFrom $dstPs1
		# Final message
		$msgKey = if ($updateInPlace) { 'message.portable_package_updated' } elseif ($bare) { 'message.portable_package_installed' } else { 'message.portable_package_exported' }
		$msg = T $msgKey @{ path = [string]$dstRoot }; Show-InfoT $msg
	} catch { Write-Verbose ("ERROR at: {0}" -f ($_.InvocationInfo.PositionMessage)); Show-ErrorT 'message.export_failed' @{ err = $_.Exception.Message }
	} finally { $ErrorActionPreference = $oldEAP }
}
function Export-InstalledConfig([switch]$SkipConfirm) {
	if ($PortableMode) { return }
	if (-not $SkipConfirm) { $ans = Ask-YesNoQuestT 'prompt.export2json' @{ app = $AppName }; if ($ans -ne [System.Windows.Forms.DialogResult]::Yes) { return } }
	try {
		$dlg = New-Object System.Windows.Forms.SaveFileDialog
		$dlg.Title = (T 'title.export_config'); $dlg.Filter = 'JSON (*.json)|*.json'; $dlg.FileName = ('{0}_installed.json' -f $AppName); $dlg.InitialDirectory = [Environment]::GetFolderPath('Desktop')
		if ($dlg.ShowDialog() -ne 'OK') { return }
		# Object that includes normal keys + DPAPI secret as 'DPAPI'
		$payload = New-InstalledExportObject; $payload | ConvertTo-Json | Set-Content -Path $dlg.FileName -Encoding UTF8
		Show-InfoT 'message.installed_config_exported'
	} catch { Show-ErrorT 'message.export_failed' @{ err = $_.Exception.Message } }
}
function Uninstall-Self {
	# Pre-uninstall export prompts (installed mode only)
	if (-not $PortableMode) {
		# Detect if any settings have been saved before (registry preferred; fall back to $State signal fields)
		$shouldOfferExport = $false
		if ($State -and -not [string]::IsNullOrWhiteSpace($State.EncPass) -and -not [string]::IsNullOrWhiteSpace($State.Server) -and -not [string]::IsNullOrWhiteSpace($State.User)) { $shouldOfferExport = $true }
		if ($shouldOfferExport) {
			# 1) Offer export of installed config (DPAPI blob, for same user/same machine restore)
			$ans1 = Ask-YesNoCancelQuestT 'prompt.export2json_before_uninstall' @{ app = $AppName }
			if ($ans1 -eq [System.Windows.Forms.DialogResult]::Cancel) { return }
			if ($ans1 -eq [System.Windows.Forms.DialogResult]::Yes) { try { Export-InstalledConfig -SkipConfirm } catch {} }
			# 2) Offer export of full portable package (passphrase-protected secret etc.)
			$ans2 = Ask-YesNoCancelQuestT 'prompt.export2portable_before_uninstall' @{ appshort = $AppNameShort; app = $AppName }
			if ($ans2 -eq [System.Windows.Forms.DialogResult]::Cancel) { return }
			if ($ans2 -eq [System.Windows.Forms.DialogResult]::Yes) { try { Export-To-Portable -SkipConfirm } catch {} }
		}
	}
	try { if ($script:timer) { $script:timer.Stop(); $script:timer.Dispose() } } catch {}
	try { Unmap-DriveIfOurs -Force -RemoveProfile } catch {}
	try { if ($menu) { $menu.Close(); $menu.Dispose() } } catch {}
	try { if ($script:mainMutex) { $script:mainMutex.ReleaseMutex() | Out-Null; $script:mainMutex.Dispose() } } catch {}
	try { if ($script:tray) { $script:tray.Visible = $false; $script:tray.Dispose() } } catch {}
	try { [System.Windows.Forms.Application]::DoEvents() } catch {}
	Start-Sleep -Milliseconds 120
	if ($PortableMode) { [System.Windows.Forms.Application]::Exit(); exit }
	try { if (Test-ValidDrive $State.Drive) { Remove-DriveIconHKCU -DriveLetter $State.Drive } } catch {}
	try { Set-StartupRunKey $false } catch {}
	try { Ensure-Shortcut 'StartMenu' $false } catch {}
	try { Ensure-Shortcut 'Desktop' $false } catch {}
	try { if (Test-Path $RegBase) { Remove-Item -Path $RegBase -Recurse -Force } } catch {}
	try {
		if (Test-Path $InstallDir) {
			$vbsName = [System.IO.Path]::ChangeExtension($ScriptFile, 'vbs')
			$bat = Join-Path $env:TEMP ("${AppName}-uninstall-{0}.cmd" -f ([guid]::NewGuid()))
			$batContent = @(
				'@echo off',
				'setlocal',
				'ping -n 2 127.0.0.1 >nul',
				'del /F /Q "%LOCALAPPDATA%\%APPNAME%\%SCRIPTFILE%" >nul 2>nul',
				'del /F /Q "%LOCALAPPDATA%\%APPNAME%\%VBSFILE%" >nul 2>nul',
				'rd /S /Q "%LOCALAPPDATA%\%APPNAME%" >nul 2>nul',
				'endlocal'
			) -join "`r`n"
			$batContent = $batContent -replace '%APPNAME%', $AppName
			$batContent = $batContent -replace '%SCRIPTFILE%', $ScriptFile
			$batContent = $batContent -replace '%VBSFILE%', $vbsName
			Set-Content -Path $bat -Value $batContent -Encoding ASCII
			Start-Process -FilePath "$env:SystemRoot\System32\cmd.exe" -ArgumentList "/c `"$bat`"" -WindowStyle Hidden | Out-Null
		}
	} catch {}
	[System.Windows.Forms.Application]::Exit()
	exit
}

# ================================================================
#	Tray icon rendering & small image assets
# ================================================================
# returns raw bytes of embedded .ico # strip whitespace just in case
function Get-EmbeddedIconBytes { $b64 = ($LogoIcoB64 -replace '\s', ''); return [Convert]::FromBase64String($b64) }
# create (once) and cache icon + bitmap for reuse
function Ensure-AppBrandIcons {
	if ($script:AppIcon -and -not $script:AppIcon.IsDisposed) { return } # already initialized
	try { $bytes = Get-EmbeddedIconBytes; $ms = New-Object System.IO.MemoryStream(, $bytes); $ico = New-Object System.Drawing.Icon $ms; $script:AppIcon = $ico; $ms.Dispose() } catch { $script:AppIcon = $null }
}
# convenience setter to call when creating UI elements
function Apply-BrandIconToForm($form) { Ensure-AppBrandIcons; if ($script:AppIcon) { try { $form.Icon = $script:AppIcon } catch {} } }
# ---------- Tray icon ----------
function New-StatusIcon([string]$label, [System.Drawing.Color]$color) {
	$bmp = New-Object System.Drawing.Bitmap 20, 20
	$g = [System.Drawing.Graphics]::FromImage($bmp); $g.SmoothingMode = 'AntiAlias'; $g.PixelOffsetMode = 'Half'; $g.TextRenderingHint = 'AntiAliasGridFit'; $g.Clear([System.Drawing.Color]::Transparent)
	$brush = New-Object System.Drawing.SolidBrush($color)
	$g.FillEllipse($brush, 0, 0, 20, 20)
	# up to 2 chars (e.g. "Z:")
	$txt = if ([string]::IsNullOrWhiteSpace($label)) { '!' } else { $label.Trim().ToUpper() }
	if ($txt.Length -gt 2) { $txt = $txt.Substring(0, 2) }
	$font = New-Object System.Drawing.Font($UiFontFamily, 8, $UiFontStyleBold)
	$sf = New-Object System.Drawing.StringFormat; $sf.Alignment = 'Center'; $sf.LineAlignment = 'Center'; $sf.FormatFlags = $sf.FormatFlags -bor [System.Drawing.StringFormatFlags]::NoWrap; $sf.Trimming = [System.Drawing.StringTrimming]::None
	[single]$offsetY = 6; [single]$offsetX = if ($txt.Length -eq 2) { 4 } else { 3 }; [single]$height = [Math]::Max(1, 16 - $offsetY)
	$rect = New-Object System.Drawing.RectangleF([single]$offsetX, [single]$offsetY, 16, [single]$height)
	$g.DrawString($txt, $font, [System.Drawing.Brushes]::White, $rect, $sf)
	# Create HICON, clone the Icon to detach from the HICON, then destroy HICON
	$icon = $null; $hicon = [IntPtr]::Zero
	try { $hicon = $bmp.GetHicon(); $icoTmp = [System.Drawing.Icon]::FromHandle($hicon); $icon = [System.Drawing.Icon]$icoTmp.Clone(); $icoTmp.Dispose() }
	finally { if ($hicon -ne [IntPtr]::Zero) { [void][Nc.Win32]::DestroyIcon($hicon) }; $g.Dispose(); $brush.Dispose(); $font.Dispose(); $sf.Dispose(); $bmp.Dispose() }
	return $icon
}
function Rebuild-Icons {
	try { if ($script:icoRed) { $script:icoRed.Dispose() } } catch {}; try { if ($script:icoGre) { $script:icoGre.Dispose() } } catch {}; try { if ($script:icoWarn) { $script:icoWarn.Dispose() } } catch {}
#	We want the drive letter AND the ':' (e.g. Z:)
#	$label = if ((-not [string]::IsNullOrWhiteSpace($State.Drive)) -and ($State.Drive -match '^[A-Za-z]:$')) { $State.Drive.Substring(0, 1) } else { '!' }
	$label = if ((-not [string]::IsNullOrWhiteSpace($State.Drive)) -and ($State.Drive -match '^[A-Za-z]:$')) { $State.Drive.Substring(0, 2) } else { '!' }
	$script:icoWarn = New-StatusIcon '!' ([System.Drawing.Color]::Goldenrod); $script:icoRed = New-StatusIcon $label ([System.Drawing.Color]::Tomato); $script:icoGre = New-StatusIcon $label ([System.Drawing.Color]::LimeGreen)
}
# Always assign a clone to the PictureBox to avoid disposing shared/global bitmaps.
function Set-PictureImageSafe([System.Windows.Forms.PictureBox]$pb, [System.Drawing.Image]$img) { try { if (-not $pb) { return }; if ($null -eq $img) { $pb.Image = $null; return }; $null = $img.Width; $pb.Image = $img.Clone() } catch { try { $pb.Image = $null } catch {} } }
# Dispose current clone and clear the PictureBox
function Clear-PictureImage([System.Windows.Forms.PictureBox]$pb) { try { if ($pb -and $pb.Image) { $pb.Image.Dispose(); $pb.Image = $null } } catch {} }
function Get-HttpImage([string]$url, [string]$user = $null, [string]$pass = $null, [int]$timeoutMs = 3000, [string]$accept = 'image/*') {
	try {
		try { [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12 } catch {}
		$req = [System.Net.HttpWebRequest]::Create($url)
		$req.Method = 'GET'
		$req.UserAgent = "ernolfs $AppName v$Version"
		$req.Timeout = $timeoutMs
		$req.ReadWriteTimeout = $timeoutMs
		$req.AllowAutoRedirect = $true
		$req.Accept = $accept
		if ($user -and $pass) { $pair = [System.Text.Encoding]::ASCII.GetBytes("$user`:$pass"); $req.Headers['Authorization'] = 'Basic ' + [Convert]::ToBase64String($pair) }
		$resp = $req.GetResponse()
		try {
			$stream = $resp.GetResponseStream()
			$img = [System.Drawing.Image]::FromStream($stream) # handles PNG/ICO/JPG
			$bmpOut = New-Object System.Drawing.Bitmap $img # clone so we can dispose $img
			$img.Dispose()
			return $bmpOut
		} finally { $resp.Close() }
	} catch { return $null }
}
function Fetch-ServerFavicon([string]$server) {
	# Downloads the raw .ico (multi-size) and persists it; also provides a Bitmap for UI preview.
	if ([string]::IsNullOrWhiteSpace($server)) { return $null }
	$url = "https://$server/index.php/apps/theming/favicon/core"
	$icoPath = Get-FavIconFilePath
	try {
		try { [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12 } catch {}
		$req = [System.Net.HttpWebRequest]::Create($url)
		$req.Method = 'GET'
		$req.UserAgent = "ernolfs $AppName v$Version"
		$req.Timeout = 3000
		$req.ReadWriteTimeout = 3000
		$req.AllowAutoRedirect = $true
		$req.Accept = 'image/x-icon, image/*'
		$resp = $req.GetResponse()
		try {
			$ms = New-Object System.IO.MemoryStream
			try {
				$resp.GetResponseStream().CopyTo($ms)
				$bytes = $ms.ToArray()
				# ICO file magic: 00 00 01 00
				$isIco = ($bytes.Length -ge 4 -and $bytes[0] -eq 0 -and $bytes[1] -eq 0 -and $bytes[2] -eq 1 -and $bytes[3] -eq 0)
				# Persist original ICO for Explorer drive branding
				$dir = [System.IO.Path]::GetDirectoryName($icoPath)
				if (-not (Test-Path $dir)) { New-Item -ItemType Directory -Path $dir -Force | Out-Null }
				if ($isIco) {
					[System.IO.File]::WriteAllBytes($icoPath, $bytes)
					# Build a Bitmap for UI preview (PictureBox) from the saved .ico
					$fs = [System.IO.File]::OpenRead($icoPath)
					try { $ico = New-Object System.Drawing.Icon($fs); $bmp = $ico.ToBitmap(); $ico.Dispose() } finally { $fs.Dispose() }
					if ($script:ServerFaviconBmp) { try { $script:ServerFaviconBmp.Dispose() } catch {} }
					$script:ServerFaviconBmp = $bmp
					return $bmp
				} else {
					# Fallback: interpret as an image stream and convert to bitmap (single size)
					$ms.Position = 0
					$img = [System.Drawing.Image]::FromStream($ms)
					$bmp = New-Object System.Drawing.Bitmap $img
					$img.Dispose()
					if ($script:ServerFaviconBmp) { try { $script:ServerFaviconBmp.Dispose() } catch {} }
					$script:ServerFaviconBmp = $bmp
					# Also save a single-size .ico (better than nothing)
					try { Save-IconFromBitmap $bmp $icoPath | Out-Null } catch {}
					return $bmp
				}
			} finally { $ms.Dispose() }
		} finally { $resp.Close() }
	} catch { return $null }
}
function Fetch-UserAvatar([string]$server, [string]$user) {
	if ([string]::IsNullOrWhiteSpace($server) -or [string]::IsNullOrWhiteSpace($user)) { return $null }
	$base = "https://$server/index.php/avatar/$user/64?guestFallback = 1"
	$bmp = Get-HttpImage -url $base -timeoutMs 3000
	if ($bmp) { if ($script:UserAvatarBmp) { try { $script:UserAvatarBmp.Dispose() } catch {} }; $script:UserAvatarBmp = $bmp }
	return $bmp
}
function Save-IconFromBitmap([System.Drawing.Bitmap]$bmp, [string]$icoPath) {
	if (-not $bmp -or [string]::IsNullOrWhiteSpace($icoPath)) { return $false }
	try {
		$hicon = $bmp.GetHicon(); $icoTmp = [System.Drawing.Icon]::FromHandle($hicon)
		try { $fs = [System.IO.File]::Open($icoPath, [System.IO.FileMode]::Create, [System.IO.FileAccess]::Write, [System.IO.FileShare]::Read); try { $icoTmp.Save($fs) } finally { $fs.Close() } }
		# Dispose wrapper and destroy HICON to avoid leaks
		finally { $icoTmp.Dispose(); if ($hicon -ne [IntPtr]::Zero) { [void][Nc.Win32]::DestroyIcon($hicon) } }
		return $true
	} catch { return $false }
}
# Decode base64 -> Image -> Bitmap; optional: force 32bpp PArgb for safer UI drawing
function Get-EmbeddedImage([string]$Base64, [switch]$ForcePArgb) {
	if ([string]::IsNullOrWhiteSpace($Base64)) { return $null }
	try {
		$bytes = [Convert]::FromBase64String($Base64)
		$ms = New-Object System.IO.MemoryStream(, $bytes)
		$img = [System.Drawing.Image]::FromStream($ms)
		if ($ForcePArgb) {
			$bmp = New-Object System.Drawing.Bitmap -ArgumentList $img.Width, $img.Height, ([System.Drawing.Imaging.PixelFormat]::Format32bppPArgb)
			$g = [System.Drawing.Graphics]::FromImage($bmp); $g.DrawImage($img, 0, 0, $img.Width, $img.Height); $g.Dispose()
		} else { $bmp = New-Object System.Drawing.Bitmap $img }
		$img.Dispose(); $ms.Dispose()
		return $bmp
	} catch { return $null }
}
# Path for persisted drive icon (.ico) derived from favicon
function Get-FavIconFilePath { return (Join-Path $HereDir 'server_favicon.ico') }
# Shows a small custom balloon near the mouse cursor (no dependencies).
function Show-CustomBalloon([string]$Title, [string]$Text, [int]$TimeoutMs = 2200) {
	Add-Type -AssemblyName System.Windows.Forms; Add-Type -AssemblyName System.Drawing
	# --- normalize inputs to strings (avoid Object[] math) ---
	if ($Title -is [array]) { $Title = ($Title -join ' ') }; if ($Text -is [array]) { $Text = ($Text -join "`n") }
	# close any previous balloon
	try {
		if ($script:BalloonTimer) { $script:BalloonTimer.Stop(); $script:BalloonTimer.Dispose(); $script:BalloonTimer = $null }
		if ($script:BalloonForm -and -not $script:BalloonForm.IsDisposed) { $script:BalloonForm.Close(); $script:BalloonForm.Dispose() }
	} catch {}
	[System.Drawing.Image]$IconImage = Get-EmbeddedImage -Base64 $Logo96B64
	$script:BalloonForm = $null
	# --- layout (larger) ---
	$pad = 12; $iconSz = 96; $gap = 8
	$fontTitle = New-Object System.Drawing.Font($UiFontFamily, 12, $UiFontStyleBold); $fontText = New-Object System.Drawing.Font($UiFontFamily, 8, $UiFontStyleBold) #[System.Drawing.FontStyle]::Regular)
	$fmt = [System.Windows.Forms.TextFormatFlags]::WordBreak -bor [System.Windows.Forms.TextFormatFlags]::NoPadding
	$maxTextWidth = 520
	# Measure using TextRenderer (more faithful to WinForms than Graphics.MeasureString)
	$szTitle = [System.Windows.Forms.TextRenderer]::MeasureText($Title, $fontTitle)
	$szText = [System.Windows.Forms.TextRenderer]::MeasureText($Text, $fontText, (New-Object System.Drawing.Size($maxTextWidth, 9999)), $fmt)
	$wText = [Math]::Max($szTitle.Width, $szText.Width); $wIcon = if ($IconImage) { $iconSz + $pad } else { 0 }
	$w = [int]($pad + $wIcon + $wText + $pad); $h = [int]($pad + [Math]::Max($iconSz, $szTitle.Height + $gap + $szText.Height) + $pad)
	# enforce bigger popup footprint when icon is large
	if ($w -lt ( $pad + $iconSz + 160 )) { $w = $pad + $iconSz + 160 }; if ($h -lt ( $pad + $iconSz + $pad )) { $h = $pad + $iconSz + $pad }
	# --- form ---
	$f = New-Object System.Windows.Forms.Form; $f.FormBorderStyle = 'None'; $f.StartPosition = 'Manual'; $f.TopMost = $true; $f.ShowInTaskbar = $false; $f.BackColor = [System.Drawing.Color]::FromArgb(250, 250, 250); $f.Size = New-Object System.Drawing.Size($w, $h)
	# allow ESC to close the balloon
	$f.KeyPreview = $true
	$f.Add_KeyDown(({ param($s, $e) if ($e.KeyCode -eq 'Escape') { try { $myForm.Close() } catch {} } }).GetNewClosure())
	# Rounded region (safe: keep path in Tag so it's alive during Paint)
	$path = New-Object System.Drawing.Drawing2D.GraphicsPath; $radius = 10; $rect = New-Object System.Drawing.Rectangle(0, 0, $w, $h)
	$path.AddArc(0, 0, $radius, $radius, 180, 90); $path.AddArc($w-$radius, 0, $radius, $radius, 270, 90); $path.AddArc($w-$radius, $h-$radius, $radius, $radius, 0, 90); $path.AddArc(0, $h-$radius, $radius, $radius, 90, 90); $path.CloseFigure()
	$f.Region = New-Object System.Drawing.Region($path)
	# Keep resources on form to avoid GC while painting
	$f.Tag = @{ Path = $path; FontTitle = $fontTitle; FontText = $fontText; IconImage = $IconImage; Padding = $pad; IconSz = $iconSz; Gap = $gap; Title = $Title; Text = $Text; Fmt = $fmt }
	# Paint
	$f.Add_Paint({
		param($s, $e)
		$g = $e.Graphics; $g.SmoothingMode = [System.Drawing.Drawing2D.SmoothingMode]::AntiAlias
		$t = $s.Tag; if (-not $t) { return }
		# hard-cast everything used in arithmetic to int
		$wClient = [int]$s.ClientSize.Width; $hClient = [int]$s.ClientSize.Height
		$pad = [int]$t.Padding; $iconSz = [int]$t.IconSz; $gap = [int]$t.Gap; $x = [int]$pad; $y = [int]$pad
		# soft border shadow
		$shadow = New-Object System.Drawing.Pen([System.Drawing.Color]::FromArgb(40, 0, 0, 0), 1)
		if ($t.Path -and $t.Path.PointCount -gt 0) { $g.DrawPath($shadow, $t.Path) }
		$shadow.Dispose()
		$x = $t.Padding; $y = $t.Padding
		if ($t.IconImage) { try { $g.DrawImage($t.IconImage, $x, $y, $iconSz, $iconSz) } catch {}; $x = [int]($x + $iconSz + $pad) }
		[System.Windows.Forms.TextRenderer]::DrawText($g, $t.Title, $t.FontTitle, [System.Drawing.Point]::new($x, $y), [System.Drawing.Color]::Black)
		$y = [int]($y + [int][Math]::Ceiling($t.FontTitle.GetHeight($g)) + $gap)
		# Wrap text inside remaining width
		$remainW = [int]($wClient - $x - $pad)
		[System.Windows.Forms.TextRenderer]::DrawText( $g, $t.Text, $t.FontText, (New-Object System.Drawing.Rectangle($x, [int]$y, [int]$remainW, $s.ClientSize.Height)), [System.Drawing.Color]::DimGray, $t.Fmt )
		# tiny 'Click to close' hint
		$hint = 'Click to close'; $hintFont = New-Object System.Drawing.Font($UiFontFamily, 7, [System.Drawing.FontStyle]::Regular)
		$szHint = [System.Windows.Forms.TextRenderer]::MeasureText($hint, $hintFont)
		$hx = [int]($wClient - $pad - [int]$szHint.Width); $hy = [int]($hClient - $pad - [int]$szHint.Height)
		[System.Windows.Forms.TextRenderer]::DrawText($g, $hint, $hintFont, (New-Object System.Drawing.Point($hx, $hy)), [System.Drawing.Color]::Gray)
		$hintFont.Dispose()
	})
	# Balloon as Chrome-Style Toast:
	$screen = [System.Windows.Forms.Screen]::PrimaryScreen.WorkingArea
	$posX = $screen.Right - $w - 10; $posY = $screen.Bottom - $h - 10
	$f.Location = New-Object System.Drawing.Point($posX, $posY); $f.Location = New-Object System.Drawing.Point($posX, $posY)
	# Close on click / mousedown / ESC (sender-based, no $myForm, no GetNewClosure)
	$f.Add_Click({ param($s, $e) try { $s.Close() } catch {} }); $f.Add_MouseDown({ param($s, $e) try { $s.Close() } catch {} }); $f.KeyPreview = $true; $f.Add_KeyDown({ param($s, $e) if ($e.KeyCode -eq 'Escape') { try { $s.Close() } catch {} } })
	# Auto-close via WinForms timer (UI-thread; safe with message pump)
	$t = New-Object System.Windows.Forms.Timer; $t.Interval = [Math]::Max(500, $TimeoutMs)
	# freeze locals for this instance (avoid capturing $f/$t by reference)
	$myForm = $f; $myTimer = $t
	$t.Add_Tick(({ try { $myTimer.Stop(); $myTimer.Dispose() } catch {}; try { if ($myForm -and -not $myForm.IsDisposed) { $myForm.Close() } } catch {} }).GetNewClosure())
	$script:BalloonTimer = $t; $script:BalloonForm = $f
	# Dispose resources when form closes
	$f.Add_FormClosed(({
		try { if ($myTimer) { $myTimer.Stop(); $myTimer.Dispose() } } catch {}
		try { if ($myForm.Tag) { if ($myForm.Tag.Path) { $myForm.Tag.Path.Dispose(); $myForm.Tag.Path = $null }; if ($myForm.Tag.FontTitle) { $myForm.Tag.FontTitle.Dispose(); $myForm.Tag.FontTitle = $null }; if ($myForm.Tag.FontText) { $myForm.Tag.FontText.Dispose(); $myForm.Tag.FontText = $null }; if ($myForm.Tag.IconImage) { $myForm.Tag.IconImage.Dispose(); $myForm.Tag.IconImage = $null } } } catch {}
		try { $myForm.Dispose() } catch {}
		# reset globals only if they still point to THIS instance
		try { if ($script:BalloonForm -eq $myForm) { $script:BalloonForm = $null }; if ($script:BalloonTimer -eq $myTimer) { $script:BalloonTimer = $null } } catch {}
	}).GetNewClosure())
	try { $t.Start() } catch {}; $f.Add_Shown({ param($s, $e); try { $s.Invalidate() } catch {} }); $f.Show(); try { $f.Activate(); $f.BringToFront(); [void]$f.Focus() } catch {}
}

# ================================================================
#	Mode & tray updates (needs-setup, immediate refresh)
# ================================================================
# ---------- Mode / Setup helpers ----------
function Refresh-NeedsSetup {
	$ba0 = $false
	try { if (Test-Path $RegWebClient) { $p = Get-ItemProperty -Path $RegWebClient -ErrorAction SilentlyContinue; if ($p -and ($p.PSObject.Properties.Name -contains 'BasicAuthLevel')) { $ba0 = ([int]$p.BasicAuthLevel -eq 0) } } } catch {}
	$script:NeedsSetup = ( [string]::IsNullOrWhiteSpace($State.Server) -or [string]::IsNullOrWhiteSpace($State.User) -or -not (Test-ValidDrive $State.Drive) -or $ba0 )
}
function Update-TrayImmediate([switch]$TryMap) {
	try {
		# paused?
		if ($script:Paused) { $script:tray.Icon = $script:icoRed; $varsPaused = @{ app = $AppName; drive = $State.Drive }; $script:tray.Text = T 'tray.paused' $varsPaused; return }
		# needs initial setup?
		if ($script:NeedsSetup) { $script:tray.Icon = $script:icoWarn; $varsNS = @{ app = $AppName }; $script:tray.Text = T 'tray.needs_setup' $varsNS; return }
		# check server state (reachable / maintenance)
		$st = Get-NcServerStatus
		if (-not $st.Reachable) { if (Test-ValidDrive $State.Drive) { Unmap-DriveIfOurs -Force -RemoveProfile }; $script:tray.Icon = $script:icoRed; $varsOff = @{ app = $AppName }; $script:tray.Text = T 'tray.offline' $varsOff; return }
		if ($st.Maintenance) { if (Test-ValidDrive $State.Drive) { Unmap-DriveIfOurs -Force -RemoveProfile }; $script:tray.Icon = $script:icoRed; $varsMaint = @{ app = $AppName }; $script:tray.Text = T 'tray.maintenance' $varsMaint; return }
		# try to ensure mapped / update tray text
		if (Test-DriveAccessible) { try { Rebuild-Icons } catch {}; $script:tray.Icon = $script:icoGre; $varsOn = @{ app = $AppName; drive = $State.Drive }; $script:tray.Text = T 'tray.online' $varsOn; try { Ensure-BrandingTick } catch {} }
		# try remap now
		elseif ($TryMap) { Unmap-DriveIfOurs; if (Map-Drive) { try { Rebuild-Icons } catch {}; $script:tray.Icon = $script:icoGre; $varsOn2 = @{ app = $AppName; drive = $State.Drive }; $script:tray.Text = T 'tray.online' $varsOn2; try { Ensure-BrandingTick } catch {} } else { $script:tray.Icon = $script:icoRed; $varsFail = @{ app = $AppName }; $script:tray.Text = T 'tray.mapping_failed' $varsFail } }
		# not accessible and no TryMap -> treat as offline
		else { $script:tray.Icon = $script:icoRed; $varsDisc = @{ app = $AppName }; $script:tray.Text = T 'tray.offline' $varsDisc }
	} catch {
		# any unexpected error -> generic tray.error
		$script:tray.Icon = $script:icoRed; $varsErr = @{ app = $AppName }; $script:tray.Text = T 'tray.error' $varsErr
	}
}
function Refresh-ShellIcons { try { [Nc.Shell]::SHChangeNotify(0x08000000, 0, [IntPtr]::Zero, [IntPtr]::Zero) } catch {} }
function Set-TrayState([string]$Text = $null, $Icon = $null) { if (-not $script:tray) { return } <# no tray yet #>; if ($Icon) { $script:tray.Icon = $Icon }; if ($Text) { $script:tray.Text = $Text } }

# ================================================================
#	Settings dialog
# ================================================================
function Show-SettingsDialog {
	# Guard: prevent multiple settings windows
	if ($script:IsSettingsOpen -and $script:SettingsForm -and (-not $script:SettingsForm.IsDisposed)) {
		try { $script:SettingsForm.WindowState = [System.Windows.Forms.FormWindowState]::Normal; $script:SettingsForm.Activate(); $script:SettingsForm.BringToFront() } catch {}
		return [System.Windows.Forms.DialogResult]::Cancel
	}
	# global tooltip (single instance, reused everywhere)
	$script:Tip = New-Object System.Windows.Forms.ToolTip
	# Small tooltip helper (shared for all controls)
#	$script:Tip.AutoPopDelay = 8000 # how long the tooltip stays visible (ms)
	$script:Tip.InitialDelay = 300 # delay before first show (ms)
	$script:Tip.ReshowDelay = 100 # delay for subsequent shows (ms)
	$script:Tip.ShowAlways = $true # also show for disabled controls
	# Mark as open early
	$script:IsSettingsOpen = $true
	# Create host form (chrome only)
	$f = $script:HostForm = New-Object System.Windows.Forms.Form; Apply-BrandIconToForm $f; Hook-FormDpi $f
	$f.Text = (T 'title.settings_dialog' @{ app = $AppName }); $f.ShowInTaskbar = $false; $f.TopMost = $true; $f.FormBorderStyle = [System.Windows.Forms.FormBorderStyle]::FixedDialog
	$f.MaximizeBox = $false; $f.MinimizeBox = $false
	$f.Width = 680 # 620
	$f.Height = 520 # 480
	$f.StartPosition = [System.Windows.Forms.FormStartPosition]::CenterScreen
	# --- TabControl host (chrome stays on $f) ---
	$script:Tabs = New-Object System.Windows.Forms.TabControl
	$script:Tabs.Left = 8; $script:Tabs.Top = 8; $script:Tabs.Width = $f.ClientSize.Width - 16; $script:Tabs.Height = $f.ClientSize.Height - 16; $script:Tabs.Anchor = 'Top, Left, Right, Bottom'
	$script:Tabs.Appearance = 'Buttons' # 'Normal' | 'Buttons' | 'FlatButtons'
	$script:Tabs.HotTrack = $true; $script:Tabs.TabStop = $false # keep focus inside the active TabPage
	# Tab: Basic
	$tabBasic = $script:TabBasic = New-Object System.Windows.Forms.TabPage; $tabBasic.Text = (T 'tab.basic_settings'); $tabBasic.Padding = '6, 6, 6, 6'
	# Tab: WebClient Tuning
	$tabTuning = $script:TabTuning = New-Object System.Windows.Forms.TabPage; $tabTuning.Text = (T 'tab.webclient_tuning'); $tabTuning.Padding = '6, 6, 6, 6'
	# Tab: WebDAV cache cleanup (on-demand admin cleaner)
	$tabCache = $script:TabCache = New-Object System.Windows.Forms.TabPage; $tabCache.Text = (T 'tab.webdav_cache'); $tabCache.Padding = '6, 6, 6, 6'
	[void]$script:Tabs.TabPages.Add($tabBasic); [void]$script:Tabs.TabPages.Add($tabTuning); [void]$script:Tabs.TabPages.Add($tabCache)
	$f.Controls.Add($script:Tabs)
	# Render content into each tab page (container ! = HostForm)
	Render-BasicSettingsTab -HostTab $tabBasic; Render-WebClientTuningTab -HostTab $tabTuning; Render-WebDavCacheTab -HostTab $tabCache
	# Track the window and show
	$script:SettingsForm = $f
	$dlg = $f.ShowDialog()
	# Reset open flag on close
	$script:IsSettingsOpen = $false
	return $dlg
}
function Render-BasicSettingsTab([System.Windows.Forms.Control] $HostTab = $null) {
	# Use provided host form (container owns chrome)
	$f = $script:HostForm
	# Choose the container for controls
	$c = if ($HostTab -ne $null) { $HostTab } else { $f }
	$panelMain = New-Object Windows.Forms.Panel; $panelMain.Dock = 'Fill'
	$panelFooter = New-Object Windows.Forms.Panel; $panelFooter.Dock = 'Bottom'; $panelFooter.Height = $script:ButtonXH
	$panelMain.TabIndex = 0; $panelFooter.TabIndex = 1 # Explicit tab order between sibling containers
	$c.Controls.AddRange(@( $panelFooter, $panelMain ))
	# Ensure state has LangPref (safe read/write)
	if (-not ($State.PSObject.Properties.Name -contains 'LangPref')) { Add-Member -InputObject $State -MemberType NoteProperty -Name 'LangPref' -Value '' -Force }
	# Mode badge
	$script:LabelMode = New-Object System.Windows.Forms.Label
	if ($PortableMode) { $script:LabelMode.Text = (T 'mode.portable'); $script:LabelMode.ForeColor = [System.Drawing.Color]::ForestGreen; $script:LabelMode.Font = New-Object System.Drawing.Font($UiFontFamily, 10, $UiFontStyleBold) }
	else { $script:LabelMode.Text = (T 'mode.installed'); $script:LabelMode.ForeColor = [System.Drawing.Color]::SteelBlue; $script:LabelMode.Font = New-Object System.Drawing.Font($UiFontFamily, 9, $UiFontStyleBold) }
	$script:LabelMode.AutoSize = $true; $script:LabelMode.Left = 12; $script:LabelMode.Top = 10
	$script:LabelServer = New-Object Windows.Forms.Label; $script:LabelServer.Text = (T 'label.server'); $script:LabelServer.Left = 12; $script:LabelServer.Top = 40; $script:LabelServer.AutoSize = $true
	$script:TextServer = New-Object Windows.Forms.TextBox; $script:TextServer.Top = 38; $script:TextServer.Width = 400; $script:TextServer.Left = $panelMain.ClientSize.Width - $script:TextServer.Width - 2; $script:TextServer.Text = $State.Server; $script:TextServer.Anchor = 'Top, Right'
	$script:LabelUser = New-Object Windows.Forms.Label; $script:LabelUser.Text = (T 'label.user'); $script:LabelUser.Left = 12; $script:LabelUser.Top = 70; $script:LabelUser.AutoSize = $true
	$script:TextUser = New-Object Windows.Forms.TextBox; $script:TextUser.Top = 68; $script:TextUser.Width = $script:TextServer.Width; $script:TextUser.Left = $script:TextServer.Left; $script:TextUser.Text = $State.User; $script:TextUser.Anchor = 'Top, Right'
	# Small images next to Server/User
	$script:PicFavicon = New-Object System.Windows.Forms.PictureBox; $script:PicFavicon.Width = 24; $script:PicFavicon.Height = 24; $script:PicFavicon.SizeMode = 'Zoom'; $script:PicFavicon.Left = $script:TextServer.Left - 28; $script:PicFavicon.Top = $script:TextServer.Top - 2; $script:PicFavicon.Anchor = 'Top, Right'
	$script:PicAvatar = New-Object System.Windows.Forms.PictureBox; $script:PicAvatar.Width = 24; $script:PicAvatar.Height = 24; $script:PicAvatar.SizeMode = 'Zoom'; $script:PicAvatar.Left = $script:PicFavicon.Left; $script:PicAvatar.Top = $script:TextUser.Top - 2; $script:PicAvatar.Anchor = 'Top, Right'
	# FaviconTimer tick
	if (-not $script:FaviconTimer) { $script:FaviconTimer = New-Object System.Windows.Forms.Timer; $script:FaviconTimer.Interval = 500 }
	$script:FaviconTimer.add_Tick({
		$script:FaviconTimer.Stop()
		# reset favicon cache before fetch
		$script:ServerFaviconBmp = $null
		$srv = $script:TextServer.Text.Trim()
		if ([string]::IsNullOrWhiteSpace($srv)) { Clear-PictureImage $script:PicFavicon; return }
		$null = Fetch-ServerFavicon ($srv)
		if ($script:ServerFaviconBmp) { Set-PictureImageSafe $script:PicFavicon $script:ServerFaviconBmp } else { Clear-PictureImage $script:PicFavicon }
	})
	# AvatarTimer tick
	if (-not $script:AvatarTimer) { $script:AvatarTimer = New-Object System.Windows.Forms.Timer; $script:AvatarTimer.Interval = 500 }
	$script:AvatarTimer.add_Tick({
		$script:AvatarTimer.Stop()
		# reset avatar cache before fetch
		$script:UserAvatarBmp = $null
		$srv = $script:TextServer.Text.Trim()
		$usr = $script:TextUser.Text.Trim()
		if ([string]::IsNullOrWhiteSpace($srv) -or [string]::IsNullOrWhiteSpace($usr)) { Clear-PictureImage $script:PicAvatar; return }
		$null = Fetch-UserAvatar ($srv) ($usr)
		if ($script:UserAvatarBmp) { Set-PictureImageSafe $script:PicAvatar $script:UserAvatarBmp } else { Clear-PictureImage $script:PicAvatar }
	})
	# debounce timer for active scope / Nextcloud check
	if (-not $script:ServerScopeTimer) {
		$script:ServerScopeTimer = New-Object System.Windows.Forms.Timer; $script:ServerScopeTimer.Interval = 2000
		$script:ServerScopeTimer.add_Tick({
			$script:ServerScopeTimer.Stop()
			if ($script:LabelActiveScope -and $script:UpdateActiveScopeLabel) { try { & $script:UpdateActiveScopeLabel $script:LabelActiveScope } catch {} }
		})
	}
	# TextServer TextChanged handler
	$script:TextServer.add_TextChanged({
		# reset favicon/avatar caches
		$script:ServerFaviconBmp = $null; $script:UserAvatarBmp = $null
		# favicon debounce
		Clear-PictureImage $script:PicFavicon; $script:FaviconTimer.Stop()
		if (-not [string]::IsNullOrWhiteSpace($script:TextServer.Text)) { $script:FaviconTimer.Start() }
		# avatar debounce
		Clear-PictureImage $script:PicAvatar; $script:AvatarTimer.Stop()
		if (-not [string]::IsNullOrWhiteSpace($script:TextServer.Text) -and -not [string]::IsNullOrWhiteSpace($script:TextUser.Text)) { $script:AvatarTimer.Start() }
		# auto display name update (only if user did not customize)
		$newDefault = (& $script:ComputeDefaultLabel $script:TxtSub.Text $script:TextUser.Text.Trim() $script:TextServer.Text.Trim())
		if ([string]::IsNullOrWhiteSpace($script:TxtDisp.Text) -or ($script:TxtDisp.Text -eq $script:BasicSettings_Auto.LastAuto)) { $script:TxtDisp.Text = $newDefault; $script:BasicSettings_Auto.LastAuto = $newDefault }
		# debounce active scope / Nextcloud check (avoid request on every keystroke)
		if ($script:LabelActiveScope -and $script:UpdateActiveScopeLabel -and $script:ServerScopeTimer) { $script:ServerScopeTimer.Stop(); $script:ServerScopeTimer.Start() }
		& $script:UpdateSaveButton
	})
	# TextUser TextChanged handler
	$script:TextUser.add_TextChanged({
		# reset avatar cache on user edit
		$script:UserAvatarBmp = $null
		Clear-PictureImage $script:PicAvatar; $script:AvatarTimer.Stop()
		if (-not [string]::IsNullOrWhiteSpace($script:TextServer.Text) -and -not [string]::IsNullOrWhiteSpace($script:TextUser.Text)) { $script:AvatarTimer.Start() }
		& $script:UpdateSaveButton
	})
	# Initial favicon fetch + assign
	if ([string]::IsNullOrWhiteSpace($script:TextServer.Text)) { Clear-PictureImage $script:PicFavicon }
	else { $null = Fetch-ServerFavicon ($script:TextServer.Text.Trim()); if ($script:ServerFaviconBmp) { Set-PictureImageSafe $script:PicFavicon $script:ServerFaviconBmp } else { Clear-PictureImage $script:PicFavicon } }
	# Initial avatar fetch + assign
	if ([string]::IsNullOrWhiteSpace($script:TextServer.Text) -or [string]::IsNullOrWhiteSpace($script:TextUser.Text)) { Clear-PictureImage $script:PicAvatar }
	else { $null = Fetch-UserAvatar ($script:TextServer.Text.Trim()) ($script:TextUser.Text.Trim()); if ($script:UserAvatarBmp) { Set-PictureImageSafe $script:PicAvatar $script:UserAvatarBmp } else { Clear-PictureImage $script:PicAvatar } }
	# Password
	$script:LabelPassword = New-Object Windows.Forms.Label; $script:LabelPassword.Text = T 'app_password'; $script:LabelPassword.Left = 12; $script:LabelPassword.Top = 100; $script:LabelPassword.AutoSize = $true
	# Small "?" help button next to the password box
	$script:ButtonPasswordHelp = New-Object Windows.Forms.Button; $script:ButtonPasswordHelp.Text = '?'; $script:ButtonPasswordHelp.Width = 28; $script:ButtonPasswordHelp.Left = $script:PicFavicon.Left - 2; $script:ButtonPasswordHelp.Top = 94; $script:ButtonPasswordHelp.Height = $script:ButtonH; $script:ButtonPasswordHelp.Anchor = 'Top, Right'
	# Encrypt button (right of password TextBox)
	$script:ButtonEncrypt = New-Object Windows.Forms.Button; $script:ButtonEncrypt.Top = $script:LabelPassword.Top - 6; $script:ButtonEncrypt.Text = (T 'button.encrypt'); $script:ButtonEncrypt.Width = 100; $script:ButtonEncrypt.Left = $panelMain.ClientSize.Width - $script:ButtonEncrypt.Width -2; $script:ButtonEncrypt.Height = $script:ButtonH; $script:ButtonEncrypt.Anchor = 'Top, Right'
	$script:TextPassword = New-Object Windows.Forms.TextBox; $script:TextPassword.Top = $script:LabelPassword.Top - 2; $script:TextPassword.Left = $script:TextServer.Left; $script:TextPassword.Width = $script:ButtonEncrypt.Left - $script:TextPassword.Left - 10; $script:TextPassword.UseSystemPasswordChar = $true; $script:TextPassword.Anchor = 'Top, Right'
	# Click handler: builds URL from current Server field or falls back
	# capture once, so the handler will later have stable references.
	# Store both: textbox + app name
	$script:ButtonPasswordHelp.Tag = @{ tb = $script:TextServer; app = $AppName }
	$script:ButtonPasswordHelp.Add_Click(({
		param($sender, $args)
		$tb = $sender.Tag.tb
		$app = [string]$sender.Tag.app
		$raw = if ($tb) { $tb.Text } else { '' }
		$host = '<cloud.example.com>'
		if (-not [string]::IsNullOrWhiteSpace($raw)) { $h = $raw.Trim(); if ($h -match '^\s*https?://') { try { $u = [Uri]$h; $h = $u.Host } catch {} }; $h = $h.Trim('/').Trim(); if (-not [string]::IsNullOrWhiteSpace($h)) { $host = $h } }
		$url = "https://$host/index.php/settings/user/security"
		[void](Show-HelpT -TitleKey 'title.app_password_help' -TitleVars @{ app = $app } -BodyKey 'message.app_password_help' -BodyVars @{ url = $url; app = $app } -Url $url -Width 640 -Height 320 -Parent $script:HostForm)
	}).GetNewClosure())
	# Subfolder (read-only -> only selection via picker)
	$script:LabelSubfolder = New-Object Windows.Forms.Label; $script:LabelSubfolder.Text = (T 'label.subfolder'); $script:LabelSubfolder.Left = 12; $script:LabelSubfolder.Top = 130; $script:LabelSubfolder.AutoSize = $true
	$script:TxtSub = New-Object Windows.Forms.TextBox; $script:TxtSub.Top = 128; $script:TxtSub.Width = $script:TextServer.Width; $script:TxtSub.Left = $script:TextServer.Left; $script:TxtSub.Text = $State.SubPath; $script:TxtSub.ReadOnly = $true; $script:TxtSub.BackColor = [System.Drawing.SystemColors]::ControlLightLight; $script:TxtSub.Anchor = 'Top, Right'
	# Helper: compute default display name from subfolder/user/server
	$script:ComputeDefaultLabel = {
		param([string]$sub, [string]$user, [string]$server)
		if ($null -eq $sub) { $sub = '' }
		$subNorm = $sub.Trim('/')
		if (-not [string]::IsNullOrWhiteSpace($subNorm)) { $parts = $subNorm.Split('/'); return $parts[$parts.Length - 1] }
		# empty subfolder -> "user@server"
		$u = if ($null -ne $user) { $user.Trim() } else { '' }
		$s = if ($null -ne $server) { $server.Trim() } else { '' }
		return ("{0}@{1}" -f $u, $s)
	}
	# Shared state for auto-filled display name; using hashtable to keep reference across event scopes
	$script:BasicSettings_Auto = @{ LastAuto = $null }
	# Helper to open the subfolder picker and update txtSub / txtDisp
	$script:OpenSubfolderPicker = {
		# sync current server/user into state (so picker knows context)
		$State.Server = $script:TextServer.Text.Trim()
		$State.User = $script:TextUser.Text.Trim()
		# remember old subfolder to detect a real change
		$oldSub = $script:TxtSub.Text
		$pick = Show-NcFolderPicker
		if ($pick -ne $null) {
			$oldDefault = (& $script:ComputeDefaultLabel $oldSub $script:TextUser.Text.Trim() $script:TextServer.Text.Trim())
			$newDefault = (& $script:ComputeDefaultLabel $pick $script:TextUser.Text.Trim() $script:TextServer.Text.Trim())
			# user actually changed folder -> suggest new label
			if ($pick -ne $oldSub) { $script:TxtDisp.Text = $newDefault; $script:BasicSettings_Auto.LastAuto = $newDefault }
			# same folder -> only update label if user hasn't customized manually
			elseif ([string]::IsNullOrWhiteSpace($script:TxtDisp.Text) -or ($script:TxtDisp.Text -eq $oldDefault) -or ($script:TxtDisp.Text -eq $script:BasicSettings_Auto.LastAuto)) { $script:TxtDisp.Text = $newDefault; $script:BasicSettings_Auto.LastAuto = $newDefault }
			$script:TxtSub.Text = $pick
			& $script:UpdateSaveButton
		}
	}
	# shared browse-state flag (controls picker availability)
	$script:BrowseState = @{ CanBrowse = $false }
	# Small tooltip for disabled controls
	# Hover tooltips for Server/User/Password
	$script:Tip.SetToolTip($script:TextServer, (T 'tip.enter_server'))
	$script:Tip.SetToolTip($script:TextUser, (T 'tip.enter_user'))
	$script:Tip.SetToolTip($script:ButtonPasswordHelp, (T 'title.app_password_help'))
	# Local helper: controls state depending on encrypted password presence
	$script:RefreshPasswordState = {
		$hasEncPortable = $PortableMode -and (Test-Path $SecretPath)
		$hasEncInstalled = (-not $PortableMode) -and (-not [string]::IsNullOrEmpty($State.EncPass))
		# Decide if browsing is allowed
		$localCanBrowse = ($hasEncPortable -or $hasEncInstalled)
		# Publish new state so MouseDown/KeyDown see it immediately
		$script:BrowseState.CanBrowse = $localCanBrowse
		# Update tooltip text
		if ($localCanBrowse) { $script:Tip.SetToolTip($script:TxtSub, $null) } else { $script:Tip.SetToolTip($script:TxtSub, (T 'tip.enter_password_and_encrypt')) }
		# Toggle Encrypt/Clear UI and show info text when a secret exists
		if ($PortableMode) {
			$script:ButtonEncrypt.Text = $(if ($hasEncPortable) { (T 'button.delete_secrets') } else { (T 'button.encrypt') })
			# Show info message instead of password dots
			if ($hasEncPortable) { $msg = (T 'password.encrypted_secret'); $script:TextPassword.ReadOnly = $true; $script:TextPassword.Enabled = $true; $script:TextPassword.UseSystemPasswordChar = $false; $script:TextPassword.ForeColor = [System.Drawing.SystemColors]::GrayText; $script:TextPassword.Text = $msg; $script:TextPassword.Tag = 'info' }
			# Back to normal editable password field
			else { if ($script:TextPassword.Tag -eq 'info') { $script:TextPassword.Text = '' }; $script:TextPassword.Tag = $null; $script:TextPassword.ReadOnly = $false; $script:TextPassword.Enabled = $true; $script:TextPassword.UseSystemPasswordChar = $true; $script:TextPassword.ForeColor = [System.Drawing.SystemColors]::WindowText }
		} else {
			$script:ButtonEncrypt.Text = $(if ($hasEncInstalled) { (T 'button.clear') } else { (T 'button.encrypt') })
			if ($hasEncInstalled) { $msg = (T 'password.encrypted_dpapi'); $script:TextPassword.ReadOnly = $true; $script:TextPassword.Enabled = $true; $script:TextPassword.UseSystemPasswordChar = $false; $script:TextPassword.ForeColor = [System.Drawing.SystemColors]::GrayText; $script:TextPassword.Text = $msg; $script:TextPassword.Tag = 'info' }
			else { if ($script:TextPassword.Tag -eq 'info') { $script:TextPassword.Text = '' }; $script:TextPassword.Tag = $null; $script:TextPassword.ReadOnly = $false; $script:TextPassword.Enabled = $true; $script:TextPassword.UseSystemPasswordChar = $true; $script:TextPassword.ForeColor = [System.Drawing.SystemColors]::WindowText }
		}
		# Password tooltip (hover only when not yet stored/encrypted)
		$pwEmpty = ([string]::IsNullOrWhiteSpace($script:TextPassword.Text) -or $script:TextPassword.Tag -eq 'info')
		$needPwd = (-not $hasEncPortable -and -not $hasEncInstalled)
		if ($needPwd -and $pwEmpty) { $script:Tip.SetToolTip($script:TextPassword, (T 'app_password')) } else { $script:Tip.SetToolTip($script:TextPassword, $null) }
	}
	# Clicking the readonly path box
	$script:TxtSub.add_MouseDown({
		# open picker directly
		if ($script:BrowseState.CanBrowse) { try { & $script:OpenSubfolderPicker } catch {} }
		# show enforced tooltip popup near the box for ~4s
		else { try { $msg = (T 'tip.enter_password_and_encrypt'); $script:Tip.Show($msg, $script:TxtSub, 0, $script:TxtSub.Height + 2, 4000) } catch {} }
		# move focus away so txtSub does not look "active"
		try { $script:ButtonEncrypt.Focus() } catch {}
	})
	# keyboard interaction in the readonly path box
	$script:TxtSub.add_KeyDown({
		param($sender, $e)
		# prevent the default "ding" sound from read-only TextBox
		$e.SuppressKeyPress = $true
		if ($script:BrowseState.CanBrowse) { try { & $script:OpenSubfolderPicker } catch {} }
		else { try { $msg = (T 'tip.enter_password_and_encrypt'); $script:Tip.Show($msg, $script:TxtSub, 0, $script:TxtSub.Height + 2, 4000) } catch {} }
		try { $script:ButtonEncrypt.Focus() } catch {}
	})
	# Encrypt/Clear toggle
	$script:ButtonEncrypt.Add_Click({
		if ($PortableMode) {
			# PORTABLE MODE: toggle between Encrypt and Delete secrets
			if (Test-Path $SecretPath) {
				# Delete secrets.dat
				if ((Ask-YesNoQuestT 'prompt.secrets_delete_confirm') -ne [System.Windows.Forms.DialogResult]::Yes) { return }
				try { Remove-Item -LiteralPath $SecretPath -Force } catch {}
				$script:PlainPassCache = $null; $script:AskedPassphrase = $false; $script:TextPassword.Text = ''; $script:TextPassword.Enabled = $true
				# (no success popup needed)
			} else {
				# Encrypt now
				if ([string]::IsNullOrWhiteSpace($script:TextPassword.Text)) { Show-InfoT 'message.enter_password_first'; return }
				$pp = Prompt-Passphrase (T 'title.passphrase_set' @{ app = $AppName }) -Confirm
				if ([string]::IsNullOrWhiteSpace($pp)) { return }
				try {
					Protect-PortableSecret $script:TextPassword.Text $pp $SecretPath
					# Keep plaintext for this session so Browse works without re-prompt
					$script:PlainPassCache = $script:TextPassword.Text; $script:AskedPassphrase = $true; $script:TextPassword.Text = ''
				} catch { Show-ErrorT 'message.write_secret_failed' @{ err = $_.Exception.Message }; return }
			}
		} else {
			# INSTALLED MODE: toggle between Encrypt and Clear
			if (-not [string]::IsNullOrEmpty($State.EncPass)) { $ans = Ask-YesNoQuestT 'prompt.clear_stored_password'; if ($ans -ne [System.Windows.Forms.DialogResult]::Yes) { return }; Clear-PlainPassword <# wipe secret everywhere + persist #>; $script:TextPassword.Text = '' <# reset UI textbox immediately #> }
			elseif ([string]::IsNullOrWhiteSpace($script:TextPassword.Text)) { Show-InfoT 'message.enter_password_first'; return }
			else { try { Set-PlainPassword $script:TextPassword.Text } catch { Show-ErrorT 'message.store_password_failed' @{ err = $_.Exception.Message }; return } }
		}
		& $script:RefreshPasswordState
		& $script:RefreshExportButtons
	})
	# Keep UI reactive if user edits the field
	$script:TextPassword.add_TextChanged({ & $script:RefreshPasswordState })
	# Initial state (now $script:ButtonBrowse exists)
	& $script:RefreshPasswordState
	# Drive selector
	$script:LabelDriveLetter = New-Object Windows.Forms.Label; $script:LabelDriveLetter.Text = (T 'label.drive_letter'); $script:LabelDriveLetter.Left = 12; $script:LabelDriveLetter.Top = 160; $script:LabelDriveLetter.AutoSize = $true
	$script:ComboBoxDrive = New-Object Windows.Forms.ComboBox; $script:ComboBoxDrive.Top = 158; $script:ComboBoxDrive.Width = 60; $script:ComboBoxDrive.Left = $script:TextServer.Left; $script:ComboBoxDrive.DropDownStyle = 'DropDownList'; $script:ComboBoxDrive.Anchor = 'Top, Right'
	# Display name
	$script:LabelDisplayName = New-Object Windows.Forms.Label; $script:LabelDisplayName.Text = (T 'label.display_name'); $script:LabelDisplayName.Left = 12; $script:LabelDisplayName.Top = 190; $script:LabelDisplayName.AutoSize = $true
	$script:TxtDisp = New-Object Windows.Forms.TextBox; $script:TxtDisp.Top = 188; $script:TxtDisp.Width = $script:TextServer.Width; $script:TxtDisp.Left = $script:TextServer.Left; $script:TxtDisp.Text = $State.Label; $script:TxtDisp.Anchor = 'Top, Right'
	# Initial prefill for display name if empty (and remember that it was auto-filled)
	if ([string]::IsNullOrWhiteSpace($script:TxtDisp.Text)) {
		$script:TxtDisp.Text = (& $script:ComputeDefaultLabel $script:TxtSub.Text $script:TextUser.Text.Trim() $script:TextServer.Text.Trim())
		$script:BasicSettings_Auto.LastAuto = $script:TxtDisp.Text
	}
	$script:TextUser.add_TextChanged({
		$newDefault = (& $script:ComputeDefaultLabel $script:TxtSub.Text $script:TextUser.Text.Trim() $script:TextServer.Text.Trim())
		if ([string]::IsNullOrWhiteSpace($script:TxtDisp.Text) -or ($script:TxtDisp.Text -eq $script:BasicSettings_Auto.LastAuto)) { $script:TxtDisp.Text = $newDefault; $script:BasicSettings_Auto.LastAuto = $newDefault }
		& $script:UpdateSaveButton
	})
	# If the user edits the Display name manually, stop auto-overwriting
	$script:TxtDisp.add_TextChanged({ if ($script:TxtDisp.Focused) { $script:BasicSettings_Auto.LastAuto = $null }; & $script:UpdateSaveButton })
	# Interval
	$script:LabelCheckInterval = New-Object Windows.Forms.Label; $script:LabelCheckInterval.Text = (T 'label.checkinterval'); $script:LabelCheckInterval.Left = 12; $script:LabelCheckInterval.Top = 220; $script:LabelCheckInterval.AutoSize = $true
	$script:Num = New-Object Windows.Forms.NumericUpDown; $script:Num.Left = 135; $script:Num.Top = 218; $script:Num.Minimum = 5; $script:Num.Maximum = 600; $script:Num.Value = ([int]$State.IntervalS); $script:Num.Width = 45
	$script:Num.add_ValueChanged({ & $script:UpdateSaveButton })
	# Language preference combo ("Auto" + available languages)
	$script:LabelLanguage = New-Object Windows.Forms.Label; $script:LabelLanguage.Text = (T 'label.language'); $script:LabelLanguage.Left = $script:TextServer.Left; $script:LabelLanguage.Top = 220; $script:LabelLanguage.AutoSize = $true; $script:LabelLanguage.Anchor = 'Top, Right'
	$script:ComboBoxLanguage = New-Object Windows.Forms.ComboBox; $script:ComboBoxLanguage.Left = $script:TextServer.Left + 90; $script:ComboBoxLanguage.Top = $script:LabelLanguage.Top - 3; $script:ComboBoxLanguage.Width = 60; $script:ComboBoxLanguage.DropDownStyle = 'DropDownList'; $script:ComboBoxLanguage.Anchor = 'Top, Right'
	# Language import button (installed mode only)
	$script:ButtonLanguageImport = New-Object Windows.Forms.Button; $script:ButtonLanguageImport.Text = (T 'button.install_language'); $script:ButtonLanguageImport.Left = $script:ComboBoxLanguage.Left + $script:ComboBoxLanguage.Width + 10; $script:ButtonLanguageImport.Width = $panelMain.ClientSize.Width - $script:ButtonLanguageImport.Left - 2; $script:ButtonLanguageImport.Top = $script:LabelLanguage.Top - 6; $script:ButtonLanguageImport.Height = $script:ButtonH; $script:ButtonLanguageImport.Anchor = 'Top, Right'
	# Helper to resolve base folder for i18n packs (portable vs installed)
	$script:ResolveLangBase = {
		$base = $null
		if ($PortableMode) { $sp = Get-ThisScriptPath; if (-not $sp) { $sp = $PSCommandPath }; if ($sp) { $base = [System.IO.Path]::GetDirectoryName($sp) } }
		else { $base = $InstallDir }
		return (Join-Path $base 'i18n')
	}
	# Guard to suppress autosave during programmatic combo updates
	$script:IsLangComboInternalUpdate = $false
	# Helper to rebuild language list (available language packs)
	$script:RefreshLangList = {
		# Determine base folder for i18n packs
		$langBase = & $script:ResolveLangBase
		$langs = @()
		try {
			if ($langBase -and (Test-Path -LiteralPath $langBase)) {
				$files = Get-ChildItem -LiteralPath $langBase -Filter ("{0}i18n*.json" -f $AppNameShort) -File -ErrorAction SilentlyContinue
				foreach ($f in $files) { $m = [regex]::Match($f.Name, ('^{0}i18n\.([^.]+)\.json$' -f ([regex]::Escape($AppNameShort)))); if ($m.Success) { $langs += $m.Groups[1].Value } }
			}
		} catch {}
		if ($langs -notcontains 'en') { $langs += 'en' }
		# dedupe + sort
		$langs = $langs | Sort-Object -Unique
		$script:IsLangComboInternalUpdate = $true
		try {
			$script:ComboBoxLanguage.Items.Clear()
			[void]$script:ComboBoxLanguage.Items.Add('Auto')
			foreach ($l in $langs) { [void]$script:ComboBoxLanguage.Items.Add($l) }
			# Select current preference
			$pref = $State.LangPref
			$script:ComboBoxLanguage.SelectedItem = if (-not [string]::IsNullOrWhiteSpace($pref) -and $script:ComboBoxLanguage.Items.Contains($pref)) { $pref } else { 'Auto' }
		} finally {
			$script:IsLangComboInternalUpdate = $false
		}
	}
	# Click handler for language import
	$script:ButtonLanguageImport.Add_Click({
		try {
			$dlg = New-Object System.Windows.Forms.OpenFileDialog
			$dlg.Title = (T 'title.install_language')
			$dlg.Filter = ('i18n JSON ({0}i18n*.json) | {0}i18n*.json|JSON (*.json)|*.json' -f $AppNameShort)
			$dlg.InitialDirectory = [Environment]::GetFolderPath('Desktop')
			if ($dlg.ShowDialog() -ne 'OK') { return }
			# Copy chosen i18n file into resolved i18n dir
			$destDir = & $script:ResolveLangBase
			if (-not (Test-Path -LiteralPath $destDir)) { New-Item -ItemType Directory -Path $destDir -Force | Out-Null }
			$bn = [System.IO.Path]::GetFileName($dlg.FileName)
			Copy-Item -LiteralPath $dlg.FileName -Destination (Join-Path $destDir $bn) -Force
			# Refresh combo now that a new language might be available
			& $script:RefreshLangList
			try { Show-InfoT 'message.lang_imported' @{ path = $bn } } catch {}
		} catch { Show-ErrorT 'message.import_failed' @{ err = $_.Exception.Message } }
	})
	# Checkboxes for autostart and shortcuts (in a TableLayoutPanel)
	$PanelCheckboxes = New-Object System.Windows.Forms.TableLayoutPanel; $PanelCheckboxes.Left = 12; $PanelCheckboxes.Top = 255; $PanelCheckboxes.Width = $panelMain.ClientSize.Width - 12; $PanelCheckboxes.Height = 30; $PanelCheckboxes.Anchor = 'Top, Left, Right'; $PanelCheckboxes.RowCount = 1; $PanelCheckboxes.ColumnCount = 3; $PanelCheckboxes.GrowStyle = 'FixedSize'
	$PanelCheckboxes.ColumnStyles.Clear(); $PanelCheckboxes.ColumnStyles.Add((New-Object System.Windows.Forms.ColumnStyle([System.Windows.Forms.SizeType]::Percent, 34))); $PanelCheckboxes.ColumnStyles.Add((New-Object System.Windows.Forms.ColumnStyle([System.Windows.Forms.SizeType]::Percent, 34))); $PanelCheckboxes.ColumnStyles.Add((New-Object System.Windows.Forms.ColumnStyle([System.Windows.Forms.SizeType]::Percent, 32)))
	$script:CheckboxAutostart = New-Object Windows.Forms.CheckBox; $script:CheckboxAutostart.Text = (T 'box.autostart'); $script:CheckboxAutostart.AutoSize = $true; $script:CheckboxAutostart.Anchor = 'Top, Left'; $script:CheckboxAutostart.Checked = (Is-StartupRunKeyEnabled)
	$script:CheckboxShortcutStartmenu = New-Object Windows.Forms.CheckBox; $script:CheckboxShortcutStartmenu.Text = (T 'box.shortcut_startmenu'); $script:CheckboxShortcutStartmenu.AutoSize = $true; $script:CheckboxShortcutStartmenu.Anchor = 'Top, Left'; $script:CheckboxShortcutStartmenu.Checked = (Shortcut-Exists 'StartMenu')
	$script:CheckboxShortcutDesktop = New-Object Windows.Forms.CheckBox; $script:CheckboxShortcutDesktop.Text = (T 'box.shortcut_desktop'); $script:CheckboxShortcutDesktop.AutoSize = $true; $script:CheckboxShortcutDesktop.Anchor = 'Top, Left'; $script:CheckboxShortcutDesktop.Checked = (Shortcut-Exists 'Desktop')
	[void]$PanelCheckboxes.Controls.Add($script:CheckboxAutostart, 0, 0); [void]$PanelCheckboxes.Controls.Add($script:CheckboxShortcutStartmenu, 1, 0); [void]$PanelCheckboxes.Controls.Add($script:CheckboxShortcutDesktop, 2, 0)
	# Use Click (not CheckedChanged) so we don't fire during initialization
	$script:CheckboxAutostart.Add_Click(({
		# sender is the checkbox itself
		if ($PortableMode) { return }
		try { <# Apply change immediately #> Set-StartupRunKey $this.Checked } catch { <# Revert UI and show error #> try { $this.Checked = -not $this.Checked } catch {}; try { Show-ErrorT 'message.operation_failed' @{ err = $_.Exception.Message } } catch {} }
	}).GetNewClosure())
	$script:CheckboxShortcutStartmenu.Add_Click(({
		if ($PortableMode) { return }
		try { Ensure-Shortcut 'StartMenu' $this.Checked } catch { try { $this.Checked = -not $this.Checked } catch {}; try { Show-ErrorT 'message.operation_failed' @{ err = $_.Exception.Message } } catch {} }
	}).GetNewClosure())
	$script:CheckboxShortcutDesktop.Add_Click(({
		if ($PortableMode) { return }
		try { Ensure-Shortcut 'Desktop' $this.Checked } catch { try { $this.Checked = -not $this.Checked } catch {}; try { Show-ErrorT 'message.operation_failed' @{ err = $_.Exception.Message } } catch {} }
	}).GetNewClosure())
	# top row: Install/Uninstall + ExportConfig (in two TableLayoutPanel)
	$PanelButtons1 = New-Object System.Windows.Forms.TableLayoutPanel; $PanelButtons1.Left = 12; $PanelButtons1.Top = 290; $PanelButtons1.Width = $panelMain.ClientSize.Width - 14; $PanelButtons1.Height = $script:ButtonXH + 2; $PanelButtons1.Anchor = 'Top, Left, Right'
	$PanelButtons1.RowCount = 1; $PanelButtons1.ColumnCount = 3; $PanelButtons1.GrowStyle = 'FixedSize'; $PanelButtons1.AutoSize = $false
	$PanelButtons1.ColumnStyles.Clear(); $PanelButtons1.ColumnStyles.Add((New-Object System.Windows.Forms.ColumnStyle([System.Windows.Forms.SizeType]::Percent, 50))); $PanelButtons1.ColumnStyles.Add((New-Object System.Windows.Forms.ColumnStyle([System.Windows.Forms.SizeType]::Absolute, 10))); $PanelButtons1.ColumnStyles.Add((New-Object System.Windows.Forms.ColumnStyle([System.Windows.Forms.SizeType]::Percent, 50)))
	# bottom row: ImportConfig + ExportToPortable
	$PanelButtons2 = New-Object System.Windows.Forms.TableLayoutPanel; $PanelButtons2.Left = 12; $PanelButtons2.Top = $PanelButtons1.Top + $script:ButtonXH + 8; $PanelButtons2.Width = $panelMain.ClientSize.Width - 14; $PanelButtons2.Height = $script:ButtonXH + 2; $PanelButtons2.Anchor = 'Top, Left, Right'
	$PanelButtons2.RowCount = 1; $PanelButtons2.ColumnCount = 3; $PanelButtons2.GrowStyle = 'FixedSize'; $PanelButtons2.AutoSize = $false
	$PanelButtons2.ColumnStyles.Clear(); $PanelButtons2.ColumnStyles.Add((New-Object System.Windows.Forms.ColumnStyle([System.Windows.Forms.SizeType]::Percent, 50))); $PanelButtons2.ColumnStyles.Add((New-Object System.Windows.Forms.ColumnStyle([System.Windows.Forms.SizeType]::Absolute, 10))); $PanelButtons2.ColumnStyles.Add((New-Object System.Windows.Forms.ColumnStyle([System.Windows.Forms.SizeType]::Percent, 50)))
	$script:ButtonInstall = New-Object Windows.Forms.Button; $script:ButtonInstall.Text = (T 'button.install2appdata'); $script:ButtonInstall.Dock = 'Fill'; $script:ButtonInstall.Height = $script:ButtonXH
	$script:ButtonUninstall = New-Object Windows.Forms.Button; $script:ButtonUninstall.Text = (T 'button.uninstall'); $script:ButtonUninstall.Dock = 'Fill'; $script:ButtonUninstall.Height = $script:ButtonXH
	$script:ButtonExportConfig = New-Object Windows.Forms.Button; $script:ButtonExportConfig.Text = (T 'button.export_config'); $script:ButtonExportConfig.Dock = 'Fill'; $script:ButtonExportConfig.Height = $script:ButtonXH
	$script:ButtonImportConfig = New-Object Windows.Forms.Button; $script:ButtonImportConfig.Text = (T 'button.import_config'); $script:ButtonImportConfig.Dock = 'Fill'; $script:ButtonImportConfig.Height = $script:ButtonXH
	$script:ButtonExportToPortable = New-Object Windows.Forms.Button; $script:ButtonExportToPortable.Text = (T 'button.export2portable'); $script:ButtonExportToPortable.Dock = 'Fill'; $script:ButtonExportToPortable.Height = $script:ButtonXH
	[void]$PanelButtons1.Controls.Add($script:ButtonInstall, 0, 0); [void]$PanelButtons1.Controls.Add($script:ButtonUninstall, 0, 0); [void]$PanelButtons1.Controls.Add($script:ButtonExportConfig, 2, 0)
	[void]$PanelButtons2.Controls.Add($script:ButtonImportConfig, 0, 0); [void]$PanelButtons2.Controls.Add($script:ButtonExportToPortable, 2, 0)
	# Enable/disable export buttons based on saved state (installed mode only)
	$script:RefreshExportButtons = {
		if ($PortableMode) { return } # not relevant in portable mode
		$ready = ($State -and -not [string]::IsNullOrWhiteSpace($State.EncPass) -and -not [string]::IsNullOrWhiteSpace($State.Server) -and -not [string]::IsNullOrWhiteSpace($State.User))
		try { if ($script:ButtonExportConfig) { $script:ButtonExportConfig.Enabled = $ready } } catch {}; try { if ($script:ButtonExportToPortable) { $script:ButtonExportToPortable.Enabled = $ready } } catch {}
	}
	# Rebind all Basic Settings controls from current $State after an Import/Reload
	$script:RebindUIFromState = {
		try { $panelMain.SuspendLayout(); $panelFooter.SuspendLayout() } catch {} # Avoid flicker and cascading events
		try {
			$script:TextServer.Text = ($State.Server -as [string]); $script:TextUser.Text = ($State.User -as [string]) # Core fields
			# Subfolder textbox expects trimmed value ('' means no subpath)
			$sp = ($State.SubPath -as [string]); if ($sp -eq '/') { $sp = '' } else { $sp = ($sp -as [string]).Trim('/','\') }; $script:TxtSub.Text = $sp
			$script:TxtDisp.Text = ($State.Label -as [string]) # Display name exactly as persisted (do NOT recompute)
			$script:BasicSettings_Auto.LastAuto = $null # Prevent later auto-overwrite by the "auto" logic
			& $script:RebuildDriveList # Drive list + selection
			if ($State.Drive -and $script:ComboBoxDrive.Items.Contains($State.Drive)) { $script:ComboBoxDrive.SelectedItem = $State.Drive } else { <# Fallback: keep first free or current selection from RebuildDriveList #> }
			$script:PrevDriveSel = if ($script:ComboBoxDrive.SelectedItem) { [string]$script:ComboBoxDrive.SelectedItem } else { $null }
			& $script:RefreshLangList # Language list/selection from state
			& $script:ApplyLanguageNow
			& $script:RefreshExportButtons
			# Active scope label recalculation (if present)
			if ($script:UpdateActiveScopeLabel -and $script:LabelActiveScope) { & $script:UpdateActiveScopeLabel $script:LabelActiveScope }
		} finally { try { $panelMain.ResumeLayout($true); $panelFooter.ResumeLayout($true) } catch {} }
		$script:Baseline = & $script:GetPendingConfig # Make the freshly rebound UI the new baseline  no "unsaved changes" prompt
		& $script:UpdateSaveButton
	}
	# Buttons save and close
	$script:ButtonClose1 = New-Object Windows.Forms.Button; $script:ButtonClose1.Text = (T 'button.close'); $script:ButtonClose1.Width = 100; $script:ButtonClose1.Left = $panelFooter.ClientSize.Width - $script:ButtonClose1.Width - 2; $script:ButtonClose1.Height = $script:ButtonXH; $script:ButtonClose1.Top = 0; $script:ButtonClose1.Anchor = 'Top, Right'; $script:ButtonClose1.TabIndex = 1
	$script:ButtonSave = New-Object Windows.Forms.Button; $script:ButtonSave.Text = (T 'button.save'); $script:ButtonSave.Width = 100; $script:ButtonSave.Left = $script:ButtonClose1.Left - $script:ButtonSave.Width - 10; $script:ButtonSave.Height = $script:ButtonXH; $script:ButtonSave.Top = 0; $script:ButtonSave.Anchor = 'Top, Right'; $script:ButtonSave.TabIndex = 0
	# Set default buttons so Enter/Esc behave nicely
	$f.AcceptButton = $script:ButtonSave; $f.CancelButton = $script:ButtonClose1
	if ($PortableMode) { $script:CheckboxAutostart.Enabled = $false; $script:CheckboxShortcutStartmenu.Enabled = $false; $script:CheckboxShortcutDesktop.Enabled = $false; $script:ButtonExportToPortable.Visible = $false; $script:ButtonUninstall.Visible = $false; $script:ButtonInstall.Visible = $true; $script:ButtonExportConfig.Visible = $false; $script:ButtonLanguageImport.Visible = $false }
	else { $script:ButtonInstall.Visible = $false; $script:ButtonExportToPortable.Visible = $true; $script:ButtonUninstall.Visible = $true; $script:ButtonExportConfig.Visible = $true; $script:ButtonLanguageImport.Visible = $true; & $script:RefreshExportButtons }
	# Drive list with colors (used stays visible/red, not selectable; default = first free)
	$script:BasicSettingsStatuses = @{}
	# Small rebuild helper (scriptblock closes over locals)
	$script:RebuildDriveList = {
		$script:ComboBoxDrive.Items.Clear()
		$all = (68..90 | ForEach-Object { '{0}:' -f ([char]$_) })
		$used = (Get-PSDrive -PSProvider FileSystem | Select-Object -Expand Name) | ForEach-Object { '{0}:' -f $_ }
		$current = if (Test-ValidDrive $State.Drive) { $State.Drive } else { $null }
		if (-not $script:BasicSettingsStatuses) { $script:BasicSettingsStatuses = @{} } else { $script:BasicSettingsStatuses.Clear() }
		foreach ($d in $all) { $isCurrent = ($d -eq $current); $isUsed = ($used -contains $d); if ($isCurrent) { $script:BasicSettingsStatuses[$d] = 'current' } elseif ($isUsed) { $script:BasicSettingsStatuses[$d] = 'used' } else { $script:BasicSettingsStatuses[$d] = 'free' }; [void]$script:ComboBoxDrive.Items.Add($d) }
		# Default selection: current if usable; otherwise first free
		if ($current -and $script:BasicSettingsStatuses.ContainsKey($current) -and ($script:BasicSettingsStatuses[$current] -in @('free', 'current'))) { $script:ComboBoxDrive.SelectedItem = $current }
		else { $firstFree = ($script:ComboBoxDrive.Items | Where-Object { $script:BasicSettingsStatuses[[string]$_] -eq 'free' } | Select-Object -First 1); if ($firstFree) { $script:ComboBoxDrive.SelectedItem = [string]$firstFree } else { $script:ComboBoxDrive.SelectedIndex = -1 } }
	}
	$script:ComboBoxDrive.DrawMode = 'OwnerDrawFixed'; $script:ComboBoxDrive.ItemHeight = $script:ComboBoxDrive.Font.Height + 4
	$script:ComboBoxDrive.add_DrawItem({
		param($s, $e)
		if ($e.Index -lt 0) { return }
		$d = [string]$s.Items[$e.Index]
		$st = if ($script:BasicSettingsStatuses.ContainsKey($d)) { $script:BasicSettingsStatuses[$d] } else { 'free' }
		switch ($st) { 'free' { $bgColor = [System.Drawing.Color]::PaleGreen }; 'used' { $bgColor = [System.Drawing.Color]::LightCoral }; 'current' { $bgColor = [System.Drawing.Color]::Khaki }; default { $bgColor = [System.Drawing.Color]::White } }
		if (($e.State -band [System.Windows.Forms.DrawItemState]::Selected) -ne 0) { $e.Graphics.FillRectangle([System.Drawing.SystemBrushes]::Highlight, $e.Bounds); $fg = [System.Drawing.SystemBrushes]::HighlightText }
		else { $bg = New-Object System.Drawing.SolidBrush($bgColor); $e.Graphics.FillRectangle($bg, $e.Bounds); $bg.Dispose(); $fg = [System.Drawing.Brushes]::Black }
		$e.Graphics.DrawString($d, $e.Font, $fg, $e.Bounds.X+2, $e.Bounds.Y+2); $e.DrawFocusRectangle()
	})
	# Guard: prevent re-entrancy while we correct the selection programmatically
	$script:DriveSelBusy = $false
	# Build once
	& $script:RebuildDriveList
	# Prevent selecting "used"; remember previous valid selection
	$script:PrevDriveSel = if ($script:ComboBoxDrive.SelectedItem) { [string]$script:ComboBoxDrive.SelectedItem } else { $null }
	$script:ComboBoxDrive.add_SelectionChangeCommitted(({
		param($s, $e)
		if ($script:DriveSelBusy) { return } # Ignore if we're already fixing selection programmatically
		$new = [string]$s.SelectedItem
		if (-not $new) { return }
		# current filesystem drives, normalized to "X:"
		$usedNow = Get-PSDrive -PSProvider FileSystem | Select-Object -Expand Name | ForEach-Object { '{0}:' -f $_ }
		# allow selecting the drive that is already configured for this app
		$isOurCurrent = ($State.Drive -and ($new -ieq $State.Drive))
		if (-not $isOurCurrent -and ($usedNow -contains $new)) {
			Show-WarnT 'message.drive_letter_used' @{ drive = $new }
			# Decide fallback target (original configured, previous valid, or first free)
			$target = $null
			$orig = [string]$State.Drive
			if ($orig -and $s.Items.Contains($orig)) { $target = $orig }
			elseif ($script:PrevDriveSel -and $s.Items.Contains($script:PrevDriveSel)) { $target = $script:PrevDriveSel }
			if (-not $target) { $firstFree = ($s.Items | Where-Object { -not ($usedNow -contains [string]$_) } | Select-Object -First 1); if ($firstFree) { $target = [string]$firstFree } }
			# Set selection asynchronously to avoid re-entrancy during the setter
			$script:DriveSelBusy = $true
			$s.BeginInvoke([Action]{ try { if ($target) { $s.SelectedItem = $target } else { $s.SelectedIndex = -1 } } finally { $script:DriveSelBusy = $false } }) | Out-Null
			return
		}
		$script:PrevDriveSel = $new # Accept user choice
		if ($script:UpdateSaveButton -is [scriptblock]) { & $script:UpdateSaveButton }
	}).GetNewClosure())
	# Also react when selection actually changes (keyboard, programmatic dropdown close, etc.)
	$script:ComboBoxDrive.add_SelectedIndexChanged({
		if ($script:DriveSelBusy) { return } # ignore while we revert programmatically
		if ($script:UpdateSaveButton -is [scriptblock]) { & $script:UpdateSaveButton }
	})
	# live language update helper (safe, no crash if some globals are not created yet)
	$script:ApplyLanguageNow = {
		# re-init i18n with the currently chosen language
		try { Initialize-I18n $State.LangPref } catch {}
		# helper: safely set .Text on a control if it exists and supports Text
		$setTxt = { param($ctrl, $newText); if ($ctrl -and ($ctrl.PSObject.Properties.Name -contains 'Text')) { $ctrl.Text = $newText } }
		# helper: set localized ToolTip text on a control (static tips only; dynamic tips via RefreshPasswordState)
		$setTip = { param($ctrl, $key); if ($ctrl -and ($ctrl -is [System.Windows.Forms.Control])) { $script:Tip.SetToolTip($ctrl, (T $key)) } }
		# update dialog title
		& $setTxt $f (T 'title.settings_dialog' @{ app = $AppName })
		# update mode badge ("PORTABLE MODE"/"INSTALLED MODE")
		if ($script:LabelMode) { if ($PortableMode) { & $setTxt $script:LabelMode (T 'mode.portable'); $script:LabelMode.ForeColor = [System.Drawing.Color]::ForestGreen } else { & $setTxt $script:LabelMode (T 'mode.installed'); $script:LabelMode.ForeColor = [System.Drawing.Color]::SteelBlue } }
		# update static labels / buttons in this window
		& $setTxt $script:TabBasic (T 'tab.basic_settings')
		& $setTxt $script:TabTuning (T 'tab.webclient_tuning')
		& $setTxt $script:TabCache (T 'tab.webdav_cache')
		& $setTxt $script:LabelServer (T 'label.server')
		& $setTxt $script:LabelUser (T 'label.user')
		& $setTxt $script:LabelPassword (T 'app_password')
		& $setTxt $script:LabelSubfolder (T 'label.subfolder')
		& $setTxt $script:LabelDriveLetter (T 'label.drive_letter')
		& $setTxt $script:LabelDisplayName (T 'label.display_name')
		& $setTxt $script:LabelCheckInterval (T 'label.checkinterval')
		& $setTxt $script:LabelLanguage (T 'label.language')
		& $setTxt $script:ButtonLanguageImport (T 'button.install_language')
		& $setTxt $script:CheckboxAutostart (T 'box.autostart')
		& $setTxt $script:CheckboxShortcutStartmenu (T 'box.shortcut_startmenu')
		& $setTxt $script:CheckboxShortcutDesktop (T 'box.shortcut_desktop')
		& $setTxt $script:ButtonInstall (T 'button.install2appdata')
		& $setTxt $script:ButtonUninstall (T 'button.uninstall')
		& $setTxt $script:ButtonExportConfig (T 'button.export_config')
		& $setTxt $script:ButtonImportConfig (T 'button.import_config')
		& $setTxt $script:ButtonExportToPortable (T 'button.export2portable')
		& $setTxt $script:ButtonSave (T 'button.save')
		& $setTxt $script:ButtonClose1 (T 'button.close')
		# WebClient tuning tab labels/buttons
		& $setTxt $script:LabelBasicAuthLevel (T 'label.basic_auth_level')
		& $setTxt $script:LabelFilesPerFolder (T 'label.file_attributes_limit')
		& $setTxt $script:LabelFileSizeLimit (T 'label.file_size_limit')
		& $setTxt $script:LabelLocalServerTimeout (T 'label.local_server_timeout')
		& $setTxt $script:LabelInternetServerTimeout (T 'label.internet_server_timeout')
		& $setTxt $script:LabelSendReceiveTimeout (T 'label.send_receive_timeout')
		& $setTxt $script:LabelServerNotFoundCacheLifeTime (T 'label.server_not_found_cache_lifetime')
		& $setTxt $script:LabelServiceStatus (T 'label.service_status')
		& $setTxt $script:LabelServiceStartType (T 'label.service_starttype')
		& $setTxt $script:ButtonServiceTriggerInfo (T 'button.triggerinfo')
		& $setTxt $script:ButtonServiceStart (T 'button.start_service')
		& $setTxt $script:ButtonServiceRestart (T 'button.restart_service')
		& $setTxt $script:ButtonApplyAsAdmin (T 'button.uac_apply_changes')
		& $setTxt $script:ButtonClose2 (T 'button.close')
		# WebDAV cache tab Labels/Buttons
		& $setTxt $script:CacheWatcherStartButton (T 'button.cache_watcher_start')
		& $setTxt $script:CacheWatcherStopButton (T 'button.cache_watcher_stop')
		& $setTxt $script:CacheWatcherLiveCheckbox (T 'box.cache_live_update')
		& $setTxt $script:ButtonCacheRefresh (T 'button.refresh')
		& $setTxt $script:CacheClearOnExitCheckbox (T 'box.cache_clear_on_exit')
		& $setTxt $script:ButtonCacheDeleteAll (T 'button.clear_cache')
        # Update cache ListView column headers
		if ($script:CacheListView -and -not $script:CacheListView.IsDisposed) { $cols = $script:CacheListView.Columns; if ($cols.Count -ge 4) { $cols[0].Text = (T 'column.cache_name'); $cols[1].Text = (T 'column.cache_size'); $cols[2].Text = (T 'column.cache_modified'); $cols[3].Text = (T 'column.cache_type') } }
		# force-refresh all tooltips to avoid stale cached strings
		$script:Tip.RemoveAll()
		# apply i18n to static ToolTips
		& $setTip $script:TextServer 'tip.enter_server'
		& $setTip $script:TextUser 'tip.enter_user'
		& $setTip $script:ButtonPasswordHelp 'title.app_password_help'
		& $setTip $script:ComboBoxBasicAuthLevel 'tip.basic_auth'
		& $setTip $script:ButtonLocalServerTimeoutHelp 'tip.local_server_timeout_help'
		& $setTip $script:ButtonInternetServerTimeoutHelp 'tip.internet_server_timeout_help'
		& $setTip $script:ButtonSendReceiveTimeoutHelp 'tip.send_receive_timeout_help'
		& $setTip $script:ButtonServerNotFoundCacheLifeTimeHelp 'tip.server_not_found_cache_lifetime_help'
		# --- Refresh i18n text in combo boxes ---
		# BasicAuthLevel combo: rebuild items with new translations, keep selection
		if ($script:ComboBoxBasicAuthLevel -is [System.Windows.Forms.ComboBox] -and -not $script:ComboBoxBasicAuthLevel.IsDisposed) {
			$oldIdx = $script:ComboBoxBasicAuthLevel.SelectedIndex; $script:BalGuard = $true
			try {
				$script:ComboBoxBasicAuthLevel.Items.Clear()
				[void]$script:ComboBoxBasicAuthLevel.Items.Add((T 'combo.basic_auth_level_0'))
				[void]$script:ComboBoxBasicAuthLevel.Items.Add((T 'combo.basic_auth_level_1'))
				[void]$script:ComboBoxBasicAuthLevel.Items.Add((T 'combo.basic_auth_level_2'))
				if ($oldIdx -ge 0 -and $oldIdx -lt $script:ComboBoxBasicAuthLevel.Items.Count) { $script:ComboBoxBasicAuthLevel.SelectedIndex = $oldIdx }
			}
			finally { $script:BalGuard = $false }
		}
		# WebClient service start type combo: rebuild items with new translations, keep selection
		if ($script:ComboServiceStartType -is [System.Windows.Forms.ComboBox] -and -not $script:ComboServiceStartType.IsDisposed) {
			$oldIdx = $script:ComboServiceStartType.SelectedIndex
			try {
				$script:ComboServiceStartType.Items.Clear()
				[void]$script:ComboServiceStartType.Items.Add((T 'combo.webclient_start_automatic'))
				[void]$script:ComboServiceStartType.Items.Add((T 'combo.webclient_start_manual'))
				[void]$script:ComboServiceStartType.Items.Add((T 'combo.webclient_start_disabled'))
				if ($oldIdx -ge 0 -and $oldIdx -lt $script:ComboServiceStartType.Items.Count) { $script:ComboServiceStartType.SelectedIndex = $oldIdx }
			} catch {}
		}
		# Ensure Apply button dirty state reflects the new texts / selections
		if ($script:UpdateWebClientApplyButton -is [scriptblock]) { & $script:UpdateWebClientApplyButton }
		# dynamic ToolTips (txtSub/txtPwd) and encrypt/clear button text
		& $script:RefreshPasswordState
		# re-apply dynamic WebClient status tooltip
		$lastState = $null
		if ($script:LabelServiceStatus -and $script:LabelServiceStatus.Tag) { $lastState = [string]$script:LabelServiceStatus.Tag.State }
		if ($script:SetWebClientStatusLabel -is [scriptblock] -and -not [string]::IsNullOrWhiteSpace($lastState)) { & $script:SetWebClientStatusLabel $lastState }
		# update tray/menu text if they already exist in the outer scope
		if ($miMode) {
			if ($PortableMode) { & $setTxt $miMode (T 'mode.portable'); if ($miMode.PSObject.Properties.Name -contains 'ForeColor') { $miMode.ForeColor = [System.Drawing.Color]::ForestGreen } }
			else { & $setTxt $miMode (T 'mode.installed'); if ($miMode.PSObject.Properties.Name -contains 'ForeColor') { $miMode.ForeColor = [System.Drawing.Color]::SteelBlue } }
		}
		if ($miConn) { & $setTxt $miConn (T 'menu.connect') }
		if ($miDisc) { & $setTxt $miDisc (T 'menu.disconnect') }
		if ($miSett) { & $setTxt $miSett (T 'menu.settings') }
		if ($miAbout) { & $setTxt $miAbout (T 'menu.about') }
		if ($miExit) { & $setTxt $miExit (T 'menu.exit') }
		# update tray tooltip text, if tray already exists
		if ($script:tray) {
			# Refresh deactivated flag to avoid stale tooltip after tuning changes
			Sync-WebClientDeactivatedFlag | Out-Null
			if ($script:ServiceDeactivated) { $script:tray.Text = T 'tray.service_deactivated' @{ app = $AppName } }
			elseif ($script:NeedsSetup) { $script:tray.Text = T 'tray.needs_setup' @{ app = $AppName } }
			elseif ($script:Paused) { $script:tray.Text = T 'tray.paused' @{ app = $AppName; drive = $State.Drive } }
			else { $script:tray.Text = T 'tray.initializing' @{ app = $AppName } }
		}
		# recompute active scope text after language change
		if ($script:LabelActiveScope) { try { & $script:UpdateActiveScopeLabel $script:LabelActiveScope } catch { $script:LabelActiveScope.Visible = $false } }
	}
	# language combo box change handler: this fires whenever the user picks a language or when we programmatically select it in RefreshLangList
	$script:ComboBoxLanguage.add_SelectedIndexChanged({
		if ($script:IsLangComboInternalUpdate) { return } # ignore programmatic changes while list is being (re)built
		$sel = [string]$script:ComboBoxLanguage.SelectedItem
		if ($sel -and $sel -ne 'Auto') { $State.LangPref = $sel } else { $State.LangPref = '' }
		try { Save-Config } catch {} # persist immediately (installed/portable handled by Save-Config)
		# update only the LangPref key in the dirty baseline
		try {
			$now = & $script:GetPendingConfig
			if (-not $script:Baseline) { $script:Baseline = $now }
			elseif ($script:Baseline.ContainsKey('LangPref') -and $now.ContainsKey('LangPref')) { $script:Baseline['LangPref'] = $now['LangPref'] }
		} catch {}
		& $script:ApplyLanguageNow; & $script:RefreshExportButtons; & $script:UpdateSaveButton
	})
	# Now that controls exist, populate language list
	& $script:RefreshLangList
	# --- Dirty tracking (compare UI vs last-saved baseline) ---
	$script:GetPendingConfig = {
		# Normalize current UI state to what Save() would persist
		$sel = [string]$script:ComboBoxLanguage.SelectedItem
		$langPrefNow = if ($sel -and $sel -ne 'Auto') { $sel } else { '' }
		$sp = ($script:TxtSub.Text -as [string])
		if ($sp -eq '/') { $sp = '' } else { $sp = $sp.Trim('/','\') }
		return @{ Server = ($script:TextServer.Text.Trim()); User = ($script:TextUser.Text.Trim()); SubPath = $sp; Drive = [string]$script:ComboBoxDrive.SelectedItem; Label = $script:TxtDisp.Text; IntervalS = [int]$script:Num.Value; LangPref = $langPrefNow }
	}
	# Baseline corresponds to the loaded/last saved state
	$script:Baseline = & $script:GetPendingConfig
	$script:HasUnsavedChanges = { $now = & $script:GetPendingConfig; foreach ($k in $script:Baseline.Keys) { if ( ($script:Baseline[$k] -as [string]) -ne ($now[$k] -as [string]) ) { return $true } } return $false }
	# Toggle Save button depending on dirty state
	$script:UpdateSaveButton = { try { if ($script:ButtonSave) { $dirty = (& $script:HasUnsavedChanges); $script:ButtonSave.Enabled = $dirty } } catch {} }
	& $script:UpdateSaveButton # Initial state
	$script:SuppressUnsavedCheck = $false
	# Warning dialog when closing (Close/Esc/[X])
	$f.add_FormClosing({
		param($sender, $e)
		if ($script:SuppressUnsavedCheck) { return }
		$dirty = $false
		try { $dirty = & $script:HasUnsavedChanges } catch {}
		if (-not $dirty) { return }
		$res = Ask-YesNoCancelQuestT 'prompt.unsaved_changes'
		switch ($res) {
			([System.Windows.Forms.DialogResult]::Yes) {
				# Cancel this close, then trigger Save AFTER the handler returns
				$e.Cancel = $true; $script:SuppressUnsavedCheck = $true # prevent re-prompt
				$f.BeginInvoke([System.Action]{ try { $script:ButtonSave.PerformClick() } catch {} }) | Out-Null
			}
			([System.Windows.Forms.DialogResult]::No) { $e.Cancel = $false } # Discard changes and close
			default { $e.Cancel = $true } # Cancel -> stay in dialog
		}
	})
	# Button handlers
	$script:ButtonInstall.Add_Click({ Install-Self })
	# Suppress "unsaved changes" prompt only for uninstall flow
	$script:ButtonUninstall.Add_Click({
		$script:SuppressUnsavedCheck = $true # disable prompt
		try { Uninstall-Self } finally { $script:SuppressUnsavedCheck = $false } # re-enable only if we return (e.g., user canceled export prompts)
	})
	$script:ButtonExportConfig.Add_Click({ Export-InstalledConfig })
	$script:ButtonExportToPortable.Add_Click({ Export-To-Portable })
	$script:ButtonImportConfig.Add_Click({
		try {
			$dlg = New-Object System.Windows.Forms.OpenFileDialog
			$dlg.Title = (T 'title.import_config'); $dlg.Filter = 'JSON (*.json)|*.json'; $dlg.InitialDirectory = [Environment]::GetFolderPath('Desktop')
			if ($dlg.ShowDialog() -ne 'OK') { return }
			$json = Get-Content -Raw -Path $dlg.FileName | ConvertFrom-Json
			# Core fields
			foreach ($k in @('Server', 'User', 'SubPath', 'Drive', 'Label', 'IntervalS')) { if ($json.PSObject.Properties.Name -contains $k) { $State.$k = $json.$k } }
			# Optional password from installed export (DPAPI), fallback to "EncPass" for old files
			if (-not $PortableMode) {
				$dpapi = $null
				if ($json.PSObject.Properties.Name -contains 'DPAPI') { $dpapi = [string]$json.DPAPI }
				elseif ($json.PSObject.Properties.Name -contains 'EncPass') { $dpapi = [string]$json.EncPass } # backward compatibility
				if ($dpapi -ne $null) { $State.EncPass = $dpapi }
			}
			Save-Config # Persist imported values
			& $script:RebindUIFromState # Rebind UI from freshly persisted state (fills SubPath/Label etc.) and resets dirty baseline
			try { Refresh-NeedsSetup } catch {} # Recompute "needs setup" and then try to map immediately
			try { Ensure-MapMutex } catch {} # keeps your original mapping guard flow
			try { Update-TrayImmediate -TryMap } catch {}
			Show-InfoT 'message.config_imported' @{ path = $dlg.FileName }
		} catch { Show-ErrorT 'message.import_failed' @{ err = $_.Exception.Message } }
	})
	$script:ButtonSave.Add_Click({
		$savedOk = $false # prevent unsaved-prompt on intentional save-close
		$script:SuppressUnsavedCheck = $true
		try {
			$sel = [string]$script:ComboBoxDrive.SelectedItem
			if ([string]::IsNullOrWhiteSpace($script:TextServer.Text) -or [string]::IsNullOrWhiteSpace($script:TextUser.Text) -or -not ($sel -match '^[A-Za-z]:$')) { Show-InfoT 'message.fill_server_user_drive'; return }
			$usedNow = (Get-PSDrive -PSProvider FileSystem | Select-Object -Expand Name) | ForEach-Object { '{0}:' -f $_ }
			if ($sel -ne $State.Drive -and $usedNow -contains $sel) { Show-WarnT 'message.drive_already_in_use' @{ drive = $sel }; return }
			$oldServer = $State.Server
			$oldUser = $State.User
			$oldSubPath = $State.SubPath
			$oldDrive = $State.Drive
			$State.Server = $script:TextServer.Text.Trim()
			$State.User = $script:TextUser.Text.Trim()
			# --- collect and persist password first (supports both flows: Encrypt or Save-only) ---
			if ($PortableMode) {
				# If no secrets.dat yet but a password was typed, create it now via passphrase
				if ((-not (Test-Path $SecretPath)) -and $script:TextPassword.Text -and ($script:TextPassword.Tag -ne 'info')) {
					$pp = Prompt-Passphrase (T 'title.passphrase_set' @{ app = $AppName }) -Confirm
					if ([string]::IsNullOrWhiteSpace($pp)) { Show-InfoT 'message.passphrase_required'; return }
					try {
						# keep a local copy before clearing the textbox
						$pw = $script:TextPassword.Text
						Protect-PortableSecret $pw $pp $SecretPath
						# Keep plaintext for this session so Browse works without re-prompt
						$script:PlainPassCache = $pw
						$script:AskedPassphrase = $true
						$script:TextPassword.Text = ''
						# $script:TextPassword.Enabled = $false
					} catch { Show-ErrorT 'message.write_secret_failed' @{ err = $_.Exception.Message }; return }
				}
			# Installed: if user typed a new password, persist immediately (DPAPI)
			} elseif ($script:TextPassword.Text -and ($script:TextPassword.Tag -ne 'info')) { try { Set-PlainPassword $script:TextPassword.Text } catch { Show-ErrorT 'message.store_password_failed' @{ err = $_.Exception.Message }; return } }
			# --- normalize subpath from UI (read-only textbox filled by picker) ---
			$valSub = $script:TxtSub.Text.Trim()
			if ($valSub -eq '/') { $valSub = '' } else { $valSub = $valSub.Trim('/').Replace('\', '/') }
			# --- validate subpath existence via OCS (only when not empty) ---
			if (-not [string]::IsNullOrWhiteSpace($valSub)) {
				# Ensure portable passphrase if needed
				if ($PortableMode) { if (-not (Ensure-PortablePass -Interactive)) { return } }
				if (-not (Test-NcFolderExists $valSub)) { Show-WarnT 'message.folder_does_not_exist' @{ folder = $valSub }; return }
			}
			# now update State (safe)
			$State.SubPath = $valSub; $State.Drive = [string]$script:ComboBoxDrive.SelectedItem; $State.Label = $script:TxtDisp.Text; $State.IntervalS = [int]$script:Num.Value
			Write-Verbose ("[{0}:{1}] IntervalS = {2}" -f (Split-Path -Leaf $PSCommandPath), $MyInvocation.ScriptLineNumber, [int]$State.IntervalS)
			# Language preference from combo ("Auto" means unset)
			$langSel = [string]$script:ComboBoxLanguage.SelectedItem
			if ($langSel -and $langSel -ne 'Auto') { $State.LangPref = $langSel } else { $State.LangPref = '' }
			Save-Config
			& $script:RefreshExportButtons
			try { if ($script:timer) { $script:timer.Interval = [Math]::Max(5, [int]$State.IntervalS) * 1000 } } catch {}
			if (-not $PortableMode) {
				try { Set-StartupRunKey ($script:CheckboxAutostart.Checked) } catch {}
				try { Ensure-Shortcut 'StartMenu' ($script:CheckboxShortcutStartmenu.Checked) } catch {}
				try { Ensure-Shortcut 'Desktop' ($script:CheckboxShortcutDesktop.Checked) } catch {}
			}
			$driveChanged = ($oldDrive -and ($oldDrive -ne $State.Drive)); $subChanged = ($oldSubPath -ne $State.SubPath); $serverChanged = ($oldServer -ne $State.Server); $userChanged = ($oldUser -ne $State.User)
			if ($driveChanged -or $subChanged -or $serverChanged -or $userChanged) {
				# Acquire guard for the new drive *before* unmapping, so we can fail early
				if ($driveChanged -and (Test-ValidDrive $State.Drive)) {
					# Drop old guard and grab the new one
					try { Release-MutexSafe $script:driveMutex } catch {}
					# If acquiring the new one fails, abort save to keep app consistent
					$dGuardOk = $true
					try { Ensure-DriveGuard -Drive $State.Drive } catch { $dGuardOk = $false }
					if (-not $dGuardOk -or (-not $script:driveMutex)) { Show-WarnT 'message.drive_already_in_use_by_other_instance' @{ drive = $State.Drive; app = $AppName }; return }
				}
				# Avoid timer races during remap
				try { if ($script:timer) { $script:timer.Stop() } } catch {}
				# Fully unmap the old mapping (letter + UNC), and nudge the shell
				try { Unmap-DriveIfOurs -drive $oldDrive -Force -RemoveProfile -Server $oldServer -User $oldUser -SubPath $oldSubPath; try { Refresh-ExplorerDriveRemoval $oldDrive } catch {} } catch {}
				# Cooldown + ensure the letter is really gone
				[void](Wait-DriveFullyUnmapped -Drive $oldDrive -TimeoutMs 3000)
				# Now map fresh with the new state
				if (Map-Drive) {
					# Build localized tray text safely (no inline hashtable literal in the call site)
					Rebuild-Icons
					$varsOnline = @{ app = $AppName; drive = $State.Drive }
					$txtOnline = T 'tray.online' $varsOnline
					Set-TrayState -Icon $script:icoGre -Text $txtOnline
					try { Ensure-BrandingTick } catch {}
				} else {
					Rebuild-Icons
					$varsFail = @{ app = $AppName }
					$txtFail = T 'tray.mapping_failed' $varsFail
					Set-TrayState -Icon $script:icoRed -Text $txtFail
				}
				# Resume timer
				try { if ($script:timer) { $script:timer.Start() } } catch {} } else { try { Ensure-BrandingTick } catch {} } # Nothing critical changed -> only ensure branding (idempotent)
			Refresh-NeedsSetup
			Update-TrayImmediate -TryMap
			$script:Baseline = & $script:GetPendingConfig # refresh "last saved" snapshot
			$savedOk = $true
			$f.DialogResult = [Windows.Forms.DialogResult]::OK
			$f.Close()
		}
		finally { if (-not $savedOk) { $script:SuppressUnsavedCheck = $false } }
	})
	$script:ButtonClose1.Add_Click({ $f.DialogResult = [Windows.Forms.DialogResult]::Cancel; $f.Close() })
	$panelMain.Controls.AddRange(@(
		$script:LabelMode,
		$script:LabelServer, $script:PicFavicon, $script:TextServer,
		$script:LabelUser, $script:PicAvatar, $script:TextUser,
		$script:LabelPassword, $script:ButtonPasswordHelp, $script:TextPassword, $script:ButtonEncrypt,
		$script:LabelSubfolder, $script:TxtSub,
		$script:LabelDriveLetter, $script:ComboBoxDrive,
		$script:LabelDisplayName, $script:TxtDisp,
		$script:LabelCheckInterval, $script:Num, $script:LabelLanguage, $script:ComboBoxLanguage, $script:ButtonLanguageImport,
		$PanelCheckboxes, $PanelButtons1, $PanelButtons2
	))
	$panelFooter.Controls.AddRange(@($script:ButtonSave, $script:ButtonClose1))
	# Cleanup timers and images when dialog closes
	$f.add_FormClosed({
		param($sender, $e)
		try { if ($script:FaviconTimer) { $script:FaviconTimer.Stop(); $script:FaviconTimer.Dispose() } } catch {}
		try { if ($script:AvatarTimer) { $script:AvatarTimer.Stop(); $script:AvatarTimer.Dispose() } } catch {}
		try { if ($script:ServerScopeTimer) { $script:ServerScopeTimer.Stop(); $script:ServerScopeTimer.Dispose() } } catch {}
		# ensure WebClientRegTimer is fully stopped when settings dialog closes
		try { if ($script:WebClientRegTimer) { $script:WebClientRegTimer.Stop(); $script:WebClientRegTimer.Dispose() } } catch {}
		# ensure CacheAgentTimer is fully stopped when settings dialog closes
		try { if ($script:CacheAgentTimer) { $script:CacheAgentTimer.Stop(); $script:CacheAgentTimer.Dispose() } } catch {}
		# break default buttons link to the form (defuse lingering refs)
		try { $sender.AcceptButton = $null; $sender.CancelButton = $null } catch {}
		# Dispose only the PictureBox-held clones; do NOT dispose global server/avatar bitmaps.
		try { if ($script:PicFavicon -and $script:PicFavicon.Image) { $script:PicFavicon.Image.Dispose(); $script:PicFavicon.Image = $null } } catch {}
		try { if ($script:PicAvatar -and $script:PicAvatar.Image) { $script:PicAvatar.Image.Dispose(); $script:PicAvatar.Image = $null } } catch {}
		# fully detach tooltip associations before disposing it
		try { if ($script:Tip) { $script:Tip.RemoveAll() } } catch {}
		try { if ($script:Tip) { $script:Tip.Dispose(); $script:Tip = $null } } catch {}
		try { if ($script:CacheListEntryFont) { $script:CacheListEntryFont.Dispose(); $script:CacheListEntryFont = $null } } catch {}
		# drop script-scope helpers/closures so GC can collect them
		try {
			$script:ComputeDefaultLabel = $null
			$script:OpenSubfolderPicker = $null
			$script:RefreshPasswordState = $null
			$script:ApplyLanguageNow = $null
			$script:RefreshLangList = $null
			$script:RebuildDriveList = $null
			$script:GetPendingConfig = $null
			$script:HasUnsavedChanges = $null
			$script:UpdateSaveButton = $null
			$script:RebindUIFromState = $null
			$script:RefreshExportButtons = $null
			$script:BasicSettings_Auto = $null
			$script:BrowseState = $null
			$script:BasicSettingsStatuses = $null
			$script:UpdateCacheTotalLabel = $null
			$script:RenderCacheEntries = $null
			$script:RefreshCacheList = $null
			$script:UpdateCacheWatcherUi = $null
			$script:InvokeCacheDeleteAll = $null
			$script:InvokeCacheRefresh = $null
		} catch {}
		# encourage prompt collection of now-unrooted closures
		try { [System.GC]::Collect(); [System.GC]::WaitForPendingFinalizers() } catch {}
		try {
			$script:HostForm = $null
			$script:TextServer = $null; $script:TextUser = $null; $script:TxtSub = $null; $script:TextPassword = $null; $script:TxtDisp = $null
			$script:ComboBoxDrive = $null; $script:Num = $null; $script:ComboBoxLanguage = $null
			$script:ButtonPasswordHelp = $null; $script:ButtonEncrypt = $null; $script:ButtonLanguageImport = $null; $script:ButtonSave = $null; $script:ButtonClose1 = $null
			$script:PicFavicon = $null; $script:PicAvatar = $null
			$script:FaviconTimer = $null; $script:AvatarTimer = $null
			# drop WebClient tuning state so nothing pins the timer / closures
			$script:WebClientRegTimer = $null
			$script:CacheAgentTimer = $null
			$script:UpdateWebClientRegView = $null
			$script:UpdateWebClientApplyButton = $null
			$script:Tabs = $null
			$script:TabBasic = $null
			$script:TabTuning = $null
			$script:TabCache = $null
			$script:CacheListView = $null
			$script:CacheAgeNumeric = $null
			$script:ButtonCacheRefresh = $null
			$script:ButtonCacheDeleteAll = $null
			$script:Tabs = $null; $script:TabBasic = $null; $script:TabTuning = $null
		} catch {}
	})
}
# --- Broker: elevate once, apply registry values under HKLM and restart WebClient ---
function global:Invoke-WebClientWriteBroker {
	param([hashtable]$ValuesToSet)
	# Basic sanity check
	if (-not $ValuesToSet -or $ValuesToSet.Count -eq 0) { return $false }
	# Write JSON payload for the elevated helper
	$tmpJson = [System.IO.Path]::GetTempFileName().Replace('.tmp', '.json')
	($ValuesToSet | ConvertTo-Json -Depth 5) | Set-Content -LiteralPath $tmpJson -Encoding UTF8
	# Log file for debugging (persists across runs)
	$tmpLog = Join-Path $env:TEMP 'NcDavTray-WebClientBroker.log'
	$broker = @"
param([string]`$JsonPath, [string]`$LogPath)
`$ErrorActionPreference = 'Stop'
function Write-Log([string]`$m) { try { Add-Content -LiteralPath `$LogPath -Value ("[{0}] {1}" -f (Get-Date -Format 's'), `$m) } catch {} }
try {
	Write-Log 'Broker started'
	if (-not (Test-Path -LiteralPath `$JsonPath)) { Write-Log ("JSON not found: {0}" -f `$JsonPath); exit 2 }
	`$raw = ''
	try { `$raw = Get-Content -Raw -LiteralPath `$JsonPath; Write-Log ("JSON raw: {0}" -f `$raw) } catch { Write-Log ("Error reading JSON: {0}" -f `$_.Exception.Message); exit 2 }
	`$data = `$null
	# Use fully qualified cmdlet name to avoid alias/shadowing issues
	try { `$data = Microsoft.PowerShell.Utility\ConvertFrom-Json -InputObject `$raw } catch { Write-Log ("ConvertFrom-Json failed: {0}" -f `$_.Exception.Message); exit 2 }
	if (`$data -eq `$null) { Write-Log 'ConvertFrom-Json returned `$null'; exit 2 }
	# Dump JSON property names for debugging
	try { `$names = @(); foreach (`$p in `$data.PSObject.Properties) { `$names += `$p.Name }; Write-Log ("JSON props: {0}" -f ([string]::Join(', ', `$names))) } catch { Write-Log 'Warning: could not enumerate JSON properties' }
	`$keyReg = '$($RegWebClient -replace ':', '')'
	`$keyPs = '$RegWebClient'
	if (-not (Test-Path `$keyPs)) { Write-Log ("Create key: {0}" -f `$keyPs); New-Item -Path `$keyPs -Force | Out-Null }
	function Set-DWord([string]`$name, [object]`$valRaw) {
		`$val = 0
		try {
			if (`$valRaw -is [string]) { if ([string]::IsNullOrWhiteSpace(`$valRaw)) { `$val = 0 } else { `$val = [decimal]`$valRaw } } else { `$val = [decimal]`$valRaw }
		} catch { Write-Log ("Set-DWord {0}: parse error for value '{1}', forcing 0" -f `$name, `$valRaw); `$val = 0 }
		if (`$val -lt 0) { `$val = 0 }
		`$max = [decimal][uint32]::MaxValue
		if (`$val -gt `$max) { `$val = `$max }
		`$ival = [uint32][math]::Floor(`$val)
		Write-Log ("Set {0} = {1}" -f `$name, `$ival)
		& reg.exe ADD "`$keyReg" /v "`$name" /t REG_DWORD /d "`$ival" /f | Out-Null
	}
	`$startupType = `$null
	if (`$data.PSObject.Properties.Name -contains 'BasicAuthLevel') { `$bal = [long]`$data.BasicAuthLevel; if (`$bal -lt 0) { `$bal = 0 }; if (`$bal -gt 2) { `$bal = 2 }; Set-DWord 'BasicAuthLevel' `$bal }
	if (`$data.PSObject.Properties.Name -contains 'FileAttributesLimitInBytes') { Set-DWord 'FileAttributesLimitInBytes' `$data.FileAttributesLimitInBytes }
	if (`$data.PSObject.Properties.Name -contains 'FileSizeLimitInBytes') { Set-DWord 'FileSizeLimitInBytes' `$data.FileSizeLimitInBytes }
	if (`$data.PSObject.Properties.Name -contains 'LocalServerTimeoutInSec') { Set-DWord 'LocalServerTimeoutInSec' `$data.LocalServerTimeoutInSec }
	if (`$data.PSObject.Properties.Name -contains 'InternetServerTimeoutInSec') { Set-DWord 'InternetServerTimeoutInSec' `$data.InternetServerTimeoutInSec }
	if (`$data.PSObject.Properties.Name -contains 'SendReceiveTimeoutInSec') { Set-DWord 'SendReceiveTimeoutInSec' `$data.SendReceiveTimeoutInSec }
	if (`$data.PSObject.Properties.Name -contains 'ServerNotFoundCacheLifeTimeInSec') { Set-DWord 'ServerNotFoundCacheLifeTimeInSec' `$data.ServerNotFoundCacheLifeTimeInSec }
	# Optional: change startup type (Automatic / Manual / Disabled)
	if (`$data.PSObject.Properties.Name -contains 'StartupType') {
		try {
			`$startupType = [string]`$data.StartupType
			if ([string]::IsNullOrWhiteSpace(`$startupType)) { `$startupType = `$null }
		} catch {
			Write-Log ("StartupType parse failed: {0}" -f `$_.Exception.Message)
			`$startupType = `$null
		}
		if (`$startupType) {
			try {
				Write-Log ("Set start type: {0}" -f `$startupType)
				Set-Service -Name WebClient -StartupType `$startupType -ErrorAction Stop
			} catch { Write-Log ("Failed to set start type: {0}" -f `$_.Exception.Message) }
		}
	}
	try {
		Write-Log 'Restart WebClient service'
		Stop-Service WebClient -ErrorAction SilentlyContinue | Out-Null
		if (-not `$startupType -or (`$startupType -ne 'Disabled')) { Start-Service WebClient -ErrorAction SilentlyContinue | Out-Null }
	} catch { Write-Log ("Service restart error: {0}" -f `$_.Exception.Message) }
	Write-Log 'Broker success'; exit 0
}
catch { Write-Log ("Broker error: {0}" -f `$_.Exception.Message); exit 1 }
"@
	# Persist broker script
	$ps1 = [System.IO.Path]::GetTempFileName().Replace('.tmp', '.ps1')
	$broker | Set-Content -LiteralPath $ps1 -Encoding UTF8
	# Use 64-bit PowerShell when available
	$pwsh = Join-Path $env:WINDIR 'Sysnative\WindowsPowerShell\v1.0\powershell.exe'
	if (-not (Test-Path $pwsh)) { $pwsh = Join-Path $env:WINDIR 'System32\WindowsPowerShell\v1.0\powershell.exe' }
	$psi = New-Object System.Diagnostics.ProcessStartInfo
	$psi.FileName = $pwsh
	$psi.Arguments = "-NoLogo -NoProfile -NonInteractive -ExecutionPolicy Bypass -File `"$ps1`" -JsonPath `"$tmpJson`" -LogPath `"$tmpLog`""
	$psi.Verb = 'runas'
	$psi.UseShellExecute = $true
	$psi.WindowStyle = [System.Diagnostics.ProcessWindowStyle]::Hidden
	$psi.CreateNoWindow = $true
	$ok = $false
	try { $p = [System.Diagnostics.Process]::Start($psi); if ($p) { $p.WaitForExit(); if ($p.ExitCode -eq 0) { $ok = $true } } } catch { $ok = $false }
	Remove-Item -LiteralPath $ps1, $tmpJson -Force -ErrorAction SilentlyContinue
	return $ok
}
# Returns "Local", "Internet" or "Unknown"
function Get-ServerScope([string]$Server) {
	$Server = ($Server -as [string]).Trim()
	if (-not $Server) { return 'Unknown' }
	# Server is stored without scheme by design -> always treat as HTTPS URL
	$url = "https://$Server"; $uri = $null
	if (-not [System.Uri]::TryCreate($url, [System.UriKind]::Absolute, [ref]$uri)) { return 'Unknown' }
	try { $zone = [System.Security.Policy.Zone]::CreateFromUrl($uri.AbsoluteUri) } catch { return 'Unknown' }
	switch ($zone.SecurityZone) { 'MyComputer' { return 'Local' }; 'Intranet' { return 'Local' }; default { return 'Internet' } }
}
# Elevate and start/restart the WebClient service
function Invoke-WebClientServiceAction([ValidateSet('start', 'restart')][string]$Action, [switch]$NoWait) {
	$cmd = if ($Action -eq 'restart') {
		"try { Stop-Service WebClient -ErrorAction SilentlyContinue; Start-Service WebClient -ErrorAction Stop; exit 0 } catch { exit 1 }"
	} else {
		"try { Start-Service WebClient -ErrorAction Stop; exit 0 } catch { exit 1 }"
	}
	$pwsh = Join-Path $env:WINDIR 'Sysnative\WindowsPowerShell\v1.0\powershell.exe'
	if (-not (Test-Path $pwsh)) { $pwsh = Join-Path $env:WINDIR 'System32\WindowsPowerShell\v1.0\powershell.exe' }
	$psi = New-Object System.Diagnostics.ProcessStartInfo
	$psi.FileName = $pwsh; $psi.Arguments = "-NoLogo -NoProfile -NonInteractive -ExecutionPolicy Bypass -Command `"$cmd`""
	$psi.Verb = 'runas'; $psi.UseShellExecute = $true; $psi.WindowStyle = 'Hidden'; $psi.CreateNoWindow = $true
	try { $p = [Diagnostics.Process]::Start($psi); if ($NoWait) { return $true }; $p.WaitForExit(); return ($p.ExitCode -eq 0) } catch { return $false }
}
# Keeps script-level deactivated flag in sync with the current WebClient StartType
function Sync-WebClientDeactivatedFlag {
	param(
		[System.ServiceProcess.ServiceController]$Service
	)
	try {
		if (-not $Service) { $Service = Get-Service -Name WebClient -ErrorAction Stop }
		$startRaw = [string]$Service.StartType
		$script:ServiceDeactivated = ($startRaw -like 'Disabled*')
		return $Service
	} catch {
		# Missing or inaccessible service -> treat as deactivated
		$script:ServiceDeactivated = $true
		return $null
	}
}
function Get-WebClientTriggerInfoText {
	[CmdletBinding()] param([string]$ServiceName = 'WebClient', [ValidateSet('String','Window')] [string]$Output = 'String')
	try { $scOutput = & sc.exe qtriggerinfo $ServiceName 2>$null } catch { return $null }
	if (-not $scOutput) { return $null }
	$match = $scOutput | Select-String -Pattern '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}' -AllMatches | Select-Object -First 1
	if (-not $match -or -not $match.Matches.Count) { return $null }
	$uuid = $match.Matches[0].Value.ToLower()
	if (-not $uuid) { return $null }
	$name = $uuid
	try {
		$keyPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Publishers\{$uuid}"
		$val = (Get-Item $keyPath -ErrorAction Stop).GetValue('')
		if ($val) { $name = [string]$val }
	} catch {}
	if ($Output -eq 'Window') { Show-InfoT 'message.service_trigger_info' @{ name = $name; uuid = $uuid } } else { return "Trigger: $name ($uuid)" }
}
function Render-WebClientTuningTab([Parameter(Mandatory)][System.Windows.Forms.TabPage]$HostTab) {
	# --- Read current registry values (no elevation to read) ---
	$cur = try { Get-ItemProperty -Path $RegWebClient -ErrorAction Stop } catch { $null }
	$get = { param($n, $def) if ($cur -and ($cur.PSObject.Properties.Name -contains $n)) { [int64]$cur.$n } else { [int64]$def } }
	# Defaults from MS docs https://learn.microsoft.com/en-us/iis/publish/using-webdav/using-the-webdav-redirector#webdav-redirector-registry-settings
	$v_BasicAuthLevel = & $get 'BasicAuthLevel' 1 # 1 = Basic only over SSL (recommended)
	$v_FileSizeLimitInBytes = & $get 'FileSizeLimitInBytes' 52428800 # 50 MB default = 50000000
	$v_FileAttributesLimitInBytes = & $get 'FileAttributesLimitInBytes' 1048576 # 1 MB default = 1000000 (~1000 files)
	$v_LocalTimeoutInSec = & $get 'LocalServerTimeoutInSec' 15
	$v_InternetTimeoutInSec = & $get 'InternetServerTimeoutInSec' 30
	$v_SendReceiveTimeoutInSec = & $get 'SendReceiveTimeoutInSec' 60
	$v_NotFoundCacheLifetimeInSec = & $get 'ServerNotFoundCacheLifeTimeInSec' 60
	# --- Layout base ---
	$t = $HostTab
	$t.Controls.Clear()
	# Small helpers
	function Format-Bytes([long]$b) { if ($b -ge 1GB) { '{0:N1} GB' -f ($b/1GB) } elseif ($b -ge 1MB) { '{0:N0} MB' -f ($b/1MB) } else { '{0:N0} B' -f $b } }
	# --- Group: Authentication ---
	$grpAuth = New-Object Windows.Forms.Panel; $grpAuth.Left = 8; $grpAuth.Top = 8; $grpAuth.Width = $t.ClientSize.Width - 16; $grpAuth.Height = 40; $grpAuth.Anchor = 'Top, Left, Right'
	$lblBAL = $script:LabelBasicAuthLevel = New-Object Windows.Forms.Label; $lblBAL.Text = (T 'label.basic_auth_level'); $lblBAL.Left = 12; $lblBAL.Top = 8; $lblBAL.AutoSize = $true
	$cmbBAL = $script:ComboBoxBasicAuthLevel = New-Object Windows.Forms.ComboBox; $cmbBAL.Width = 340; $cmbBAL.Left = $grpAuth.Width - $cmbBAL.Width; $cmbBAL.Top = $lblBAL.Top - 4; $cmbBAL.DropDownStyle = 'DropDownList'; $cmbBAL.Anchor = 'Top, Right'
	$opt = @( @{ v = 0; s = (T 'combo.basic_auth_level_0') }, @{ v = 1; s = (T 'combo.basic_auth_level_1') }, @{ v = 2; s = (T 'combo.basic_auth_level_2') } )
	foreach($o in $opt) { [void]$cmbBAL.Items.Add($o.s) }
	# Preselect "1" as safe default (find index of option with v = = 1)
	$selectedIdx = 0; for ($i = 0; $i -lt $opt.Count; $i++) { if ([int]$opt[$i].v -eq 1) { $selectedIdx = $i; break } }
	# If registry has a specific value, prefer that when present in options
	$desired = 1; try { $desired = [int]$v_BasicAuthLevel } catch { $desired = 1 }
	for ($i = 0; $i -lt $opt.Count; $i++) { if ([int]$opt[$i].v -eq $desired) { $selectedIdx = $i; break } }
	$cmbBAL.SelectedIndex = $selectedIdx
	$script:Tip.SetToolTip($cmbBAL, (T 'tip.basic_auth'))
	$script:BalGuard = $false
	$cmbBAL.add_SelectedIndexChanged(({
		if ($script:BalGuard) { return }
		$idx = $this.SelectedIndex
		if ($idx -eq 0 -or $idx -eq 2) {
			$key = if ($idx -eq 0) { 'prompt.basic_auth_0_warning' } else { 'prompt.basic_auth_2_warning' }
			$ans = Ask-YesNoWarnT $key
			if ($ans -ne [System.Windows.Forms.DialogResult]::Yes) { $script:BalGuard = $true; $this.SelectedIndex = 1; $script:BalGuard = $false }
		}
		if ($script:UpdateWebClientApplyButton -is [scriptblock]) { & $script:UpdateWebClientApplyButton }
	}).GetNewClosure())
	$grpAuth.Controls.AddRange(@($lblBAL, $cmbBAL))
	$t.Controls.Add($grpAuth)
	# --- Group: Limits ---
	$grpLim = New-Object Windows.Forms.Panel; $grpLim.Left = 8; $grpLim.Top = $grpAuth.Bottom + 8; $grpLim.Width = $t.ClientSize.Width - 16; $grpLim.Height = 65; $grpLim.Anchor = 'Top, Left, Right'
	# FileAttributesLimit: map "files per folder" -> bytes (rule of thumb: ~1000 bytes per file)
	$lblFAL = $script:LabelFilesPerFolder = New-Object Windows.Forms.Label; $lblFAL.Text = (T 'label.file_attributes_limit'); $lblFAL.Left = 12; $lblFAL.Top = 4; $lblFAL.AutoSize = $true
	$numFiles = New-Object Windows.Forms.NumericUpDown; $numFiles.Left = $cmbBAL.Left + 80; $numFiles.Top = $lblFAL.Top - 2; $numFiles.Anchor = 'Top, Right'
	$numFiles.Minimum = 50; $numFiles.Maximum = 4294967295; $numFiles.Increment = 50; $numFiles.Width = 80
	# derive initial files-per-folder from current bytes (floor)
	$numFiles.Value = [decimal]([Math]::Max(50, [int]([double]$v_FileAttributesLimitInBytes / 1000)))
	$numFiles.add_ValueChanged({ if ($script:UpdateWebClientApplyButton -is [scriptblock]) { & $script:UpdateWebClientApplyButton } })
	# FileSizeLimit: slider-ish via discrete steps (human friendly)
	$lblFSL = New-Object Windows.Forms.Label; $lblFSL.Text = (T 'label.file_size_limit'); $lblFSL.Left = 12; $lblFSL.Top = 38; $lblFSL.AutoSize = $true
	$steps = @(50MB, 100MB, 200MB, 500MB, 1GB, 2GB, 4GB)
	$cmbFSL = New-Object Windows.Forms.ComboBox
	$cmbFSL.Left = $cmbBAL.Left + 80; $cmbFSL.Top = $lblFSL.Top - 4; $cmbFSL.Width = 80; $cmbFSL.DropDownStyle = 'DropDownList'; $cmbFSL.Anchor = 'Top, Right'
	foreach($s in $steps) { [void]$cmbFSL.Items.Add((Format-Bytes $s)) }
	$sel = $steps | Select-Object @{n = 'd'; e = { [math]::Abs($_ - $v_FileSizeLimitInBytes) }}, @{n = 'v'; e = {$_}} | Sort-Object d | Select-Object -First 1
	$cmbFSL.SelectedIndex = [Array]::IndexOf($steps, $sel.v)
	$cmbFSL.add_SelectedIndexChanged({ if ($script:UpdateWebClientApplyButton -is [scriptblock]) { & $script:UpdateWebClientApplyButton } })
	# current registry value labels for limits
	$script:lblFALCur = New-Object Windows.Forms.Label
	$script:lblFALCur.AutoSize = $true; $script:lblFALCur.Top = $lblFAL.Top; $script:lblFALCur.Left = $numFiles.Left + 100; $script:lblFALCur.Anchor = 'Top, Right'
	$script:lblFSLCur = New-Object Windows.Forms.Label
	$script:LabelFileSizeLimit = $lblFSL
	$script:lblFSLCur.AutoSize = $true; $script:lblFSLCur.Top = $lblFSL.Top; $script:lblFSLCur.Left = $script:lblFALCur.Left; $script:lblFSLCur.Anchor = 'Top, Right'
	$grpLim.Controls.AddRange(@($lblFAL, $numFiles, $lblFSL, $cmbFSL, $script:lblFALCur, $script:lblFSLCur))
	$t.Controls.Add($grpLim)
	# --- Group: Timeouts + zone ---
	$grpTo = New-Object Windows.Forms.Panel; $grpTo.Left = 8; $grpTo.Top = $grpLim.Bottom + 8; $grpTo.Width = $t.ClientSize.Width - 16; $grpTo.Height = 150; $grpTo.Anchor = 'Top, Left, Right'
	$lblSco = $script:LabelActiveScope = New-Object Windows.Forms.Label; $lblSco.Left = 4; $lblSco.Top = 0; $lblSco.AutoSize = $true; $lblSco.Visible = $false
	$script:UpdateActiveScopeLabel = {
		param($lbl)
		$server = $script:TextServer.Text
		if ([string]::IsNullOrWhiteSpace($server)) { $lbl.Visible = $false; return }
		# use unified status helper to ensure it is a Nextcloud server
		$orig = $State.Server
		$State.Server = $server
		try { $st = Get-NcServerStatus } catch { $st = $null }
		$State.Server = $orig
		if (-not $st -or -not $st.Reachable -or -not $st.Installed) { $lbl.Visible = $false; return }
		$zoneText = if ((Get-ServerScope $server) -eq 'Local') { (T 'label.active_scope_local') } else { (T 'label.active_scope_internet') }
		$lbl.Text = (T 'label.active_scope' @{ zone = $zoneText })
		$lbl.Visible = $true
	}
	$lblLoc = $script:LabelLocalServerTimeout = New-Object Windows.Forms.Label; $lblLoc.Text = (T 'label.local_server_timeout'); $lblLoc.Left = 12; $lblLoc.Top = 30; $lblLoc.AutoSize = $true
	$btnHelpLoc = $script:ButtonLocalServerTimeoutHelp = New-Object Windows.Forms.Button; $btnHelpLoc.Text = '?'; $btnHelpLoc.Width = 28; $btnHelpLoc.Left = $cmbBAL.Left + 80; $btnHelpLoc.Top = $lblLoc.Top - 6; $btnHelpLoc.Height = $script:ButtonH; $btnHelpLoc.Anchor = 'Top, Right'
	if ($script:Tip) { $script:Tip.SetToolTip($btnHelpLoc, (T 'tip.local_server_timeout_help')) }
	$btnHelpLoc.Add_Click({ $parent = $this.FindForm(); [void](Show-HelpT -TitleKey 'label.local_server_timeout' -BodyKey 'message.local_server_timeout_help' -Width 580 -Height 270 -Parent $parent) })
	$numLoc = New-Object Windows.Forms.NumericUpDown; $numLoc.Left = $btnHelpLoc.Left + 32; $numLoc.Top = $lblLoc.Top - 2; $numLoc.Minimum = 5; $numLoc.Maximum = 600; $numLoc.Value = $v_LocalTimeoutInSec; $numLoc.Width = 80 - 32; $numLoc.Anchor = 'Top, Right'
	$lblInt = $script:LabelInternetServerTimeout = New-Object Windows.Forms.Label; $lblInt.Text = (T 'label.internet_server_timeout'); $lblInt.Left = 12; $lblInt.Top = 60; $lblInt.AutoSize = $true
	$btnHelpInt = $script:ButtonInternetServerTimeoutHelp = New-Object Windows.Forms.Button; $btnHelpInt.Text = '?'; $btnHelpInt.Width = 28; $btnHelpInt.Left = $btnHelpLoc.Left; $btnHelpInt.Top = $lblInt.Top - 6; $btnHelpInt.Height = $script:ButtonH; $btnHelpInt.Anchor = 'Top, Right'
	if ($script:Tip) { $script:Tip.SetToolTip($btnHelpInt, (T 'tip.internet_server_timeout_help')) }
	$btnHelpInt.Add_Click({ $parent = $this.FindForm(); [void](Show-HelpT -TitleKey 'label.internet_server_timeout' -BodyKey 'message.internet_server_timeout_help' -Width 580 -Height 270 -Parent $parent) })
	$numInt = New-Object Windows.Forms.NumericUpDown; $numInt.Left = $btnHelpInt.Left + 32; $numInt.Top = $lblInt.Top - 2; $numInt.Minimum = 5; $numInt.Maximum = 1800; $numInt.Value = $v_InternetTimeoutInSec; $numInt.Width = 80 - 32; $numInt.Anchor = 'Top, Right'
	$lblSR = $script:LabelSendReceiveTimeout = New-Object Windows.Forms.Label; $lblSR.Text = (T 'label.send_receive_timeout'); $lblSR.Left = 12; $lblSR.Top = 90; $lblSR.AutoSize = $true
	$btnHelpSR = $script:ButtonSendReceiveTimeoutHelp = New-Object Windows.Forms.Button; $btnHelpSR.Text = '?'; $btnHelpSR.Width = 28; $btnHelpSR.Left = $btnHelpLoc.Left; $btnHelpSR.Top = $lblSR.Top - 6; $btnHelpSR.Height = $script:ButtonH; $btnHelpSR.Anchor = 'Top, Right'
	if ($script:Tip) { $script:Tip.SetToolTip($btnHelpSR, (T 'tip.send_receive_timeout_help')) }
	$btnHelpSR.Add_Click({ $parent = $this.FindForm(); [void](Show-HelpT -TitleKey 'label.send_receive_timeout' -BodyKey 'message.send_receive_timeout_help' -Width 580 -Height 270 -Parent $parent) })
	$numSR = New-Object Windows.Forms.NumericUpDown; $numSR.Left = $btnHelpSR.Left + 32; $numSR.Top = $lblSR.Top - 2; $numSR.Minimum = 5; $numSR.Maximum = 1800; $numSR.Value = $v_SendReceiveTimeoutInSec; $numSR.Width = 80 - 32; $numSR.Anchor = 'Top, Right'
	$lblC = $script:LabelServerNotFoundCacheLifeTime = New-Object Windows.Forms.Label; $lblC.Text = (T 'label.server_not_found_cache_lifetime'); $lblC.Left = 12; $lblC.Top = 120; $lblC.AutoSize = $true
	$btnHelpC = $script:ButtonServerNotFoundCacheLifeTimeHelp = New-Object Windows.Forms.Button; $btnHelpC.Text = '?'; $btnHelpC.Width = 28; $btnHelpC.Left = $btnHelpLoc.Left; $btnHelpC.Top = $lblC.Top - 6; $btnHelpC.Height = $script:ButtonH; $btnHelpC.Anchor = 'Top, Right'
	if ($script:Tip) { $script:Tip.SetToolTip($btnHelpC, (T 'tip.server_not_found_cache_lifetime_help')) }
	$btnHelpC.Add_Click({ $parent = $this.FindForm(); [void](Show-HelpT -TitleKey 'label.server_not_found_cache_lifetime' -BodyKey 'message.server_not_found_cache_lifetime_help' -Width 580 -Height 330 -Parent $parent) })
	$numC = New-Object Windows.Forms.NumericUpDown; $numC.Left = $btnHelpC.Left + 32; $numC.Top = $lblC.Top - 2; $numC.Minimum = 5; $numC.Maximum = 86400; $numC.Value = $v_NotFoundCacheLifetimeInSec; $numC.Width = 80 - 32; $numC.Anchor = 'Top, Right'
	$numLoc.add_ValueChanged({ if ($script:UpdateWebClientApplyButton -is [scriptblock]) { & $script:UpdateWebClientApplyButton } })
	$numInt.add_ValueChanged({ if ($script:UpdateWebClientApplyButton -is [scriptblock]) { & $script:UpdateWebClientApplyButton } })
	$numSR.add_ValueChanged({ if ($script:UpdateWebClientApplyButton -is [scriptblock]) { & $script:UpdateWebClientApplyButton } })
	$numC.add_ValueChanged({ if ($script:UpdateWebClientApplyButton -is [scriptblock]) { & $script:UpdateWebClientApplyButton } })
	# current registry value labels for timeouts
	$script:LabelLocalServerTimeoutCur = New-Object Windows.Forms.Label; $script:LabelLocalServerTimeoutCur.AutoSize = $true; $script:LabelLocalServerTimeoutCur.Top = $lblLoc.Top; $script:LabelLocalServerTimeoutCur.Left = $script:lblFALCur.Left; $script:LabelLocalServerTimeoutCur.Anchor = 'Top, Right'
	$script:LabelInternetServerTimeoutCur = New-Object Windows.Forms.Label; $script:LabelInternetServerTimeoutCur.AutoSize = $true; $script:LabelInternetServerTimeoutCur.Top = $lblInt.Top; $script:LabelInternetServerTimeoutCur.Left = $script:lblFALCur.Left; $script:LabelInternetServerTimeoutCur.Anchor = 'Top, Right'
	$script:LabelSendReceiveTimeoutCur = New-Object Windows.Forms.Label; $script:LabelSendReceiveTimeoutCur.AutoSize = $true; $script:LabelSendReceiveTimeoutCur.Top = $lblSR.Top; $script:LabelSendReceiveTimeoutCur.Left = $script:lblFALCur.Left; $script:LabelSendReceiveTimeoutCur.Anchor = 'Top, Right'
	$script:LabelServerNotFoundCacheLifeTimeCur = New-Object Windows.Forms.Label; $script:LabelServerNotFoundCacheLifeTimeCur.AutoSize = $true; $script:LabelServerNotFoundCacheLifeTimeCur.Top = $lblC.Top; $script:LabelServerNotFoundCacheLifeTimeCur.Left = $script:lblFALCur.Left; $script:LabelServerNotFoundCacheLifeTimeCur.Anchor = 'Top, Right'
	$grpTo.Controls.AddRange(@(
		$lblSco,
		$lblLoc, $btnHelpLoc, $numLoc, $script:LabelLocalServerTimeoutCur,
		$lblInt, $btnHelpInt, $numInt, $script:LabelInternetServerTimeoutCur,
		$lblSR, $btnHelpSR, $numSR, $script:LabelSendReceiveTimeoutCur,
		$lblC, $btnHelpC, $numC, $script:LabelServerNotFoundCacheLifeTimeCur
	))
	try { & $script:UpdateActiveScopeLabel $lblSco } catch { $lblSco.Visible = $false }
	$t.Controls.Add($grpTo)
	# --- Group: WebClient service ---
	$grpSvc = New-Object Windows.Forms.Panel; $grpSvc.Left = 8; $grpSvc.Top = $grpTo.Bottom + 8; $grpSvc.Width = $t.ClientSize.Width - 16; $grpSvc.Height = 78; $grpSvc.Anchor = 'Top, Left, Right'
	$lblSvc = $script:LabelServiceStatus = New-Object Windows.Forms.Label
	$lblSvc.Left = 12; $lblSvc.Top = 8; $lblSvc.AutoSize = $true; $lblSvc.Anchor = 'Top, Left'
	$lblSvc.Padding = New-Object System.Windows.Forms.Padding(0,0,22,0) # reserve some space for LED
	$lblSvc.Text = (T 'label.service_status')
	# draw traffic-light LED after the label text
	$lblSvc.add_Paint({
		param($sender, $e)
		try {
			$lbl = [System.Windows.Forms.Label]$sender; $g = $e.Graphics; $text = $lbl.Text
			if ([string]::IsNullOrEmpty($text)) { return }
			# measure text in current font
			$textSize = $g.MeasureString($text, $lbl.Font)
			# LED size
			$diam = [float]([Math]::Ceiling($lbl.Font.Height * 0.85))
			$y = ($lbl.Height - $diam) / 2 - 1 # move LED a bit up
			# a bit more distance from text
			$x = [Math]::Ceiling($textSize.Width) + 8
			if ($x + $diam -gt $lbl.Width) { $x = $lbl.Width - $diam - 2 }
			# colors from Tag (SetWebClientStatusLabel)
			$fillColor = [System.Drawing.Color]::DarkGray
			$borderColor = [System.Drawing.Color]::Black
			$state = $null
			if ($lbl.Tag) { if ($lbl.Tag.Color) { $fillColor = $lbl.Tag.Color }; if ($lbl.Tag.BorderColor) { $borderColor = $lbl.Tag.BorderColor }; if ($lbl.Tag.State) { $state = $lbl.Tag.State } }
			$g.SmoothingMode = [System.Drawing.Drawing2D.SmoothingMode]::AntiAlias
			# filled LED
			$brushDot = New-Object System.Drawing.SolidBrush($fillColor); $g.FillEllipse($brushDot, $x, $y, $diam, $diam); $brushDot.Dispose()
			# outline so it is clearly visible
			$penBorder = New-Object System.Drawing.Pen($borderColor, 1.2); $g.DrawEllipse($penBorder, $x, $y, $diam, $diam); $penBorder.Dispose()
			# for "<not found>" draw a white cross inside the red LED
			if ($state -eq '<not found>') {
				$penX = New-Object System.Drawing.Pen([System.Drawing.Color]::White, 1.4)
				$margin = 3
				$g.DrawLine($penX, $x + $margin, $y + $margin, $x + $diam - $margin, $y + $diam - $margin)
				$g.DrawLine($penX, $x + $diam - $margin, $y + $margin, $x + $margin, $y + $diam - $margin)
				$penX.Dispose()
			}
		} catch {}
	})
	$lblST = $script:LabelServiceStartType = New-Object Windows.Forms.Label; $lblST.Text = (T 'label.service_starttype')
	$lblST.Left = $cmbBAL.Left - 55; $lblST.Top = $lblSvc.Top; $lblST.AutoSize = $true; $lblST.Anchor = 'Top, Right'
	# Trigger info button below start type
	$btnTrig = $script:ButtonServiceTriggerInfo = New-Object Windows.Forms.Button; $btnTrig.Text = (T 'button.triggerinfo')
	$btnTrig.Width = 170; $btnTrig.Height = $script:ButtonH; $btnTrig.Left = $grpSvc.Width - $btnTrig.Width; $btnTrig.Top = $lblSvc.Top - 6; $btnTrig.Anchor = 'Top, Right'
	$btnTrig.Visible = $false
	$btnTrig.Add_Click({ Get-WebClientTriggerInfoText -ServiceName 'WebClient' -Output 'Window' })
	# Startup type combo (Automatic / Manual / Disabled)
	$cmbSvc = $script:ComboServiceStartType = New-Object Windows.Forms.ComboBox
	$cmbSvc.Left = $cmbBAL.Left + 60; $cmbSvc.Width = $btnTrig.Left - $cmbSvc.Left - 10; $cmbSvc.Top = $lblSvc.Top - 4
	$cmbSvc.DropDownStyle = 'DropDownList'; $cmbSvc.Anchor = 'Top, Right'
	# Fixed order: 0 = Automatic, 1 = Manual, 2 = Disabled
	[void]$cmbSvc.Items.Add((T 'combo.webclient_start_automatic'))
	[void]$cmbSvc.Items.Add((T 'combo.webclient_start_manual'))
	[void]$cmbSvc.Items.Add((T 'combo.webclient_start_disabled'))
	$script:SvcStartPrevIdx = 0
	$cmbSvc.add_SelectedIndexChanged({
		$idx = $this.SelectedIndex
		# Determine current real service start type
		$startIsDisabled = $false
		try { $svc = Get-Service -Name WebClient -ErrorAction Stop; $startRaw = [string]$svc.StartType; if ($startRaw -like 'Disabled*') { $startIsDisabled = $true } } catch { $startIsDisabled = $false }
		if ($idx -eq 2) {
			# Only warn if the IS state is NOT already Disabled
			if (-not $startIsDisabled) {
				$ans = Ask-YesNoWarnT 'prompt.start_disabled_warn'
				# Revert to previous index
				if ($ans -ne [System.Windows.Forms.DialogResult]::Yes) { if ($script:SvcStartPrevIdx -ge 0 -and $script:SvcStartPrevIdx -lt $this.Items.Count) { $this.SelectedIndex = $script:SvcStartPrevIdx }; return }
			}
			$script:SvcStartPrevIdx = $idx
		} else { $script:SvcStartPrevIdx = $idx }
		if ($script:UpdateWebClientApplyButton -is [scriptblock]) { & $script:UpdateWebClientApplyButton }
	}.GetNewClosure())
	# Buttons share the same position and toggle visibility depending on service state
	$btnSvcRestart = $script:ButtonServiceRestart = New-Object Windows.Forms.Button; $btnSvcRestart.Text = (T 'button.restart_service'); $btnSvcRestart.Top = 38; $btnSvcRestart.Left = 12; $btnSvcRestart.Height = $script:UacButtonH; $btnSvcRestart.AutoSize = $true; $btnSvcRestart.AutoSizeMode = [System.Windows.Forms.AutoSizeMode]::GrowAndShrink
	$btnSvcStart = $script:ButtonServiceStart = New-Object Windows.Forms.Button; $btnSvcStart.Text = (T 'button.start_service'); $btnSvcStart.Top = 38; $btnSvcStart.Left = 12; $btnSvcStart.Height = $script:UacButtonH; $btnSvcStart.AutoSize = $true; $btnSvcStart.AutoSizeMode = [System.Windows.Forms.AutoSizeMode]::GrowAndShrink
	$grpSvc.Controls.AddRange(@($lblSvc, $lblST, $cmbSvc, $btnTrig, $btnSvcRestart, $btnSvcStart))
	$t.Controls.Add($grpSvc)
	# --- script-scoped async invoker with live polling (no extra runspace) ---
	$script:InvokeWebClientActionAsync = {
		param([ValidateSet('start', 'restart')][string]$Action)
		# mark that we are driving the service state ourselves
		$script:SvcActionPending = $true
		# immediate visual feedback (safe guards)
		if ($script:SetWebClientStatusLabel -is [scriptblock]) { $st = if ($Action -eq 'restart') { 'StopPending' } else { 'StartPending' }; & $script:SetWebClientStatusLabel $st }
		if ($script:ButtonServiceStart -is [Windows.Forms.Button] -and -not $script:ButtonServiceStart.IsDisposed) { $script:ButtonServiceStart.Visible = $false }
		if ($script:ButtonServiceRestart -is [Windows.Forms.Button] -and -not $script:ButtonServiceRestart.IsDisposed) { $script:ButtonServiceRestart.Visible = $false }
		# live polling while elevated action runs
		$poll = New-Object System.Windows.Forms.Timer; $poll.Interval = 300
		$poll.add_Tick({
			try {
				$st = (Get-Service -Name WebClient -ErrorAction Stop).Status.ToString()
				if ($script:SetWebClientStatusLabel -is [scriptblock]) { & $script:SetWebClientStatusLabel $st }
			} catch { if ($script:SetWebClientStatusLabel -is [scriptblock]) { & $script:SetWebClientStatusLabel '<not found>' } }
		})
		$poll.Start()
		# launch elevation without waiting (lets UAC appear; UI stays responsive)
		$launched = Invoke-WebClientServiceAction $Action -NoWait
		if (-not $launched) {
			try { $poll.Stop(); $poll.Dispose() } catch {}
			$script:SvcActionPending = $false
			& $script:UpdateSvc
			try { Show-ErrorT 'message.uac_admin_required' } catch {}
			return
		}
		# stop polling when state stabilizes
		$stopper = New-Object System.Windows.Forms.Timer; $stopper.Interval = 1000
		$stopper.add_Tick({
			try {
				$st = (Get-Service -Name WebClient -ErrorAction Stop).Status
				if ($st -in [System.ServiceProcess.ServiceControllerStatus]::Running, [System.ServiceProcess.ServiceControllerStatus]::Stopped) {
					try { if ($poll) { $poll.Stop(); $poll.Dispose(); $poll = $null } } catch {}
					try { if ($stopper) { $stopper.Stop(); $stopper.Dispose(); $stopper = $null } } catch {}
					$script:SvcActionPending = $false
					& $script:UpdateSvc
				}
			} catch {
				try { if ($poll) { $poll.Stop(); $poll.Dispose(); $poll = $null } } catch {}
				try { if ($stopper) { $stopper.Stop(); $stopper.Dispose(); $stopper = $null } } catch {}
				$script:SvcActionPending = $false
				& $script:UpdateSvc
			}
		})
		$stopper.Start()
	}
	# small helper: map WebClient state to LED color + tooltip
	$script:SetWebClientStatusLabel = {
		param([string]$stateText)
		try {
			if ($script:LabelServiceStatus -is [Windows.Forms.Label] -and -not $script:LabelServiceStatus.IsDisposed) {
				# saturated LED colors
				$greenFill = [System.Drawing.Color]::FromArgb(0, 255, 0); $greenBorder = [System.Drawing.Color]::FromArgb(0, 120, 0)
				$redFill = [System.Drawing.Color]::FromArgb(255, 0, 0); $redBorder = [System.Drawing.Color]::FromArgb(120, 0, 0)
				$orangeFill = [System.Drawing.Color]::FromArgb(255, 165, 0); $orangeBorder = [System.Drawing.Color]::FromArgb(180, 90, 0)
				$defaultBorder = [System.Drawing.Color]::FromArgb(40, 40, 40); $fillColor = [System.Drawing.Color]::DarkGray; $borderColor = $defaultBorder
				switch ($stateText) {
					'Running' { $fillColor = $greenFill; $borderColor = $greenBorder; break; }
					'Stopped' { $fillColor = $redFill; $borderColor = $redBorder; break }
					'<not found>' { $fillColor = $redFill; $borderColor = $redBorder; break }
					default { if ($stateText -like '*Pending' -or $stateText -eq 'Paused') { $fillColor = $orangeFill; $borderColor = $orangeBorder } break }
				}
				# store for Paint handler
				$script:LabelServiceStatus.Tag = [pscustomobject]@{ Color = $fillColor; BorderColor = $borderColor; State = $stateText }
				$script:LabelServiceStatus.Invalidate()
				# localized status text for tooltip
				$locStatus = switch ($stateText) { 'Running' { T 'status.running' }; 'Stopped' { T 'status.stopped' }; '<not found>' { T 'status.not_found' }; default { T 'status.pending' } }
				# tooltip shows full localized state text
				if ($script:Tip) { $script:Tip.SetToolTip( $script:LabelServiceStatus, (T 'tip.service_status' @{ status = $locStatus }) ) }
			}
		} catch {}
	}
	$script:UpdateSvc = {
		try {
			# Sync script-level flag and reuse returned service object
			$s = Sync-WebClientDeactivatedFlag
			if (-not $s) { throw 'WebClient service not available' }
			$state = [string]$s.Status
			$startRaw = [string]$s.StartType; $startMode = 'Manual'
			# Normalize startup mode to Automatic / Manual / Disabled
			switch -Regex ($startRaw) { '^Automatic' { $startMode = 'Automatic'; break }; '^Disabled' { $startMode = 'Disabled'; break }; default { $startMode = 'Manual'; break } }
			# Status label with placeholder (centralized helper)
			if ($script:SetWebClientStatusLabel -is [scriptblock]) { & $script:SetWebClientStatusLabel $state }
			# Startup-type combo + trigger button visibility
			if ($cmbSvc -and -not $cmbSvc.IsDisposed) {
				$hasTrigger = Test-Path $($RegWebClient -replace 'Parameters', 'TriggerInfo')
				if ($btnTrig -and -not $btnTrig.IsDisposed) { $btnTrig.Visible = $hasTrigger }
				# Map normalized start mode to fixed index: 0 = Automatic, 1 = Manual, 2 = Disabled
				$idx = switch ($startMode) { 'Automatic' { 0 }; 'Disabled' { 2 }; default { 1 } }
				if ($idx -ge 0 -and $idx -lt $cmbSvc.Items.Count) { $cmbSvc.SelectedIndex = $idx; $script:SvcStartPrevIdx = $idx } else { $cmbSvc.SelectedIndex = -1 }
			}
			# Keep global "service deactivated" flag in sync with startup mode
			$wasDeactivated = [bool]$script:ServiceDeactivated
			$nowDeactivated = ($startMode -eq 'Disabled')
			$script:ServiceDeactivated = $nowDeactivated
			if ($nowDeactivated -and -not $wasDeactivated) {
				# Service has just been disabled -> unmap drive and show dedicated tray state
				try { Unmap-DriveIfOurs -Force -RemoveProfile } catch {}
				try { if ($script:tray) { $script:tray.Icon = $script:icoWarn; $script:tray.Text = T 'tray.service_deactivated' @{ app = $AppName } } } catch {}
			}
			# Service control buttons: respect StartType
			if ($script:ButtonServiceStart -is [Windows.Forms.Button] -and -not $script:ButtonServiceStart.IsDisposed) {
				# Show Start but gray it out while service is disabled
				if ($startMode -eq 'Disabled') { $script:ButtonServiceStart.Visible = $true; $script:ButtonServiceStart.Enabled = $false }
				else { $script:ButtonServiceStart.Visible = ($state -ne 'Running'); $script:ButtonServiceStart.Enabled = $true }
			}
			if ($script:ButtonServiceRestart -is [Windows.Forms.Button] -and -not $script:ButtonServiceRestart.IsDisposed) {
				# No restart when the service is disabled
				if ($startMode -eq 'Disabled') { $script:ButtonServiceRestart.Visible = $false } else { $script:ButtonServiceRestart.Visible = ($state -eq 'Running') }
			}
		}
		catch {
			if ($script:SetWebClientStatusLabel -is [scriptblock]) { & $script:SetWebClientStatusLabel '<not found>' }
			if ($cmbSvc -and -not $cmbSvc.IsDisposed) { $cmbSvc.SelectedIndex = -1 }
			if ($script:ButtonServiceStart -is [Windows.Forms.Button] -and -not $script:ButtonServiceStart.IsDisposed) { $script:ButtonServiceStart.Visible = $true; $script:ButtonServiceStart.Enabled = $false }
			if ($script:ButtonServiceRestart -is [Windows.Forms.Button] -and -not $script:ButtonServiceRestart.IsDisposed) { $script:ButtonServiceRestart.Visible = $false }
		}
	}
	# --- Footer: Apply (admin) left of Close ---
	$footer = New-Object Windows.Forms.Panel; $footer.Dock = 'Bottom'; $footer.Height = $script:UacFooterH
	$t.Controls.Add($footer)
	$btnClose = $script:ButtonClose2 = New-Object Windows.Forms.Button; $btnClose.Text = (T 'button.close')
	$btnClose.Width = 100; $btnClose.Left = $footer.ClientSize.Width - $btnClose.Width - 2; $btnClose.Height = $script:ButtonXH; $btnClose.Top = [int]($script:UacButtonH - $btnClose.Height); $btnClose.Anchor = 'Top, Right'
	$btnApply = $script:ButtonApplyAsAdmin = New-Object Windows.Forms.Button; $btnApply.Text = (T 'button.uac_apply_changes')
	$btnApply.AutoSize = $true; $btnApply.AutoSizeMode = [System.Windows.Forms.AutoSizeMode]::GrowAndShrink
	$btnApply.Left = $btnClose.Left - $btnApply.Width - 10; $btnApply.Height = $script:UacButtonH; $btnApply.Anchor = 'Top, Right'
	$footer.Controls.AddRange(@($btnApply, $btnClose))
	# Dirty tracking: compare live registry values with current UI values
	$script:UpdateWebClientApplyButton = {
		try {
			if (-not $btnApply -or $btnApply.IsDisposed) { return }
			# Read current registry snapshot
			try { $curNow = Get-ItemProperty -Path $RegWebClient -ErrorAction Stop } catch { $curNow = $null }
			$raw = { param($n, $def, $src); if ($src -and ($src.PSObject.Properties.Name -contains $n)) { try { return [int64]$src.$n } catch { return $def } }; return $def }
			$maxDword = [uint32]::MaxValue
			# Service startup type (service side)
			$startReg = $null
			try {
				$s = Get-Service -Name WebClient -ErrorAction Stop
				$startRaw = [string]$s.StartType
				switch -Regex ($startRaw) { '^Automatic' { $startReg = 'Automatic'; break }; '^Disabled' { $startReg = 'Disabled'; break }; default { $startReg = 'Manual'; break } }
			} catch { $startReg = $null }
			# Registry side (canonical 32-bit range)
			$balReg = [int] (& $raw 'BasicAuthLevel' $v_BasicAuthLevel $curNow)
			$attrReg = [int64] (& $raw 'FileAttributesLimitInBytes' $v_FileAttributesLimitInBytes $curNow)
			if ($attrReg -gt $maxDword) { $attrReg = [int64]$maxDword }
			$sizeReg = [int64] (& $raw 'FileSizeLimitInBytes' $v_FileSizeLimitInBytes $curNow)
			if ($sizeReg -gt $maxDword) { $sizeReg = [int64]$maxDword }
			$locReg = [int] (& $raw 'LocalServerTimeoutInSec' $v_LocalTimeoutInSec $curNow)
			$intReg = [int] (& $raw 'InternetServerTimeoutInSec' $v_InternetTimeoutInSec $curNow)
			$srReg = [int] (& $raw 'SendReceiveTimeoutInSec' $v_SendReceiveTimeoutInSec $curNow)
			$nfReg = [int] (& $raw 'ServerNotFoundCacheLifeTimeInSec' $v_NotFoundCacheLifetimeInSec $curNow)
			# UI side (same canonical space)
			$balUi = 1
			if ($cmbBAL.SelectedIndex -ge 0) { $balUi = @(0,1,2)[$cmbBAL.SelectedIndex] }
			$attrUi = [int64]$numFiles.Value * 1000
			if ($attrUi -gt $maxDword) { $attrUi = [int64]$maxDword }
			if ($cmbFSL.SelectedIndex -ge 0) { $sizeUi = [int64]$steps[$cmbFSL.SelectedIndex] } else { $sizeUi = [int64]$steps[0] }
			if ($sizeUi -gt $maxDword) { $sizeUi = [int64]$maxDword }
			$locUi = [int]$numLoc.Value; $intUi = [int]$numInt.Value; $srUi = [int]$numSR.Value; $nfUi = [int]$numC.Value
			# Startup type from UI combo (fixed index mapping)
			$startUi = $null
			if ($cmbSvc -and -not $cmbSvc.IsDisposed -and $cmbSvc.SelectedIndex -ge 0) { $idxStart = $cmbSvc.SelectedIndex; $startUi = switch ($idxStart) { 0 { 'Automatic' }; 1 { 'Manual' }; 2 { 'Disabled' }; default { $null } } }
			$dirty = $false
			if ($balReg -ne $balUi) { $dirty = $true } elseif ($attrReg -ne $attrUi) { $dirty = $true } elseif ($sizeReg -ne $sizeUi) { $dirty = $true } elseif ($locReg -ne $locUi) { $dirty = $true } elseif ($intReg -ne $intUi) { $dirty = $true } elseif ($srReg -ne $srUi) { $dirty = $true } elseif ($nfReg -ne $nfUi) { $dirty = $true }
			elseif ($startReg -ne $startUi -and $startReg -ne $null -and $startUi -ne $null) { $dirty = $true }
			$btnApply.Enabled = $dirty
		} catch {}
	}.GetNewClosure()
	# Initial evaluation
	if ($script:UpdateWebClientApplyButton -is [scriptblock]) { & $script:UpdateWebClientApplyButton }
	$null = $btnSvcStart.Handle; Enable-UacShield $btnSvcStart; $null = $btnSvcRestart.Handle; Enable-UacShield $btnSvcRestart; $null = $btnApply.Handle; Enable-UacShield $btnApply
	# updater (script-scoped so event handlers can call it later)
	$btnSvcStart.Add_Click({ & $script:InvokeWebClientActionAsync -Action 'start' })
	$btnSvcRestart.Add_Click({ & $script:InvokeWebClientActionAsync -Action 'restart' })
	& $script:UpdateSvc
	# Live registry view for raw values (hex / dec)
	if ($script:WebClientRegTimer) { try { $script:WebClientRegTimer.Stop(); $script:WebClientRegTimer.Dispose() } catch {}; $script:WebClientRegTimer = $null }
	$script:UpdateWebClientRegView = {
		try { $curNow = Get-ItemProperty -Path $RegWebClient -ErrorAction Stop } catch { $curNow = $null }
		$raw = { param($n, $def, $src); if ($src -and ($src.PSObject.Properties.Name -contains $n)) { try { return [int64]$src.$n } catch { return $def } }; return $def }
		$fmt = { param($v); if ($v -lt 0) { $v = 0 }; $u = [uint32]$v; return ("0x{0:x8} ({1})" -f $u, $u) }
		if ($script:lblFALCur -and -not $script:lblFALCur.IsDisposed) { $v = & $raw 'FileAttributesLimitInBytes' $v_FileAttributesLimitInBytes $curNow; $script:lblFALCur.Text = & $fmt $v }
		if ($script:lblFSLCur -and -not $script:lblFSLCur.IsDisposed) { $v = & $raw 'FileSizeLimitInBytes' $v_FileSizeLimitInBytes $curNow; $script:lblFSLCur.Text = & $fmt $v }
		if ($script:LabelLocalServerTimeoutCur -and -not $script:LabelLocalServerTimeoutCur.IsDisposed) { $v = & $raw 'LocalServerTimeoutInSec' $v_LocalTimeoutInSec $curNow; $script:LabelLocalServerTimeoutCur.Text = & $fmt $v }
		if ($script:LabelInternetServerTimeoutCur -and -not $script:LabelInternetServerTimeoutCur.IsDisposed) { $v = & $raw 'InternetServerTimeoutInSec' $v_InternetTimeoutInSec $curNow; $script:LabelInternetServerTimeoutCur.Text = & $fmt $v }
		if ($script:LabelSendReceiveTimeoutCur -and -not $script:LabelSendReceiveTimeoutCur.IsDisposed) { $v = & $raw 'SendReceiveTimeoutInSec' $v_SendReceiveTimeoutInSec $curNow; $script:LabelSendReceiveTimeoutCur.Text = & $fmt $v }
		if ($script:LabelServerNotFoundCacheLifeTimeCur -and -not $script:LabelServerNotFoundCacheLifeTimeCur.IsDisposed) { $v = & $raw 'ServerNotFoundCacheLifeTimeInSec' $v_NotFoundCacheLifetimeInSec $curNow; $script:LabelServerNotFoundCacheLifeTimeCur.Text = & $fmt $v }
	}
	$script:WebClientRegTimer = New-Object System.Windows.Forms.Timer; $script:WebClientRegTimer.Interval = 800
	$script:WebClientRegTimer.add_Tick({
		& $script:UpdateWebClientRegView
		if ($script:UpdateWebClientApplyButton -is [scriptblock]) { & $script:UpdateWebClientApplyButton }
		# keep service LED + buttons in sync with real service state, but do not interfere while a Start/Restart action is pending
		if (-not $script:SvcActionPending -and ($script:UpdateSvc -is [scriptblock])) { & $script:UpdateSvc }
	})
	$script:WebClientRegTimer.Start()
	& $script:UpdateWebClientRegView
	& $script:UpdateSvc
	# Apply handler -> elevate via broker
	$btnApply.Add_Click({
		# Map current UI state to registry payload
		$bal = 1
		if ($cmbBAL.SelectedIndex -ge 0) { $bal = @(0,1,2)[$cmbBAL.SelectedIndex] }
		$maxDword = [uint32]::MaxValue
		# Map files-per-folder back to bytes (approx. 1000 bytes per file)
		$limitAttr = [int64]$numFiles.Value * 1000
		if ($limitAttr -gt $maxDword) { $limitAttr = [int64]$maxDword }
		# Map selected step to bytes
		if ($cmbFSL.SelectedIndex -ge 0) { $limitSize = [int64]$steps[$cmbFSL.SelectedIndex] } else { $limitSize = [int64]$steps[0] }
		if ($limitSize -gt $maxDword) { $limitSize = [int64]$maxDword }
		# Startup type from UI (Automatic / Manual / Disabled)  same index pattern as BasicAuth
		$startupMode = $null; $idxStart = $null
		if ($cmbSvc -and -not $cmbSvc.IsDisposed -and $cmbSvc.SelectedIndex -ge 0) { $idxStart = $cmbSvc.SelectedIndex; $startupMode = switch ($idxStart) { 0 { 'Automatic' }; 1 { 'Manual' }; 2 { 'Disabled' }; default { $null } } }
		# If startup type will change from enabled (Automatic/Manual) to Disabled, unmap the WebDAV drive once (without putting the app into "paused" state).
		if ($startupMode -eq 'Disabled') {
			$startIsDisabled = $false
			try { $svc = Get-Service -Name WebClient -ErrorAction Stop; $startRaw = [string]$svc.StartType; if ($startRaw -like 'Disabled*') { $startIsDisabled = $true } } catch { $startIsDisabled = $false }
			if (-not $startIsDisabled) { try { Unmap-DriveIfOurs -Force -RemoveProfile } catch {} }
		}
		$new = @{ BasicAuthLevel = [int]$bal; FileAttributesLimitInBytes = $limitAttr; FileSizeLimitInBytes = $limitSize; LocalServerTimeoutInSec = [int]$numLoc.Value; InternetServerTimeoutInSec = [int]$numInt.Value; SendReceiveTimeoutInSec = [int]$numSR.Value; ServerNotFoundCacheLifeTimeInSec = [int]$numC.Value }
		if ($startupMode) { $new.StartupType = $startupMode }
		if (Invoke-WebClientWriteBroker $new) {
			try { Show-InfoT 'message.tuning_applied' } catch {}
			try { & $script:UpdateSvc } catch {}
			# Let registry snapshot + timer decide dirty state
			if ($script:UpdateWebClientApplyButton -is [scriptblock]) { & $script:UpdateWebClientApplyButton }
		} else { try { Show-ErrorT 'message.uac_admin_required' } catch {} }
	}.GetNewClosure())
	# Wire Close button (close parent form)
	$btnClose.Add_Click({ param($s, $e); try { $f = $s.FindForm(); if ($f) { $f.DialogResult = [Windows.Forms.DialogResult]::OK; $f.Close() } } catch {} })
	$t.add_Disposed({
		try {
			$script:UpdateSvc = $null
			$script:ButtonServiceStart = $null
			$script:ButtonServiceRestart = $null
			$script:LabelBasicAuthLevel = $null
			$script:ComboBoxBasicAuthLevel = $null
			$script:LabelFilesPerFolder = $null
			$script:LabelFileSizeLimit = $null
			$script:LabelActiveScope = $null
			$script:LabelLocalServerTimeout = $null
			$script:LabelInternetServerTimeout = $null
			$script:LabelSendReceiveTimeout = $null
			$script:LabelServerNotFoundCacheLifeTime = $null
			$script:LabelServiceStatus = $null
			$script:LabelServiceStartType = $null
			$script:ButtonServiceTriggerInfo = $null
			$script:ButtonLocalServerTimeoutHelp = $null
			$script:ButtonInternetServerTimeoutHelp = $null
			$script:ButtonSendReceiveTimeoutHelp = $null
			$script:ButtonServerNotFoundCacheLifeTimeHelp = $null
			$script:ButtonApplyAsAdmin = $null
			# dispose shield bitmap and detach from button
			foreach ($b in @($btnSvcStart, $btnSvcRestart, $btnApply)) { try { if ($b -and $b.Tag -and $b.Tag.UacBmp) { $b.Image = $null; $b.Tag.UacBmp.Dispose(); $b.Tag.UacBmp = $null; } } catch {} }
			if ($script:WebClientRegTimer) { try { $script:WebClientRegTimer.Stop(); $script:WebClientRegTimer.Dispose() } catch {}; $script:WebClientRegTimer = $null }
			$script:UpdateWebClientRegView = $null
			$script:lblFALCur = $null; $script:lblFSLCur = $null
			$script:LabelLocalServerTimeoutCur = $null; $script:LabelInternetServerTimeoutCur = $null; $script:LabelSendReceiveTimeoutCur = $null; $script:LabelServerNotFoundCacheLifeTimeCur = $null
			$script:UpdateWebClientApplyButton = $null
			$script:SetWebClientStatusLabel = $null
			$script:SvcStartPrevIdx = $null
		} catch {}
	})
}
function Format-CacheBytes([long]$b) {
	if ($b -ge 1GB) { return ('{0:N1} GB' -f ($b / 1GB)) }
	elseif ($b -ge 1MB) { return ('{0:N1} MB' -f ($b / 1MB)) }
	elseif ($b -ge 1KB) { return ('{0:N0} KB' -f ($b / 1KB)) }
	else { return ('{0:N0} B' -f $b) }
}
function Render-WebDavCacheTab([Parameter(Mandatory)] [System.Windows.Forms.TabPage]$HostTab) {
	$t = $HostTab
	$t.Controls.Clear()
	# ---- layout: main container ----
	$panelMain = $script:CacheWatcherDetailsPanel = New-Object Windows.Forms.Panel; $panelMain.Dock = 'Fill'
	$t.Controls.Add($panelMain)
	# list panel (center)
	$panelList = New-Object Windows.Forms.Panel; $panelList.Dock = 'Fill'
	$panelMain.Controls.Add($panelList)
	# bottom panel: clear cache button
	$panelBottom = New-Object Windows.Forms.Panel; $panelBottom.Dock = 'Bottom'; $panelBottom.Height = 40
	$panelMain.Controls.Add($panelBottom)
	# info panel (line 3)
	$panelTop = New-Object Windows.Forms.Panel; $panelTop.Dock = 'Top'; $panelTop.Height = 40
	$panelMain.Controls.Add($panelTop)
	# watcher panel (line 2)
	$panelWatcher = $script:CacheWatcherPanel = New-Object Windows.Forms.Panel; $panelWatcher.Dock = 'Top'; $panelWatcher.Height = 40
	$panelMain.Controls.Add($panelWatcher)
	# status panel (line 1)
	$panelStatus = $script:CacheStatusPanel = New-Object Windows.Forms.Panel; $panelStatus.Dock = 'Top'; $panelStatus.Height = 30
	$panelMain.Controls.Add($panelStatus)
	$lblWatcher = $script:CacheWatcherStatusLabel = New-Object Windows.Forms.Label; $lblWatcher.Left = 4; $lblWatcher.Top = 12; $lblWatcher.AutoSize = $true
	$panelStatus.Controls.Add($lblWatcher)
	# watcher row: label left, toggle/live/refresh right
	$flowWatcherLeft = New-Object Windows.Forms.FlowLayoutPanel; $flowWatcherLeft.Dock = 'Left'; $flowWatcherLeft.AutoSize = $true; $flowWatcherLeft.AutoSizeMode = 'GrowAndShrink'; $flowWatcherLeft.WrapContents = $false; $flowWatcherLeft.Padding = '0,2,4,4'
	$flowWatcherRight = New-Object Windows.Forms.FlowLayoutPanel; $flowWatcherRight.Dock = 'Right'; $flowWatcherRight.AutoSize = $true; $flowWatcherRight.AutoSizeMode = 'GrowAndShrink'; $flowWatcherRight.WrapContents = $false; $flowWatcherRight.Padding = '4,2,0,0'; $flowWatcherRight.FlowDirection = [System.Windows.Forms.FlowDirection]::RightToLeft
	# Start button (with UAC shield)
	$btnStart = $script:CacheWatcherStartButton = New-Object Windows.Forms.Button; $btnStart.Text = (T 'button.cache_watcher_start'); $btnStart.AutoSize = $true; $btnStart.AutoSizeMode = 'GrowAndShrink'; $btnStart.MinimumSize = New-Object System.Drawing.Size(0, $script:ButtonXH); $btnStart.Margin = New-Object System.Windows.Forms.Padding(4,0,0,0)
	try { $null = $btnStart.Handle; Enable-FlatUacShield $btnStart } catch {} # start needs elevation
	# Stop button (no UAC shield)
	$btnStop = $script:CacheWatcherStopButton = New-Object Windows.Forms.Button; $btnStop.Text = (T 'button.cache_watcher_stop'); $btnStop.AutoSize = $true; $btnStop.AutoSizeMode = 'GrowAndShrink'; $btnStop.MinimumSize = New-Object System.Drawing.Size(0, $script:ButtonH); $btnStop.Margin = New-Object System.Windows.Forms.Padding(4,4,0,0)
	$chkLive = $script:CacheWatcherLiveCheckbox = New-Object Windows.Forms.CheckBox; $chkLive.Text = (T 'box.cache_live_update'); $chkLive.AutoSize = $true; $chkLive.Checked = $script:CacheWatcherLiveUpdate; $chkLive.Margin = New-Object System.Windows.Forms.Padding(0,10,4,0)
	$btnRefresh = $script:ButtonCacheRefresh = New-Object Windows.Forms.Button; $btnRefresh.Text = (T 'button.refresh'); $btnRefresh.Width = 100; $btnRefresh.Height = $script:ButtonH; $btnRefresh.Margin = New-Object System.Windows.Forms.Padding(4,4,0,0)
	$flowWatcherLeft.Controls.AddRange(@($btnStart, $btnStop))
	$flowWatcherRight.Controls.AddRange(@($btnRefresh, $chkLive))
	$panelWatcher.Controls.AddRange(@($flowWatcherLeft, $flowWatcherRight))
	# info row (line 3): only text on the left
	$lblInfo = $script:LabelCacheInfo = New-Object Windows.Forms.Label; $lblInfo.Text = (T 'label.cache_info' @{ size = (Format-CacheBytes 0) }); $lblInfo.Font = New-Object System.Drawing.Font($UiFontFamily, 9, $UiFontStyleRegular); $lblInfo.AutoSize = $true; $lblInfo.Left = 0; $lblInfo.Top = 8
	$panelTop.Controls.Add($lblInfo)
	# ListView
	$lv = $script:CacheListView = New-Object Windows.Forms.ListView; $lv.View = 'Details'; $lv.FullRowSelect = $true; $lv.MultiSelect = $true; $lv.HideSelection = $false; $lv.Dock = 'Fill'; $lv.HeaderStyle = 'Clickable'; $lv.GridLines = $true; $lv.Sorting = 'None'
	$lv.TabStop = $false; $lv.Enabled = $false; $lv.OwnerDraw = $true
	# Use smaller monospace font for cache entries
	$script:CacheListEntryFont = New-Object System.Drawing.Font('Consolas', 7.5)
	$lv.add_DrawColumnHeader({
		param($s,$e)
		$font = $e.Font
		$flags = [System.Windows.Forms.TextFormatFlags]::Left -bor [System.Windows.Forms.TextFormatFlags]::VerticalCenter
		$e.Graphics.FillRectangle([System.Drawing.Brushes]::Gainsboro, $e.Bounds) # Paint header background (no DrawBackground)
		[System.Windows.Forms.TextRenderer]::DrawText($e.Graphics, $e.Header.Text, $font, $e.Bounds, [System.Drawing.SystemColors]::WindowText, $flags)
	})
	$lv.add_DrawItem({ param($s,$e) }) # required when OwnerDraw is true in Details view
	$lv.add_DrawSubItem({
		param($s,$e)
		$font  = if ($script:CacheListEntryFont) { $script:CacheListEntryFont } else { $e.SubItem.Font }
		$flags = [System.Windows.Forms.TextFormatFlags]::Left -bor [System.Windows.Forms.TextFormatFlags]::VerticalCenter
		# Always paint our own background (no DrawBackground)
		if (($e.ItemIndex % 2) -eq 1) { $e.Graphics.FillRectangle([System.Drawing.Brushes]::Honeydew, $e.Bounds) } else { $e.Graphics.FillRectangle([System.Drawing.SystemBrushes]::Window, $e.Bounds) }
		$textColor = [System.Drawing.SystemColors]::WindowText # Stable text color, independent of Selected/Focus
		[System.Windows.Forms.TextRenderer]::DrawText($e.Graphics, $e.SubItem.Text, $font, $e.Bounds, $textColor, $flags)
	})
	[void]$lv.Columns.Add((T 'column.cache_name'), 330); [void]$lv.Columns.Add((T 'column.cache_size'), 85); [void]$lv.Columns.Add((T 'column.cache_modified'), 131); [void]$lv.Columns.Add((T 'column.cache_type'), 55)
	# Make columns fill the full client width (avoid horizontal scrolling, full-row background)
	$script:AlignCacheColumns = {
		if (-not $script:CacheListView -or $script:CacheListView.IsDisposed) { return }
		$lvLocal = $script:CacheListView
		if ($lvLocal.Columns.Count -lt 4) { return }
		$w0 = 330; $w1 = 85; $w2 = 131 # Base widths for first three columns
		$total = $lvLocal.ClientSize.Width
		$last = [Math]::Max(40, $total - ($w0 + $w1 + $w2))
		$lvLocal.Columns[0].Width = $w0; $lvLocal.Columns[1].Width = $w1; $lvLocal.Columns[2].Width = $w2; $lvLocal.Columns[3].Width = $last
	}
	# Initial alignment
	if ($script:AlignCacheColumns -is [scriptblock]) { & $script:AlignCacheColumns }
	# Re-align when the ListView is resized
	$lv.add_Resize({ if ($script:AlignCacheColumns -is [scriptblock]) { & $script:AlignCacheColumns } })
	$panelList.Controls.Add($lv)
	# Bottom panel: right actions (clear cache + clear-on-exit)
	$flowRight = New-Object Windows.Forms.FlowLayoutPanel; $flowRight.Dock = 'Right'; $flowRight.AutoSize = $true; $flowRight.AutoSizeMode = 'GrowAndShrink'; $flowRight.WrapContents = $false; $flowRight.Padding = '4,4,0,4'; $flowRight.FlowDirection = [System.Windows.Forms.FlowDirection]::LeftToRight
	$script:CacheClearOnExit = $true; try { $script:CacheClearOnExit = Get-CacheWatcherClearOnExit } catch {}
	$chkClearOnExit = $script:CacheClearOnExitCheckbox = New-Object Windows.Forms.CheckBox; $chkClearOnExit.Text = (T 'box.cache_clear_on_exit'); $chkClearOnExit.AutoSize = $true; $chkClearOnExit.Checked = $script:CacheClearOnExit; $chkClearOnExit.Margin = New-Object System.Windows.Forms.Padding(0,10,4,0)
	$btnDeleteAll = $script:ButtonCacheDeleteAll = New-Object Windows.Forms.Button; $btnDeleteAll.Text = (T 'button.clear_cache'); $btnDeleteAll.Width = 140; $btnDeleteAll.Height = $script:ButtonH
	$flowRight.Controls.AddRange(@($chkClearOnExit, $btnDeleteAll))
	$panelBottom.Controls.Add($flowRight)
	# ---- shared state + helpers ----
	$script:CacheEntries = @()
	$script:CacheSortColumn = 0
	$script:CacheSortDescending = $false
	$script:UpdateCacheTotalLabel = {
		if (-not $script:LabelCacheInfo -or $script:LabelCacheInfo.IsDisposed) { return }
		$total = 0L
		if ($script:CacheEntries) { foreach ($e in $script:CacheEntries) { $total += [int64]$e.Length } }
		$script:LabelCacheInfo.Text = (T 'label.cache_info' @{ size = (Format-CacheBytes($total)) })
	}
	$script:RenderCacheEntries = {
		if (-not $script:CacheListView -or $script:CacheListView.IsDisposed) { return }
		$entries = $script:CacheEntries
		if (-not $entries) {
			$script:CacheListView.BeginUpdate()
			$script:CacheListView.Items.Clear()
			$script:CacheListView.EndUpdate()
			if ($script:UpdateCacheTotalLabel -is [scriptblock]) { & $script:UpdateCacheTotalLabel }
			return
		}
		$items = $entries
		switch ($script:CacheSortColumn) {
			0 { $items = if ($script:CacheSortDescending) { $entries | Sort-Object Name -Descending } else { $entries | Sort-Object Name } }
			1 { $items = if ($script:CacheSortDescending) { $entries | Sort-Object Length -Descending } else { $entries | Sort-Object Length } }
			2 { $items = if ($script:CacheSortDescending) { $entries | Sort-Object LastWriteTimeUtc -Descending } else { $entries | Sort-Object LastWriteTimeUtc } }
			3 { $items = if ($script:CacheSortDescending) { $entries | Sort-Object Type -Descending } else { $entries | Sort-Object Type } }
		}
		$script:CacheListView.BeginUpdate()
		$script:CacheListView.Items.Clear()
		foreach ($f in $items) {
			$sizeText = Format-CacheBytes ([long]$f.Length)
			$dt = [DateTime]::SpecifyKind($f.LastWriteTimeUtc, [DateTimeKind]::Utc).ToLocalTime()
			$item = New-Object Windows.Forms.ListViewItem $f.Name
			[void]$item.SubItems.Add($sizeText)
			[void]$item.SubItems.Add($dt.ToString('yyyy-MM-dd HH:mm'))
			$typeText = if ($f.Type) { [string]$f.Type } else { 'file' }
			[void]$item.SubItems.Add($typeText)
			$item.Tag = $f
			[void]$script:CacheListView.Items.Add($item)
		}
		$script:CacheListView.EndUpdate()
		if ($script:UpdateCacheTotalLabel -is [scriptblock]) { & $script:UpdateCacheTotalLabel }
	}
	$script:RefreshCacheList = {
		try {
			if (-not $script:CacheListView -or $script:CacheListView.IsDisposed) { return $false }
			Write-Verbose "[CacheTab] RefreshCacheList: using Get-CacheAgentState"
			$state = Get-CacheAgentState
			# No snapshot: clear once when transitioning from "had snapshot" -> "no snapshot"
			if (-not $state -or -not $state.Snapshot) {
				Write-Verbose "[CacheTab] RefreshCacheList: no snapshot"
				if ($script:LastCacheSnapshotSignature -ne $null) {
					Write-Verbose "[CacheTab] RefreshCacheList: snapshot disappeared, clearing list once"
					$script:LastCacheSnapshotSignature = $null; $script:CacheEntries = @()
					if ($script:RenderCacheEntries -is [scriptblock]) { & $script:RenderCacheEntries }
				}
				else { Write-Verbose "[CacheTab] RefreshCacheList: snapshot still missing, list already cleared, skipping redraw" }
				return $false
			}
			# Snapshot present: build a cheap signature to detect changes
			$snapshot = $state.Snapshot
			$signature = "{0}|{1}|{2}|{3}" -f $snapshot.FileCount, $snapshot.TotalBytes, $snapshot.NewestWriteTimeUtc, $snapshot.OldestWriteTimeUtc
			if (-not $script:CacheForceRefreshOnce -and $signature -eq $script:LastCacheSnapshotSignature) { Write-Verbose "[CacheTab] RefreshCacheList: snapshot unchanged, skipping redraw"; return $true }
			# Either forced or snapshot changed: reset force flag and update signature
			$script:CacheForceRefreshOnce = $false
			$script:LastCacheSnapshotSignature = $signature
			$files = $snapshot.Files
			if (-not $files) { $script:CacheEntries = @(); if ($script:RenderCacheEntries -is [scriptblock]) { & $script:RenderCacheEntries }; return $true }
			$script:CacheEntries = @($files)
			if ($script:RenderCacheEntries -is [scriptblock]) { & $script:RenderCacheEntries }
			Write-Verbose ("[CacheTab] RefreshCacheList: rendered {0} items" -f $script:CacheListView.Items.Count)
			return $true
		} catch {
			try { $script:CacheListView.EndUpdate() } catch {}
			Write-Verbose ("[CacheTab] RefreshCacheList error: {0}" -f $_.Exception.Message)
			return $false
		}
	}
	$script:UpdateCacheWatcherUi = {
		try {
			if (-not $script:CacheWatcherStatusLabel -or $script:CacheWatcherStatusLabel.IsDisposed) { return }
			if (-not $script:CacheWatcherStartButton -or $script:CacheWatcherStartButton.IsDisposed) { return }
			if (-not $script:CacheWatcherStopButton -or $script:CacheWatcherStopButton.IsDisposed) { return }
			$anyWatcher = $script:CacheWatcherPresent
			$starting = $script:CacheStartPending
			$stopping = $script:CacheStopPending
			$statusKey = 'label.cache_watcher_stopped'
			Write-Verbose ("[CacheTab] UpdateCacheWatcherUi: anyWatcher={0}, starting={1}, stopping={2}" -f $anyWatcher, $starting, $stopping)
			if ($starting -and -not $anyWatcher) {
				# starting (no watcher visible yet, start requested)
				$statusKey = 'status.starting'
				$script:CacheWatcherStartButton.Visible = $true
				$script:CacheWatcherStartButton.Enabled = $false
				$script:CacheWatcherStopButton.Visible = $false
			}
			elseif ($stopping -and $anyWatcher) {
				# stopping (stop requested, watcher still present)
				$statusKey = 'status.stopping'
				$script:CacheWatcherStartButton.Visible = $false
				$script:CacheWatcherStopButton.Visible = $true
				$script:CacheWatcherStopButton.Enabled = $false
			}
			elseif ($anyWatcher) {
				# running (normal state)
				$statusKey = 'status.running'
				$script:CacheWatcherStartButton.Visible = $false
				$script:CacheWatcherStopButton.Visible = $true
				$script:CacheWatcherStopButton.Enabled = $true
			}
			else {
				# stopped (no watcher, no pending start/stop)
				$statusKey = 'status.stopped'
				$script:CacheWatcherStartButton.Visible = $true
				$script:CacheWatcherStartButton.Enabled = $true
				$script:CacheWatcherStopButton.Visible = $false
			}
			Write-Verbose ("[CacheTab] UpdateCacheWatcherUi: statusKey={0}" -f $statusKey)
			$script:CacheWatcherStatusLabel.Text = (T label.cache_watcher_status @{ status = (T $statusKey) })
			# disable details while stopping, otherwise coupled to watcher presence
			$detailsEnabled = $anyWatcher -and -not $stopping
			if ($script:LabelCacheInfo -and -not $script:LabelCacheInfo.IsDisposed) { $script:LabelCacheInfo.Enabled = $detailsEnabled }
			if ($script:CacheListView -and -not $script:CacheListView.IsDisposed) { $script:CacheListView.Enabled = $detailsEnabled }
			if ($script:ButtonCacheDeleteAll -and -not $script:ButtonCacheDeleteAll.IsDisposed) { $script:ButtonCacheDeleteAll.Enabled = $detailsEnabled }
			if ($script:ButtonCacheRefresh -and -not $script:ButtonCacheRefresh.IsDisposed) { $script:ButtonCacheRefresh.Enabled = $detailsEnabled }
			if ($script:CacheWatcherLiveCheckbox -and -not $script:CacheWatcherLiveCheckbox.IsDisposed) { $script:CacheWatcherLiveCheckbox.Enabled = $detailsEnabled }
			if ($script:CacheClearOnExitCheckbox -and -not $script:CacheClearOnExitCheckbox.IsDisposed) { $script:CacheClearOnExitCheckbox.Enabled = $detailsEnabled }
		} catch {
			Write-Verbose ("[CacheTab] UpdateCacheWatcherUi: ERROR {0}" -f $_.Exception.Message)
		}
	}
	$script:InvokeCacheDeleteAll = {
		if (-not $script:CacheWatcherPresent) { return }
		$ans = Ask-YesNoWarnT 'prompt.cache_delete_all_confirm'
		if ($ans -ne [System.Windows.Forms.DialogResult]::Yes) { return }
		if (Request-CacheDeleteAll) {
			$script:CacheListView.Items.Clear()
			$script:CacheEntries = @()
			if ($script:UpdateCacheTotalLabel -is [scriptblock]) { & $script:UpdateCacheTotalLabel }
		}
	}
	$script:InvokeCacheRefresh = { $script:CacheForceRefreshOnce = $true; if ($script:RefreshCacheList -is [scriptblock]) { [void](& $script:RefreshCacheList) } }
	if (-not $script:CacheAgentTimer) {
		$script:CacheAgentTimer = New-Object System.Windows.Forms.Timer
		$script:CacheAgentTimer.Interval = 1000 # 1500
		$script:CacheAgentTimer.Add_Tick({
			try {
				# Always pull live PIDs (this also cleans orphaned ones)
				Write-Verbose "[CacheTab] Timer tick: querying watcher entries"
				$watchersRaw = Get-CacheWatcherEntries
				$watchers = @()
				if ($watchersRaw) {
					# Normalize to an array, even if a single PSCustomObject is returned
					$watchers = @($watchersRaw)
				}
				$count = $watchers.Count
				$anyWatcher = ($count -gt 0)
				Write-Verbose ("[CacheTab] Timer tick: watchers.Count={0}, anyWatcher={1}" -f $count, $anyWatcher)
				$script:CacheWatcherPresent = $anyWatcher
				if ($anyWatcher -and $script:CacheClearOnExitCheckbox -and -not $script:CacheClearOnExitCheckbox.IsDisposed) {
					try {
						$flag = Get-CacheWatcherClearOnExit
						if ($flag -ne $script:CacheClearOnExit) { $script:CacheClearOnExit = $flag; $script:CacheClearOnExitCheckbox.Checked = $flag }
					} catch {}
				}
				# Transition: starting -> running
				if ($anyWatcher -and $script:CacheStartPending) {
					Write-Verbose "[CacheTab] Timer tick: watcher detected, clearing CacheStartPending"
					$script:CacheStartPending = $false
				}
				# Transition: stopping -> stopped
				if (-not $anyWatcher -and $script:CacheStopPending) {
					Write-Verbose "[CacheTab] Timer tick: no watcher, clearing CacheStopPending"
					$script:CacheStopPending = $false
				}
				# When no watcher and no start pending: full reset of UI list
				if (-not $anyWatcher -and -not $script:CacheStartPending) {
					Write-Verbose "[CacheTab] Timer tick: no watcher and no start pending, clearing list"
					if ($script:CacheListView -and -not $script:CacheListView.IsDisposed) {
						$script:CacheListView.BeginUpdate()
						$script:CacheListView.Items.Clear()
						$script:CacheListView.EndUpdate()
					}
					$script:CacheEntries = @()
					if ($script:UpdateCacheTotalLabel -is [scriptblock]) { & $script:UpdateCacheTotalLabel }
				}
				if ($script:UpdateCacheWatcherUi -is [scriptblock]) { & $script:UpdateCacheWatcherUi }
				if ($script:CacheWatcherLiveUpdate -and $script:RefreshCacheList -is [scriptblock] -and $script:CacheWatcherPresent) {
					Write-Verbose "[CacheTab] Timer tick: live update enabled, refreshing cache list"
					[void](& $script:RefreshCacheList)
				}
			} catch {
				Write-Verbose ("[CacheTab] Timer tick: ERROR {0}" -f $_.Exception.Message)
			}
		})
	}
	$t.Add_Enter({
		if ($script:CacheAgentTimer) { $script:CacheAgentTimer.Enabled = $true }
		if ($script:RefreshCacheList -is [scriptblock]) { [void](& $script:RefreshCacheList) }
	})
	# ---- wiring ----
	$chkClearOnExit.Add_CheckedChanged({
		$script:CacheClearOnExit = $this.Checked
		if ($script:CacheWatcherPresent) { try { Set-CacheWatcherClearOnExit -value $script:CacheClearOnExit } catch {} }
	})
	$btnRefresh.Add_Click({ & $script:InvokeCacheRefresh })
	$btnDeleteAll.Add_Click({ & $script:InvokeCacheDeleteAll })
	$lv.add_ColumnClick({
		param($s, $e)
		$col = [int]$e.Column
		if ($col -eq $script:CacheSortColumn) { $script:CacheSortDescending = -not $script:CacheSortDescending } else { $script:CacheSortColumn = $col; $script:CacheSortDescending = $false }
		if ($script:RenderCacheEntries -is [scriptblock]) { & $script:RenderCacheEntries }
	})
	# wiring for watcher controls: Start (with UAC shield) / Stop (no shield)
	$script:CacheWatcherStartButton.Add_Click({
		if ($script:CacheWatcherPresent) { return }
		if (Start-CacheWatcher) {
			$script:CacheStopPending = $false
			$script:CacheStartPending = $true
			try { Set-CacheWatcherClearOnExit -value $script:CacheClearOnExit } catch {}
			if ($script:UpdateCacheWatcherUi -is [scriptblock]) { & $script:UpdateCacheWatcherUi }
		} else { Show-ErrorT 'message.uac_admin_required' }
	})
	$script:CacheWatcherStopButton.Add_Click({
		if (-not $script:CacheWatcherPresent) { return }
		# Only warn if watcher is configured to clear cache on automatic exit
		if (Get-CacheWatcherClearOnExit) {
			$ans = (Ask-YesNoWarnT 'prompt.cache_watcher_stop_warn' @{ cache_clear_on_exit = (T 'box.cache_clear_on_exit') })
			if ($ans -ne [System.Windows.Forms.DialogResult]::Yes) { return }
		}
		try { $null = Send-CacheAgentCommand @{ Action = 'Stop' } } catch {}
		$script:CacheStopPending = $true
		if ($script:UpdateCacheWatcherUi -is [scriptblock]) { & $script:UpdateCacheWatcherUi }
	})
	$chkLive.Add_CheckedChanged({ $script:CacheWatcherLiveUpdate = $this.Checked }) # Timer always stays on; only the behavior during the tick changes.
	if ($script:UpdateCacheWatcherUi -is [scriptblock]) { & $script:UpdateCacheWatcherUi }
}

# ================================================================
#	Watchdog (separate process guard)
# ================================================================
function Run-Watchdog {
	$created = $false
	$wdKey = if ($OwnerPid -gt 0) { "Local\{0}Watchdog-{1}" -f $AppName, $OwnerPid } else { $WDMutex }
	try { $wdMutex = New-Object System.Threading.Mutex($true, $wdKey, [ref]$created); if (-not $created) { return } } catch { return }
	while ($true) {
		$mainAlive = $false
		try { if (-not [string]::IsNullOrWhiteSpace($MainMutexName) -and ($m = [System.Threading.Mutex]::OpenExisting($MainMutexName))) { $mainAlive = $true; $m.Dispose() } } catch { $mainAlive = $false }
		if (-not $mainAlive) { try { Load-Config; Unmap-DriveIfOurs -Force -RemoveProfile } catch {}; break }
		if ($PortableMode) {
			try { $root = $null; $root = Split-Path -Qualifier $SecretPath; $portableBroken = -not (Test-Path $SecretPath) -or -not (Test-Path $PortJson) -or ($root -and -not (Test-Path $root)) } catch { $portableBroken = $true }
			if ($portableBroken) { try { Load-Config; Unmap-DriveIfOurs -Force -RemoveProfile } catch {}; break }
		}
		Start-Sleep -Seconds 2
	}
	try { $wdMutex.ReleaseMutex() | Out-Null } catch {}
	try { $wdMutex.Dispose() } catch {}
}
if ($Watchdog) { Run-Watchdog; exit }

# ================================================================
#	Installed instance control (stop / start)
# ================================================================
# Returns absolute path to the installed script ($AppNameShort.ps1).
function Get-InstalledScriptPath { $p = Join-Path $InstallDir "$AppNameShort.ps1"; if (Test-Path -LiteralPath $p) { $p } }
function Get-RunningInstalledMain {
	# Returns an array of System.Diagnostics.Process for installed-mode main instances
	# (same session, command line contains the installed NDT.ps1 path, and NOT the -Watchdog helper)
	try {
		$inst = Get-InstalledScriptPath
		if (-not $inst) { return @() }
		$esc = [regex]::Escape($inst); $mySession = (Get-Process -Id $PID).SessionId
		$procs = Get-CimInstance Win32_Process -ErrorAction SilentlyContinue | Where-Object { $_.SessionId -eq $mySession -and $_.CommandLine -ne $null -and $_.CommandLine -match $esc -and $_.CommandLine -notmatch '\-Watchdog' }
		if (-not $procs) { return @() }
		$out = @()
		foreach ($p in $procs) { try { $dp = Get-Process -Id $p.ProcessId -ErrorAction Stop; if ($dp.Id -ne $PID) { $out += $dp } } catch {} }
		return $out
	} catch { return @() }
}
function Stop-InstalledInstance {
	[CmdletBinding()] param( [int]$TimeoutSec = 12, [switch]$ForceOnTimeout )
	# 1) Try graceful stop by sending CTRL+C is not possible for GUI loop.
	# We fall back to Stop-Process (first soft, then -Force if requested).
	$procs = Get-RunningInstalledMain
	if (-not $procs -or $procs.Count -eq 0) { return $true }
	Write-Verbose ("Found {0} installed instance(s) to stop" -f $procs.Count)
	# Try soft kill first
	foreach ($p in $procs) { try { if (-not $p.HasExited) { Write-Verbose ("Stopping PID {0} (soft)..." -f $p.Id); Stop-Process -Id $p.Id -ErrorAction SilentlyContinue } } catch {} }
	# Wait for exit
	$deadline = [DateTime]::UtcNow.AddSeconds($TimeoutSec)
	while ([DateTime]::UtcNow -lt $deadline) { $alive = @(); foreach ($p in $procs) { try { $p.Refresh(); if (-not $p.HasExited) { $alive += $p } } catch {} }; if ($alive.Count -eq 0) { break }; Start-Sleep -Milliseconds 300 }
	# Escalate with -Force if still alive and requested
	$still = @()
	foreach ($p in $procs) { try { $p.Refresh(); if (-not $p.HasExited) { $still += $p } } catch {} }
	if ($still.Count -gt 0 -and $ForceOnTimeout) { foreach ($p in $still) { try { Write-Verbose ("Force-stopping PID {0}..." -f $p.Id); Stop-Process -Id $p.Id -Force -ErrorAction SilentlyContinue } catch {} } }
	# Final check
	$rem = @()
	foreach ($p in $procs) { try { $p.Refresh(); if (-not $p.HasExited) { $rem += $p } } catch {} }
	if ($rem.Count -gt 0) { Write-Warning ("Some installed instances did not exit: {0}" -f ($rem.Id -join ', ')); return $false }
	return $true
}
function Start-InstalledInstance {
	# Start installed NDT in installed mode. It will spawn its watchdog by itself.
	try {
		$inst = Get-InstalledScriptPath
		if (-not $inst) { return $false }
		$ps = Join-Path $env:SystemRoot 'System32\WindowsPowerShell\v1.0\powershell.exe'
		if (-not (Test-Path -LiteralPath $ps)) { $ps = 'powershell.exe' }
		# Preserve STA & EP; no args by default  you can extend if needed
		$args = @('-NoProfile', '-ExecutionPolicy', 'Bypass', '-STA', '-File', "`"$inst`"")
		Start-Process -FilePath $ps -ArgumentList $args -WindowStyle Hidden | Out-Null
		return $true
	} catch { Write-Warning ("Start-InstalledInstance failed: {0}" -f $_.Exception.Message); return $false }
}

# ================================================================
#	Main (load config, tray, menu, timer, watchdog, application run)
# ================================================================
Load-Config
# Now that $State is loaded, initialize i18n with user preferences.
Initialize-I18n
<# This is for debug purposes only
if ($env:NDT_I18N_TEST -eq '1') {
	Show-InfoT 'i18n.ok'
} #>
# --- early actions triggered by installer bootstrap ---
if ($Action -eq 'Install') {
	$script:FromInstaller = $true # flag for Install-Self
	Write-Verbose 'Dispatch: Install (from installer)'
	# 1) Stop running installed instance (same session). Escalate if needed.
	$stopped = $false
	try { $stopped = Stop-InstalledInstance -TimeoutSec 12 -ForceOnTimeout } catch {}
	if (-not $stopped) { Write-Warning 'Some installed instance(s) did not exit in time; proceeding with installation anyway.' }
	# 2) Perform installation without auto-launch.
	Install-Self -FromInstaller
	# 3) Start the newly installed instance exactly once.
	try { [void](Start-InstalledInstance) } catch {}
	return
}
if ($Action -eq 'ExportPortable') {
	$script:FromInstaller = $true	# so default = script folder AND "bare" export
	Write-Verbose 'Dispatch: ExportPortable'
	Export-To-Portable -Force
	return
}
if ($Action -eq 'CacheAgent') { CacheAgent -OwnerPid $OwnerPid -IntervalSeconds $IntervalSeconds; return }

# --- Single-instance per config.json ---
Ensure-SingleInstanceForConfig

# --- Guard the drive letter from this config ---
if (Test-ValidDrive $State.Drive) { Ensure-DriveGuard -Drive $State.Drive }

# --- WebClient presence + one-time hint/start (depends on startup mode) ---
$svc = Get-Service -Name WebClient -ErrorAction SilentlyContinue
if (-not $svc) { Show-ErrorT 'message.service_webclient_missing'; exit 1 }
$startMode = switch -Regex ([string]$svc.StartType) { '^Automatic' { 'Automatic' }; '^Disabled' { 'Disabled' }; default { 'Manual' } }
$hasTrigger = Test-Path ($RegWebClient -replace 'Parameters', 'TriggerInfo')
if (-not $script:WebClientServicePrompted) {
	$script:WebClientServicePrompted = $true
	# Service is deactivated -> for informational purposes only, activation is done via the WebClient tuning tab (Broker)
	if ($startMode -eq 'Disabled') {
		$script:ServiceDeactivated = $true
		Show-WarnT 'message.service_webclient_disabled_use_tuning'
	}
	elseif ($startMode -eq 'Manual' -and -not $hasTrigger) {
		# Manually without trigger -> Offer to start the service once (but DO NOT activate it)
		$ans = Ask-YesNoWarnT 'prompt.service_webclient_start_now' -Uac
		if ($ans -eq [System.Windows.Forms.DialogResult]::Yes -and -not (Invoke-WebClientServiceAction 'start')) { Show-ErrorT 'message.service_webclient_start_failed' }
	}
}

# BasicAuth = 0 -> one-time warning/fix prompt (before NeedsSetup / Tray)
if (-not $script:BasicAuthWarned) {
	$script:BasicAuthWarned = $true
	$ba0 = $false
	try {
		if (Test-Path $RegWebClient) {
			$p = Get-ItemProperty -Path $RegWebClient -ErrorAction SilentlyContinue
			if ($p -and ($p.PSObject.Properties.Name -contains 'BasicAuthLevel')) { $ba0 = ([int]$p.BasicAuthLevel -eq 0) }
		}
	} catch {}
	if ($ba0) {
		$ans = Ask-YesNoWarnT 'prompt.basic_auth_disabled_enable_now' -Uac
		if ($ans -eq [System.Windows.Forms.DialogResult]::Yes) { if (-not (Invoke-WebClientWriteBroker @{ BasicAuthLevel = 1 })) { Show-ErrorT 'message.tuning_failed' } }
	}
}
try { if (-not [string]::IsNullOrWhiteSpace($State.Server)) { [void](Fetch-ServerFavicon $State.Server) } } catch {}

# --- First-run: open Settings immediately if we need setup ---
Refresh-NeedsSetup
# Tray
#$label = if (Test-ValidDrive $State.Drive) { $State.Drive.Substring(0, 1) } else { '!' }
$label = if (Test-ValidDrive $State.Drive) { $State.Drive.Substring(0, 2) } else { '!' }
$script:tray = New-Object System.Windows.Forms.NotifyIcon
$script:icoWarn = New-StatusIcon '!' ([System.Drawing.Color]::Goldenrod)
$script:icoRed = New-StatusIcon $label ([System.Drawing.Color]::Tomato)
$script:icoGre = New-StatusIcon $label ([System.Drawing.Color]::LimeGreen)
$script:tray.Visible = $true
if ($script:ServiceDeactivated) { $script:tray.Icon = $script:icoWarn; $script:tray.Text = T 'tray.service_deactivated' @{ app = $AppName } }
elseif ($script:NeedsSetup) { $script:tray.Icon = $script:icoWarn; $script:tray.Text = T 'tray.needs_setup' @{ app = $AppName } }
else { $script:tray.Icon = $script:icoRed; $script:tray.Text = T 'tray.initializing' @{ app = $AppName } }
if ($script:NeedsSetup) { Write-Verbose 'First run detected -> opening Settings dialog immediately.'; [void](Show-SettingsDialog); Refresh-NeedsSetup } # Re-evaluate after dialog
$script:MainMutexName = "Local\${AppName}Main-$PID"
try { $script:mainMutex = New-Object System.Threading.Mutex($true, $script:MainMutexName) } catch { $script:mainMutex = $null }
Refresh-NeedsSetup
# Portable: prompt passphrase if secret exists (with reset)
if ($PortableMode -and (Test-Path $SecretPath) -and (-not $script:AskedPassphrase)) {
	while ($true) {
		$result = Prompt-Passphrase (T 'title.passphrase_query' @{ app = $AppName }) -ExitOnCancel
		if ($null -eq $result) {
			# User cancelled  exit cleanly BEFORE building the rest of the UI
			try { if ($script:timer) { $script:timer.Stop() } } catch {}
			try { Unmap-Drive } catch {}
			try { if ($script:mainMutex) { $script:mainMutex.ReleaseMutex() | Out-Null; $script:mainMutex.Dispose() } } catch {}
			try { if ($script:tray) { $script:tray.Visible = $false; $script:tray.Dispose() } } catch {}
			[System.Windows.Forms.Application]::Exit()
			return
		}
		try { $script:PlainPassCache = Unprotect-PortableSecret $result $SecretPath; $script:AskedPassphrase = $true; break } catch { Show-WarnT 'message.passphrase_wrong_or_corrupt' } # Loop continues -> prompt again
	}
	if ($script:ResetRequested) { $script:ResetRequested = $false; [void](Show-SettingsDialog) }
}
if (-not (Ensure-ConfiguredFolderOrExit)) { return }

# Menu (with mode banner)
$menu = New-Object System.Windows.Forms.ContextMenuStrip
$miMode = New-Object System.Windows.Forms.ToolStripLabel
$miMode.Text = if ($PortableMode) { (T 'mode.portable') } else { (T 'mode.installed') }
$miMode.ForeColor = if ($PortableMode) { [System.Drawing.Color]::ForestGreen } else { [System.Drawing.Color]::SteelBlue }
$miMode.Font = New-Object System.Drawing.Font($UiFontFamily, 9, $UiFontStyleBold)
$null = $menu.Items.Add($miMode)
$menu.Items.Add('-') | Out-Null
$miConn = $menu.Items.Add((T 'menu.connect'))
$miDisc = $menu.Items.Add((T 'menu.disconnect'))
$miSett = $menu.Items.Add((T 'menu.settings'))
$menu.Items.Add('-') | Out-Null
$miAbout = $menu.Items.Add((T 'menu.about'))
$menu.Items.Add('-') | Out-Null
$miExit = $menu.Items.Add((T 'menu.exit'))

function Update-MenuState {
	try {
		# Refresh deactivated flag from current StartType
		Sync-WebClientDeactivatedFlag | Out-Null
		# When the WebClient service is deactivated, both actions are meaningless
		if ($script:ServiceDeactivated) { $miConn.Enabled = $false; $miDisc.Enabled = $false; return }
		$isConnected = Test-DriveAccessible
		$hasPassword = if ($PortableMode) { -not [string]::IsNullOrWhiteSpace((Get-PlainPassword)) } else { $true }
		# Connect is meaningful if paused OR not connected, and (in portable mode) a password exists
		$miConn.Enabled = (($script:Paused -or -not $isConnected) -and $hasPassword)
		# Disconnect is meaningful if connected and not paused
		$miDisc.Enabled = ($isConnected -and -not $script:Paused)
	} catch { $miConn.Enabled = $true; $miDisc.Enabled = $false }
}
function Invoke-NcTrayDisconnect {
	# Same behavior as tray menu "Disconnect": pause, unmap, update tray + menu
	$script:Paused = $true
	try {
		Unmap-DriveIfOurs -Force -RemoveProfile
		$varsPaused = @{ app = $AppName; drive = $State.Drive }
		$txtPaused = T 'tray.paused' $varsPaused
		Set-TrayState -Icon $script:icoRed -Text $txtPaused
	} catch {}
	try { Update-MenuState } catch {}
}
$menu.add_Opening({ Update-MenuState })
Update-MenuState

$script:tray.ContextMenuStrip = $menu

# Connect now
$miConn.add_Click({
	$script:Paused = $false
	# Refresh deactivated flag from current StartType
	Sync-WebClientDeactivatedFlag | Out-Null
	# Do not try to connect while the WebClient service is disabled
	if ($script:ServiceDeactivated) { Show-WarnT 'message.service_webclient_disabled_use_tuning'; return }
	if ($script:NeedsSetup) { if (Show-SettingsDialog -eq [Windows.Forms.DialogResult]::OK) { Refresh-NeedsSetup } else { return } }
	if ($PortableMode) { if (-not (Ensure-PortablePass -Interactive)) { return } }
	# ensure subfolder still exists before mapping ---
	if (-not (Ensure-ConfiguredFolderOrExit)) { return }
	if (Map-Drive) { Rebuild-Icons; $varsOnline = @{ app = $AppName; drive = $State.Drive }; $txtOnline = T 'tray.online' $varsOnline; Set-TrayState -Icon $script:icoGre -Text $txtOnline }
	else { $varsFail = @{ app = $AppName }; $txtFail = T 'tray.mapping_failed' $varsFail; Set-TrayState -Icon $script:icoRed -Text $txtFail }
	Update-MenuState
})

# Disconnect now and pause the tick
$miDisc.add_Click({ Invoke-NcTrayDisconnect })
$miSett.add_Click({ [void](Show-SettingsDialog) })
$miAbout.add_Click({
	# Simple About dialog
	$f = New-Object System.Windows.Forms.Form
	Apply-BrandIconToForm $f
	Hook-FormDpi $f
	$f.Text = (T 'title.about' @{ app = $AppName }); $f.StartPosition = 'CenterScreen'; $f.FormBorderStyle = 'FixedDialog'; $f.MaximizeBox = $false; $f.MinimizeBox = $false; $f.TopMost = $true; $f.Width = 420; $f.Height = 220; $f.AutoScaleMode = 'Dpi'; $f.Font = New-Object System.Drawing.Font($UiFontFamily, 9)
	$lblTit = New-Object System.Windows.Forms.Label; $lblTit.Text = "ernolfs $AppName"; $lblTit.AutoSize = $true
	$lblTit.Font = New-Object System.Drawing.Font($UiFontFamily, 11, $UiFontStyleBold); $lblTit.Left = 16; $lblTit.Top = 16; $lblTit.UseCompatibleTextRendering = $false
	$lblDes = New-Object System.Windows.Forms.Label; $lblDes.Left = 16; $lblDes.Top = 44; $lblDes.Text = (T 'about.des'); $lblDes.AutoSize = $true; $lblDes.MaximumSize = New-Object System.Drawing.Size(260, 0) # <- slightly narrower to make room for avatar
	$lblVer = New-Object System.Windows.Forms.Label; $lblVer.Left = 16; $lblVer.Top = 88; $lblVer.Text = (T 'about.ver' @{ version = $Version }); $lblVer.AutoSize = $true
	$lblAut = New-Object System.Windows.Forms.Label; $lblAut.Left = 16; $lblAut.Top = 110; $lblAut.Text = (T 'about.aut' @{ author = $Author }); $lblAut.AutoSize = $true
	$link = New-Object System.Windows.Forms.LinkLabel; $link.Text = $ProjectUrl; $link.Left = 16; $link.Top = 132; $link.AutoSize = $true; $link.add_LinkClicked({ param($s, $e); try { $psi = New-Object System.Diagnostics.ProcessStartInfo; $psi.FileName = $ProjectUrl; $psi.UseShellExecute = $true; [System.Diagnostics.Process]::Start($psi) | Out-Null } catch {} })
	$avatarImg = Get-EmbeddedImage -Base64 $ernolfB64 # Avatar on the right
	$pb = $null
	if ($avatarImg) { $pb = New-Object System.Windows.Forms.PictureBox; $pb.Width = 96; $pb.Height = 96; $pb.SizeMode = 'Zoom'; $pb.Image = $avatarImg; $pb.Left = $f.ClientSize.Width - $pb.Width - 16; $pb.Top = 16; $pb.Anchor = 'Top, Right' }
	$ok = New-Object System.Windows.Forms.Button; $ok.Text = (T 'button.ok'); $ok.Width = 80; $ok.Height = $script:ButtonXH; $ok.Left = $f.ClientSize.Width - $ok.Width - 16; $ok.Top = $f.ClientSize.Height - $ok.Height - 16; $ok.Anchor = 'Bottom, Right'; $ok.Add_Click({ $f.Close() })
	# Dispose avatar image to free GDI handles
	$f.add_FormClosed({ if ($pb -and $pb.Image) { try { $pb.Image.Dispose() } catch {} } })
	if ($pb) { $f.Controls.AddRange(@($lblTit, $lblDes, $lblVer, $lblAut, $link, $pb, $ok)) }
	else { $f.Controls.AddRange(@($lblTit, $lblDes, $lblVer, $lblAut, $link, $ok)) }
	[void]$f.ShowDialog()
})
$miExit.add_Click({
	# Ensure timer is fully stopped and disposed
	try { if ($script:timer) { $script:timer.Stop(); $script:timer.Dispose() } } catch {}
	# Unmap, refresh shell and release main mutex
	try { Unmap-Drive } catch {}
	try { Refresh-ExplorerDriveRemoval $State.Drive } catch {}
	Start-Sleep -Milliseconds 120
	try { if ($script:mainMutex) { $script:mainMutex.ReleaseMutex() | Out-Null; $script:mainMutex.Dispose() } } catch {}
	# Hide and dispose tray icon
	$script:tray.Visible = $false; $script:tray.Dispose()
	# (Optional) dispose context menu to release GDI handles
	try { if ($menu) { $menu.Dispose() } } catch {}
	[System.Windows.Forms.Application]::Exit()
})

# Left click balloon
$script:tray.add_MouseClick({
	param($s, $e)
	if ($e.Button -eq [System.Windows.Forms.MouseButtons]::Left) {
		if ($script:NeedsSetup) { [void](Show-SettingsDialog) }
		else {
			$subInfo = if ($State.SubPath) { "/$($State.SubPath)" } else { "/" }
			$varsBalloon = @{ server = $State.Server; drive = $State.Drive; sub = $subInfo; status = Get-TrayStatusCore $script:tray.Text }
			$title = $AppName; $text = (T 'tray.balloon' $varsBalloon)
			Show-CustomBalloon -Title $title -Text $text -TimeoutMs 6600
		}
	}
})

# Timer
$script:timer = New-Object System.Windows.Forms.Timer; $script:timer.Interval = [Math]::Max(5, [int]$State.IntervalS) * 1000
$script:timer.add_Tick({
	# Self-heal for portable mode after missing secret.dat
	if ($PortableMode -and $script:NeedsSetup) { if ((Test-Path $PortJson) -and (Test-Path $SecretPath)) { Refresh-NeedsSetup; if (-not $script:NeedsSetup) { $script:MissingSecretsPrompted = $false } } }
	# Keep deactivated flag in sync with real StartType
	Sync-WebClientDeactivatedFlag | Out-Null
	# Do not try to (re)map while WebClient service is deactivated
	if ($script:ServiceDeactivated) { $script:tray.Icon = $script:icoWarn; $script:tray.Text = T 'tray.service_deactivated' @{ app = $AppName }; return }
	if ($script:Paused) { $script:tray.Icon = $script:icoRed; $varsPaused = @{ app = $AppName; drive = $State.Drive }; $script:tray.Text = T 'tray.paused' $varsPaused; return }
	if ($script:NeedsSetup) { $script:tray.Icon = $script:icoWarn; $varsNS = @{ app = $AppName }; $script:tray.Text = T 'tray.needs_setup' $varsNS; return }
	# Portable: if Reset was triggered -> immediately open settings
	if ($PortableMode -and $script:ResetRequested) { $script:ResetRequested = $false; [void](Show-SettingsDialog); return }
	# Portable: reset prompt flag if files are back
	if ($PortableMode) { if ((Test-Path $SecretPath) -and (Test-Path $PortJson)) { $script:MissingSecretsPrompted = $false } }
	# Portable: if secrets or portable config are missing -> unmount, ask to quit once
	if ($PortableMode) {
		$missingJson = -not (Test-Path $PortJson)
		$missingSecret = -not (Test-Path $SecretPath)
		if ($missingJson -or $missingSecret) {
			try { Unmap-Drive } catch {}
			$script:NeedsSetup = $true
			if ($missingJson) { $State.Server = ''; $State.User = ''; $State.Drive = ''; $script:PlainPassCache = $null; try { Rebuild-Icons } catch {} }
			$script:tray.Icon = $script:icoWarn; $script:tray.Text = (T 'tray.secrets_missing' @{ app = $AppName })
			if (-not $script:MissingSecretsPrompted) {
				$script:MissingSecretsPrompted = $true; $ans = Ask-YesNoWarnT 'prompt.secret_file_missing_quit' @{ app = $AppName }
				if ($ans -eq [System.Windows.Forms.DialogResult]::Yes) {
					if ($miExit) { $miExit.PerformClick() }
					else {
						try { if ($script:timer) { $script:timer.Stop() } } catch {}
						try { Unmap-Drive } catch {}
						try { if ($script:mainMutex) { $script:mainMutex.ReleaseMutex() | Out-Null; $script:mainMutex.Dispose() } } catch {}
						$script:tray.Visible = $false
						$script:tray.Dispose()
						[System.Windows.Forms.Application]::Exit()
					}
					return
				} else { [void](Show-SettingsDialog) }
			}
			return
		}
	} else {
		$hasPwd = -not [string]::IsNullOrWhiteSpace($State.EncPass)
		# password exists again -> allow future prompts again
		if ($hasPwd) { $script:MissingPwdPrompted = $false }
		else {
			# no password stored anymore -> behave like portable "secret missing"
			try { Unmap-Drive } catch {}
			$script:NeedsSetup = $true
			# Tray yellow + text (needs a string)
			$script:tray.Icon = $script:icoWarn
			$script:tray.Text = T 'tray.password_missing' @{ app = $AppName }
			if (-not $script:MissingPwdPrompted) {
				$script:MissingPwdPrompted = $true
				$ans = Ask-YesNoWarnT 'prompt.password_missing_quit' @{ app = $AppName }
				if ($ans -eq [System.Windows.Forms.DialogResult]::Yes) {
					# reuse same clean-exit path wie im Portable-Teil
					if ($miExit) { $miExit.PerformClick() }
					else {
						try { if ($script:timer) { $script:timer.Stop() } } catch {}
						try { Unmap-Drive } catch {}
						try { if ($script:mainMutex) { $script:mainMutex.ReleaseMutex() | Out-Null; $script:mainMutex.Dispose() } } catch {}
						$script:tray.Visible = $false
						$script:tray.Dispose()
						[System.Windows.Forms.Application]::Exit()
					}
					return
				} else { [void](Show-SettingsDialog) }
			}
			return
		}
	}
	try {
		# use server status (offline / maintenance)
		$st = Get-NcServerStatus
		if (-not $st.Reachable) { if (Test-ValidDrive $State.Drive) { Unmap-DriveIfOurs -Force -RemoveProfile }; $script:tray.Icon = $script:icoRed; $varsOff = @{ app = $AppName }; $script:tray.Text = T 'tray.offline' $varsOff; return }
		if ($st.Maintenance) { if (Test-ValidDrive $State.Drive) { Unmap-DriveIfOurs -Force -RemoveProfile }; $script:tray.Icon = $script:icoRed; $varsMaint = @{ app = $AppName }; $script:tray.Text = T 'tray.maintenance' $varsMaint; return }
		# online (no maintenance) -> proceed as before
		if (Test-DriveAccessible) { $script:tray.Icon = $script:icoGre; $varsOn = @{ app = $AppName; drive = $State.Drive }; $script:tray.Text = T 'tray.online' $varsOn; try { Ensure-BrandingTick } catch {} }
		else {
			Unmap-DriveIfOurs
			if (Map-Drive) { try { Rebuild-Icons } catch {}; $script:tray.Icon = $script:icoGre; $varsOn2 = @{ app = $AppName; drive = $State.Drive }; $script:tray.Text = T 'tray.online' $varsOn2; try { Ensure-BrandingTick } catch {} }
			else { $script:tray.Icon = $script:icoRed; $varsFail = @{ app = $AppName }; $script:tray.Text = T 'tray.mapping_failed' $varsFail }
		}
	} catch { $script:tray.Icon = $script:icoRed; $varsErr = @{ app = $AppName }; $script:tray.Text = T 'tray.error' $varsErr }
})
$script:timer.Start()

# Start watchdog (only if none active for this PID)
$wdKey = "Local\{0}Watchdog-{1}" -f $AppName, $PID
try {
	[void][System.Threading.Mutex]::OpenExisting($wdKey)
	# already running for this PID
} catch {
	$exe = "$env:SystemRoot\System32\WindowsPowerShell\v1.0\powershell.exe"
	$args = "-WindowStyle Hidden -NoProfile -ExecutionPolicy Bypass -STA -File `"$PSCommandPath`" -Watchdog -MainMutexName `"$script:MainMutexName`" -OwnerPid $PID"
	Start-Process -FilePath $exe -ArgumentList $args -WindowStyle Hidden | Out-Null
}

# Exit hooks
$exitHandler = [System.EventHandler]{
	# optional, symmetrical unsubscription first
	try { [System.Windows.Forms.Application]::remove_ApplicationExit($exitHandler) } catch {}
	try { [AppDomain]::CurrentDomain.remove_ProcessExit($exitHandler) } catch {}
	# timer: stop + dispose
	try { if ($script:timer) { $script:timer.Stop(); $script:timer.Dispose() } } catch {}
	# drive unmap
	try { Unmap-Drive } catch {}
	# main mutex
	try { if ($script:mainMutex) { $script:mainMutex.ReleaseMutex() | Out-Null; $script:mainMutex.Dispose() } } catch {}
	# other mutex helpers (your existing calls)
	try { Release-MutexSafe $script:driveMutex } catch {}
	try { Release-MutexSafe $script:cfgMutex } catch {}
	try { if ($script:mapMutexObj) { if ($script:mapMutexOwned) { $script:mapMutexObj.ReleaseMutex() | Out-Null }; $script:mapMutexObj.Dispose() } } catch {}
	# icons/bitmaps
	try { if ($script:icoRed) { $script:icoRed.Dispose() } } catch {}
	try { if ($script:icoGre) { $script:icoGre.Dispose() } } catch {}
	try { if ($script:icoWarn) { $script:icoWarn.Dispose() } } catch {}
	try { if ($script:ServerFaviconBmp) { $script:ServerFaviconBmp.Dispose() } } catch {}
	try { if ($script:UserAvatarBmp) { $script:UserAvatarBmp.Dispose() } } catch {}
	try { if ($script:AppIcon) { $script:AppIcon.Dispose() } } catch {}
	# tray + menu
	try { if ($script:tray) { $script:tray.Visible = $false; $script:tray.Dispose() } } catch {}
	try { if ($menu) { $menu.Dispose() } } catch {}
}

[System.Windows.Forms.Application]::add_ApplicationExit($exitHandler)
[AppDomain]::CurrentDomain.add_ProcessExit($exitHandler)

[System.Windows.Forms.Application]::Run()
